"""«Комплект Автоматики» - программа, которая получает на входе бланк оборудования (допустимо использование бланков форматов docx, doc, rtf, pdf; рекомендуется первый формат), а на выходе даёт два бланка комплекта автоматики в формате docx – один для завода, второй – для заказчиков. В настоящий момент функционал программы ограничен: возможна обработка бланков кондиционеров ВЕРОСА, канального оборудования, общепромышленных и индустриальных вентиляторов, кроссплатформенность не гарантируется, стабильная работа возможна лишь на операционной системе Windows 10 и выше. Возможны критические ошибки при обработке крайне специализированных бланков - в таком случае рекомендуется ручной подбор.

Программа предусматривает несколько режимов работы: обработка одного бланка без предустановленных значений, обработка одного бланка с предустановленными значениями, обработка нескольких бланков. 

Глобально программа представляет собой одну функцию - main_part, которую можно импортировать. Она на выходе создаёт два бланка и сводную таблицу
"""

# ============================== ПРОЛОГ ==============================
# Чтобы полностью разобраться в этой программе, я напишу подробные коментарии ко всему, что здесь происходит. Это полностью противоречит духу и принципам "чистого когда", но я считаю, что избыточные и чрезмерно подробные комментарии жизненно необходимы в данной программе. Начну с того, что данное повествование будет скакать от места к месту, но каждая часть будет озаглавена в нужном порядке, так что если за одной главой будет следовать не следующая глава, то это значит лишь одно - надо будет найти эту следующую главу, после неё отправиться на поиски последующей главы, и так далее, пока не встретие эпилог. В качестве помощи могу сказать, что названия глав у меня пронумерованы РИМСКИМИ цифрами, и конструкция надписи начала главы такая: '============================== ГЛАВА номер_главы_римскими_цифрами =============================='. Можно заметить, что можно искать номер главы через Ctrl+F как, например, ' I ', ' II ', ' X ' - с ПРОБЕЛАМИ в начале и конце, чтобы было проще (не находите ли, что это и в самом деле элегантнее?).

# import PySimpleGUI as sg  # Традиционно я сначала объявляю свой модуль, потом пандас, а затем - то, что потребно в программе, однако тут я сначала импортировал модуль по созданию оконной формы, потому что ради этой оконной формы, ради удобства конечному пользвателю, это всё и затевалось
import pandas as pd  # Пандас - он и в Африке пандас
import vezamodule as vm  # Мой модуль - моя гордость, труд долгих часов работы. Ныне уже не мой модуль, а везовский модуль. Тут самое важное - класс Бланк, который и возвращает всю информацию из бланка. За информацией о том, как работает мой модуль, прошу проследовать в сам модуль
import os  # На всякий случай спешу уточнить, что данная программа приспособлена для работы в Виндоус, и кроссплатформенность не гарантируется. В связи с текущей обстановкой, переход на Линукс может стать необходимостью, тогда я лишь надеюсь, что удастся решить данную проблему
import re  # Хоть я из всего разнообразия модуля ре использую преимущественно только файндолл, я импортирую его целиком, ибо верю, что использую потенциал регулярных выражений лишь на сотые доли процента. Я верю, что их можно использовать эффективнее
from docx import Document  # Полностью отказаться от этого модуля не получится ни при каком желании. Отсюда мне нужен минимум способ создания документа-объекта
from docx.opc.exceptions import PackageNotFoundError  # А как максимум ещё и эта специфическая ошибка
from json import load  # В программе используются json-файлы, но я просто выгружаю из них информацию
from time import perf_counter  # Время от времени я использую либо перфкаунт для подсчёта скорости вычисления
from itertools import takewhile, pairwise  # Используется только тейквайл, но какая же это прекрасная штука!
from datetime import date  # Из всего функционала мне нужны, в первую очередь, возможности отсчитывать сегодняшнюю дату. 
from vezamodule import DocxExpand as de, PrintDebugModeOn as pdmo  # Снова мой модуль, откуда я импортирую два довольно любопытных класса. Первый - ДоксЭкспандер, состоит из разнообразных вспомогательных статических функций, которые расширяют потенциал модуля docx. А вот второй - класс-функция ПринтДебагМодОн - вызывает принт только если активен режим отладки, причём эта активация встроена в саму природа класса, что позволяет менять поведение всего класса дистанционно
from zipfile import BadZipFile  # Зип-файлы вообще штука очень крутая и прикольная, но конкретно тут мне нужна только эта ошибка, которая возникает при обработке докс-файлов. Почему же такая ошибка зип-файлов возникает в доксах? Всё просто - докс это зип. Суровый мелкомягкий костыль

# Пролог на этом не кончается. После объявления модулей надо объявить ряд констант, которые будут использоваться на протяжении всей последующей программы. Эти глобальные переменные представляют собой адреса папок, импортированные json и csv файлы. Зачем вообще их тут так объявлять? Связано это с тем, что программу можно использовать в качестве своеобразного модуля, подставлять её в другие программы, что Руслану очень даже удалось. Для этого, собственно, всё, что эта программа делает и так, вынесено в "главную функцию" (в Питоне этой функции в виде, как в С-языках, нет, но, по сути, она есть). А главная функция у меня находится в самом-самом-самом-самом-самом-САМОМ конце программы. и самый смак происходит в других функциях.

VERSION = '2.5.6'  # Номер серии. Изменяется по моему усмотрению в соответствии с моим ощущением новизны
WORKING_FOLDER = 'working_files'  # Как следует из названия, рабочая папка, где находятся все рабочие документы, содержащие ту или иную необходимую информацию
TEST_FOLDER = '_ТЗ_для программы'  # Как следует из названия, папка для тестовых бланков. Была вынесена отдельно по простой причине - именно наличие или отсутствие данной папки сигнализирует программе о том, что она была запущена не в рабочем пространстве, а где-то либо в другой папке, либо вообще на другом компьютере. Ради всего святого, я искренне надеюсь, что не у всех на компьютере есть папка под названием "_ТЗ_для программы", которая ещё и лежит каким-то волшебным образом в той же папке, что и программа подбора автоматики, потому что если есть, то я начну очень серьёзно сомневаться в человечестве
RESULT_FOLDER = 'Готовые бланки'  # Как следует из названия, папка, где аккумулируются все готовые бланки. Была мысль для каждого бланка делать подпапку, это не так сложно, однако реальной потребности в этом так и не возникло, так что добавление подпапок остаётся на усмотрение.

with open(f'{WORKING_FOLDER}/codes.json', encoding='utf-8') as file:
    CODES = load(file)  # json-файл нужен ради одного - создать огромный словарь. В данном файле содержатся все коды, обозначения для каждого из пункта обозначения шкафов.. В бумажной версии это записано как "Кодирование состава системы и технических характеристик для КА". Всё это приложение перенесено в json-файл, иерархия которого может показаться отличной от того, как оно изложено в таблице, однако на то есть одна очень серьёзная причина, имя которой - ручной ввод данных, о чём будет сказано много позже. Почему не запихнуть это всё внутрь кода? Я хочу оставить возможность редактировать обозначения на случай, если они изменятся - достаточно будет просто открыть json-файл в Блокноте и осторожно изменить содержимое внутри кавычек. Можно даже позволить себе через блокно добавлять новые разделы, если есть понимание, что такое json-файл.
CODES_WITH_CODES = {f'1.{i + 1}' : value for i, value in enumerate(CODES.values())}  # Создание дополнительного словаря кодов, где все ключи заменены на номер по таблице из бланка для завода... Я только что понял, что бланки для завода и заказчика объявляются позже по тексту внутри главной функции, так что пока просто примите на веру тот факт, что данное объявление абсолютно необходимо
with open(f'{WORKING_FOLDER}\\codes_for_blank.json', encoding='utf-8') as file:
    CODES_FOR_BLANK = load(file)  # Одно из самых важных мест. Второй файл представляет собой почти точную копию первого, однако в котором все словари самых внутренних уровней заменены на пустое значение словаря верхнего уровня. Возможно, чтобы осознать полную наглядность происходящего, надо будет просто выставить два словаря рядом на экране, чтобы понять, о чём речь. Опять же, объяснение существование данного словаря - ручной ввод данных, о чём будет сказано гораздо_гораздо позже.
CODES_FOR_BLANK_WITH_CODES = {f'1.{i + 1}' : value for i, value in enumerate(CODES_FOR_BLANK.values())}  # Создание копии предыдущего словаря, но где ключи - номера из таблицы по бланку. Пока данную информацию нужно просто держать в голове.
CODES_FOR_BLANK_WITH_CODES_CLEAR = __import__("copy").deepcopy(CODES_FOR_BLANK_WITH_CODES)  # Создание глубинной копии словаря, импортированного из json-файла. Этот пустой словарь нужен будет ровно в одном месте

# Дальше идёт блок создания справочных матриц, содержащих информацию, необходимю для расчёта той или иной информации
MAIN_DF = (df.values.tolist() for df in pd.read_excel(f'{WORKING_FOLDER}/СПРАВОЧНАЯ ИНФОРМАЦИЯ.xlsx', None).values())  # Очень долгое время у меня вся информация была разбита по несколькими экселевским файлам. Теперь оно содержится всё в одном, и оно как работает? Я забираю все листы, и оно записывается в словарь, где ключ - это то ли название листа, то ли индекс листа (в этом случае нас такие мелочи не волнуют), а значение - датафрейм. Так что я преобразую словарь в значения словаря (какой-то очень мутный тип, который индексов не имеет и сам генератором не является), датафреймы перевожу в двухмерные списки, а потом обращаю это в генератор. Проще всего было бы всем переменным сразу в одной строке передать значения, но так как мне нужно расписать каждый шаг, объяснить каждую таблицу, то я это разбил на проход по генератору до полного его исчерпания. Если захотите добавить новые листы, то ради бога, блядь, добавляйте в КОНЕЦ ЭКСЕЛЕВСКОГО ФАЙЛА. Если вы, конечно, хотите ебаться с тем, в каком порядке что следует, флаг вам в руки и барабан под мышку, но если из-за этого вы проебётесь - я предупреждал. И решите удалить какую-то таблицу - удаляйте и весь лист, и всю переменную, и весь некст.
SHLANG_DATA = next(MAIN_DF)  # Таблица подбора шлангов. Забегая вперёд, надо сказать следующее - не для всех индексов ВЕРОСА возможно подобрать шланг, поэтому шланги подбираются для промежуточных вариантов по хитрой схеме. Пока достаточно лишь знать, что программа считает и длину шланга
VECTOR_DATA = next(MAIN_DF)  # Таблица, представляющая собой очень сухую выжимку таблиц про ВЕКТОРа из соответствующего каталога. В данной программе самое важное - подобрать нужный типоразмер по заданной схеме, и извлечь информацию по движку (или что там в этом ВЕКТОРе находится, я без понятия). Ещё где-то тут была таблица про Белимы, но она отпала за ненадобностью
ENGINE_DATA = next(MAIN_DF)  # Это преобразованная в удобный для пандаса вид таблица-подбора двигателя. Если кто-то видел ту таблицу, то должен знать, что переключение через полюсами осуществлялось через нажатие кнопочки. Это капец как неудобно, так что все варианты полюсов вынесены рядом друг с другом.
FUNCTION_DIAGRAM_NUMBER_DATA_100 = next(MAIN_DF)  # Таблица, выбирающая функциональную схему для ВЕРСА-100. Логика в том, что для ВЕРСА-100 существует довольно ограниченный набор вариантов развития событий, и хоть сама маркировка предстваляет собой "ФХХХ", где ХХХ - трёхначное число, все эти числа отличаются друг от друга на 30 в зависимости от определённого условия. Пока что это не играет значительной роли, когда об этом зайдёт речь, я подробно всё распишу.
FUNCTION_DIAGRAM_NUMBER_DATA_200 = next(MAIN_DF)  # То же самое, но для ВЕРСА-200. Там логика выбора отличается, но несильно - просто иные параметры.
FUNCTION_DIAGRAM_NUMBER_DATA_300 = next(MAIN_DF)  # То же самое, что для ВЕРСА-200, но для ВЕРСА-300. Логика будет схожей с 200
CABINET_MOTOR_INDEX_DATA = next(MAIN_DF)  # Таблица выбора индекса для ВЕРСА. Индексы движков для ВЕРСА одинаковы в обоих случаях. Самый интересный пункт той таблицы - записанные текстом формулы - это сыграет свою роль позже.
CHANNEL_ENGINE_ROTATION_DATA = next(MAIN_DF)  # Таблица оборотов двигателей для канального оборудования, потому что в веросах обороты указываются, а в канальном - нет
CHANNEL_ELECTRIC_HEATER_DATA = next(MAIN_DF)  # Таблица необходимых характеристик для электронагревателей каналок

FILE_PIVOT_TABLE = 'Сводная таблица.xlsx'  # По требованию заказчиков из отдела автоматики, им крайне потребна свооебразная сводная таблица, где каждая строчка - нужная информация по данной ВЕРОСЕ.
PIVOT_TABLE_COLUMNS = (  # Здесь представлены заголовки - то, что нужно им видеть в свододной таблице
    '№',  # Исключительно техническая информация, просто порядковый номер внутри самой таблицы, от неё можно смело отказаться
    '№КА',  # Номер шкафа - представляет собой конструкцию "КА" + "названиеОПР"
    'Обозначение по ТУ ВЕЗА',  # Представляет собой конструкцию, которая добавляется в бланк для заказчиков
    'Обозначение по СПА',  # Своеобразная сухая выжимка того, что заносится в таблицу в бланке для завода
    'Стоимость ШСАУ, евро. с НДС прайс',  # Цена комплекта автоматики. Увы, нереализуемо на текущем уровня технического развития
    'ВЕРСА',  # Обозначение версы, если верса в данном случае применима
    'Стоимость ВЕРСА, евро. с НДС прайс',  # Цена на версу - снова нереализуемо
    'Узел ВЕКТОР (нагреватель)',  # Если есть узел-нагреватель, то он записывается сюда
    'Узел ВЕКТОР (охладитель)'  # Если есть узел-охладитель, то он записывается сюда
)
DF_RESULT = pd.read_excel(FILE_PIVOT_TABLE) if os.path.exists(FILE_PIVOT_TABLE) else pd.DataFrame(columns=PIVOT_TABLE_COLUMNS)  # Для добавления новой информации в сводную таблицу, я использую эксельрайтер из пандаса, а для этого надо иметь датафрейм. Если файл уже существует, то я просто забираю оттуда информацию, ну а если нет - создаю пустой датафрейм с колонками.

TABLE_MAIN_CONTENT_1_KEYS = ['Объект', 'Заказчик', 'E-mail', 'Телефон/Факс', 'Для', 'Система', 'Контроллер', 'Разработчик от "ВЕЗА"', 'Подпись разработчика', 'МЕНЕДЖЕР', 'Типовое схемное решение:']  # Заголовочная таблица в двух бланках выглядит практически одинаково, но отличается некоторыми пунктами, поэтому гораздо проще было создать сначала один список с заголовками, а сразу за ним - другой. Это делается в основном теле программы по простой причине - эта информация потребуется не только внутри главной функции, но в функции оконной формы.
TABLE_MAIN_CONTENT_2_KEYS = TABLE_MAIN_CONTENT_1_KEYS[0:4] + ['Для специалиста по автоматике'] + TABLE_MAIN_CONTENT_1_KEYS[7:10]  # Об этой строчке я уже сказал в предыдущем абзаце

PIVOT_INDEX = 1  # Тот самый индекс, который заносится в столбец "№" в сводной таблице. Исключительно техническая информация
KA_NUMBER_NUMBER = 0  # Итак, по просьбе Николая я сделал так, чтобы в случае не-Верос (обычно у Верос есть этот номер из 1С или типа того) можно было записать номер, с которого начинается потом последовательность. Стартовое значение - ноль, оно же ложь, что нам ещё понадобится потом
INNER_DELIMITER = ' + '  # Все множественные однотипные детали внутри одного пункта делятся через этот делиметр на тексте. Делиметр можно изменить по требованию заказчика

# Закончив с вводом глобальных переменных и констант, можно переходить к многочисленным функциям. Первой на очереди - "тест_автомата", где происходит тестировка и отладка работы программы.
# ============================== КОНЕЦ ПРОЛОГА ==============================

# ====================================================================================================================================================================================

class TestValues():
    """Отдельно вынесенные тестовые данные, которые можно импортировать в том или ином виде для экспериментов
    """
    
    all_test_files_VEROSA = tuple(f'{TEST_FOLDER}\\Веросы\\' + file for file in (  # Тут лежат ссылки на абсолютно все, мать его, бланки. Если нужно протестировать лишь один из них, то нужно будет дальше по ходу дела указать. К каждому из бланков обычно прилагается комментарий, ради чего он нужен, но не ко всем - ко многим я уже всё напрочь забыл. Почему кортеж? Он никак не будет меняться по ходу событий, так что смысл мне держать ради такого целый массив? Почему, мать его, генератор? Меня заебало каждый раз копировать и вставлять название папки, тем более что теперь все бланки по Веросам переехали в соответствующую папку, так что разделение на два разных генератора исчезло
        'Бланк1\\211027853-ОПР АЭРОПРОЕКТ (Реконстр. аэропортового комплекса Чертовицкое г.Воронеж ОАСС).docx',  # 0 - самый первый бланк, самый базовый и очень даже простой
        'Бланк1.5\\211012073-ОПР АПБП (Складской комплекс ООО ЛА МАРЕ г. Москва, ул. Складочная д.15).docx',  # 1 - был найден мной, содержал в себе несколько однотипных вещей
        'Бланк2\\201006039-ОПР Ташир ГК(Апарт-Отель г.Ярославль).docx',  # 2 - ещё один базовый пример, в котором есть что-то, а ещё это нетиповой бланк, записанный через жопу
        'Бланк3\\1_211043062б-ОПР ИНИЦИАТИВА ИНЖПРОЕКТ (ст.Каширская Западный Вестибюль).docx',  # 3 - тот бланк, который в своё время вырвал Юрий и сунул автоматчикам. Тут как минимум есть приточный и вытяжной вентилятор
        'Бланк4\\201019804-ОПР М-ПРОЕКТ(ГАУДО Домисолька  г. Москова, ул. Новохорошевский проезд, д.1).docx',  # 4 - ещё один бланк-образец
        'Бланк4.5\\18.10.39112г-ОПР МосводоканалНИИпроект(Южно-Бутовские очистные сооружения).docx',  # 5 - тут есть ЖТУ
        'Бланк5-8\\1.6. Паровой ТО.docx',  # 6 - тут паровой ТО
        'Бланк5-8\\1.7. 221041641а-ЧХВ.doc',  # 7 - тут электронагреватель
        'Бланк5-8\\1.8. 221038959-ЧХВ.doc',  # 8 - тут жидкостный охладитель, а ещё тоже блок с двумя клапанами, где один должен быть вертикальным, а другой - горизонтальным
        'Бланк5-8\\1.11. 201014747а-ОПР Мосэлектронпроект(Раменское приборостроительное конструкторское бюро).docx',  # 9 - тут форсуночный увлажнитель
        '221027639д-ОПР ФАРМ ДИЗАЙН ООО (Виварий) П1С осн, В1С осн.doc',  # 10 - зато тут есть ЖТУ и пропиленгликоль 50% в векторе
        '221027641д-ОПР ФАРМ ДИЗАЙН ООО (Виварий) П2С осн, В7С осн.doc',  # 11 - зато тут есть ЖТУ и пропиленгликоль 50% в векторе
        '221029071-ОПР ЭВЕРГРИН ООО (Клиника АО Группа комп. Медси г. Москва, ул. Новочеремушкинская д. 16).doc',  # 12
        '221020111-ОПР ВНИПИПРОМТЕХНОЛОГИИ АО (Рудник 6, Забайкальский край, г. Краснокаменск).doc',  # 13
        '(...АВдв...)\\201012404-ОПР Ремстрой СК Производство средств защиты растений и семеноводства  Сингента  Липецкая область.docx',  # 14
        '(...-ТР-ТО-ХО_...)\\201003971-ОПР СТРОЙКАПИТАЛИНВЕСТ (Молочный комбинат, Таджикистан, Душанбе. ул. Мясо).docx',  # 15 - тут как минимум есть ВЕРСА-200!
        '(...-ФО-...)\\211016218а-ОПР МОСОБЛГИДРОПРОЕКТ (Столовая, Корпанга в п. Яковлево, Белгородской обл).docx',  # 16
        '(...-ЭК-...)\\201034027-ОПР Гидропроект (Среднеахтубинская ГЭС Здание СПК).docx',  # 17 - тут каким-то макаром обнаружился Эйрмейт!!!
        '(Вв-Кв)\\201028426-ОПР Прогресстех(Аэропот г.Сочи).docx',  # 18
        '(К-КР-Ф-В-...)\\201028511а-ОПР Гидропроект (Среднеахтубинская ГЭС Здание СПК).docx',  # 19
        'БЗ\\221057131-ОПР В1.1 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 20 - целая череда непонятных бланков, которые сейчас нужны лишь для создания массовости и продолжительности тестов - вроде ничего интересного в них нет, но, главное, чтобы из-за них ничего не вылетало. Массовка тоже важна в нашем нелёгком деле.
        'БЗ\\221057132-ОПР В1.2 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 21 - целая череда непонятных бланков, которые сейчас нужны лишь для создания массовости и продолжительности тестов - вроде ничего интересного в них нет, но, главное, чтобы из-за них ничего не вылетало. Массовка тоже важна в нашем нелёгком деле.
        'БЗ\\221057133-ОПР В5.1 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 22 - целая череда непонятных бланков, которые сейчас нужны лишь для создания массовости и продолжительности тестов - вроде ничего интересного в них нет, но, главное, чтобы из-за них ничего не вылетало. Массовка тоже важна в нашем нелёгком деле.
        'БЗ\\221057134-ОПР П1.1 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 23 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!), и даже только фреоновый охладитель
        'БЗ\\221057135-ОПР П1.2 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 24 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!), и даже только фреоновый охладитель
        'БЗ\\221057136-ОПР ПВ2.1 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 25 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!)
        'БЗ\\221057137-ОПР ПВ2.2 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 26 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!)
        'БЗ\\221057138-ОПР ПВ3.1 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 27 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!)
        'БЗ\\221057139-ОПР ПВ3.2 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 28 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!)
        'БЗ\\221057140-ОПР ПВ4.1 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 29 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!)
        'БЗ\\221057141-ОПР ПВ4.2 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 30 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!)
        'БЗ\\221057142-ОПР П5.1 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 31 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!), и даже только фреоновый охладитель
        'БЗ\\221057136а-ОПР ПВ2.1 ТЕРМОКУЛ (Мираторг Овощи Тульская обл).doc',  # 32 - оказалось, что тут и пропиленгликоль 35% (это будет очень важно!)
        '1\\221035275-ОПР ВЕНТМОНТАЖ ООО (ТЦ,Тарутинский. г.Калуга, ул.Тарутинская, д.1).doc',  # 33
        '221057784-ОПР П5 ГАЗПРОМ ТРАНСГАЗ Центр Диагностики и Реабилитации Воскресенкс.docx',  # 34
        'Ебаный Снежинск\\221039308-ОПР П1 31ГПИСС (Челябинская обл, г. Снежинск.).doc',  # 35
        '221056572-ОПР ПВ1 КАЛУГАГЛАВСНАБ (Складское помещение, Апрелевка).doc',  # 36
        '221057896-ОПР ИК НИИ КВОВ (ОС 2. Рек-ция объектов аэропортового комплекса Геленджик) П1.doc',  # 37 - тут два электронагревателя и лажа с ВЕРСАми
        'Ебаный Снежинск\\221039459-ОПР П20 31ГПИСС (Челябинская обл, г. Снежинск.).doc',  # 38 - треклятый Снежинск, с которым всё всегда идёт через жопу. В нём есть поток резерв, в нём есть несколько сложных и странных условий. 
        '211037566-ОПР В1\\211037566-ОПР В1 (1).docx',  # 39 - тут поток резерв и лишь два блока перехода - до двигателей. А ещё какая-то хрень с датчиками
        '221049161-ОПР П1.3В1.3 Гипроздрав (ЖД район Останкинский, ул. Бочкова, влд. 11А)\\221049161-ОПР П1.3В1.3 Гипроздрав (ЖД район Останкинский, ул. Бочкова, влд. 11А).doc',  # 40
        '221054633-ОПР ПВ1\\221054633-ОПР ПВ1 ГРОСС ИНЖИНИРИНГ (Гостиница Комета. г.Москва, ул. Космонавта Волкова, 14 ).doc',  # 41 - тут тоже что-то не слава богу
        '211043780б-ОПР М1\\211043780б-ОПР М1 ПРОЕКТ ООО (Центр ядерной медицины г. Екатеринбург) П3.doc',  # 42 - тут выполняется то сложное условие, которое запрашивает режим работы. А ещё тут не ловится частотник. И вообще бланк говно.
        '221032574-ОПР\\221032574-ОПР Исток (НПП Исток им. Шокина, Корус 150).doc',  # 43 - тут много векторов, надо по-умному задать
        'КСп-Ф-ТО-В\\221020111-ОПР ВНИПИПРОМТЕХНОЛОГИИ АО (Рудник 6, Забайкальский край, г. Краснокаменск).doc',  # 44
        '221057628-ОПР ПВ1.1 ВАВИЛОН (ЖК Вернадский, пр-т Вернадского, 41).doc',  # 45
        'Северное исполнение с ЭК\\221025299-ОПР АРСЕНАЛ ПЛЮС ООО (ВЛ 110кВ Певек-Билибино).doc',  # 46 - всё ещё лажа с клапанами...
        'Северное исполнение с ЭК\\221056390-ОПР П1 МОЛЛТЕК ООО (ТДЦ Планета. г. Красноярск, ул. 9 Мая, 77).doc',  # 47
        'П11 221058821-ОПР  Испытательный Центр Стройэксперт (Детский сад, Ашукино).doc',  # 48 - проблема с температурой 1.7
        'П12 221058210а-ОПР Испытательный Центр Стройэксперт (Детский сад, Ашукино).doc',  # 49
        '221051925-ОПР П2 ДАТАПРО (ЦОД, Москва, ул. Рябиновая 53с3).doc',  # 50 - вроде работает
        '221049162-ОПР П1.4 Гипроздрав (ЖД район Останкинский, ул. Бочкова, влд. 11А).doc',  # 51 - вроде работает
        'Ебаный Снежинск\\221041604а-ОПР П2 31ГПИСС (Челябинская обл, г. Снежинск.).doc',  # 52 - вылетало на свитчинг - вообще тут даже не резервный вентилятор, а резервная установка, что ещё веселее!!!
        '221050709-ОПР\\221050709-ОПР П1 БИС - БАЛАНС ИНЖЕНЕРНЫХ СИСТЕМ (РОССЕЛЬХОЗБАНК г. Москва, Пресненская наб. д10стр2 ).doc',  # 53 - тут что-то с версами?
        '221040736а-ОПР ПВ4 МЭЙДЖЕРЭНЖЕНЕР (ЖК г. Москва, Пр. Вернадского, у ст.метро Юго-западная).doc',  # 54
        '221040737а-ОПР ПВ7 МЭЙДЖЕРЭНЖЕНЕР (ЖК г. Москва, Пр. Вернадского, у ст.метро Юго-западная).doc',  # 55
        '231002679-ОПР ИНЖИТЭКСТРОЙ (Завод сухих смесей г. Воскресенск) П1.doc',  # 56 - раньше думали, что тут ошибка, но он всё делает правильно, так что мы не будем тут ничего делать, оно и так идеально! Просто стал массовкой
        '221057000-ОПР\\221057000-ОПР 1А-КОР-П1 ВИС СТРОЙТЕХ (Арктический центр).doc',  # 57 - ещё одно северное исполнение, на котором будет отрабатываться навыки определения пропиленгликоля и всякое такое
        '221056841-ОПР\\221056841-ОПР 5Ф-ФИЛ-ПВ1 ВИС СТРОЙТЕХ (Государственная Филармония Якутии).doc',  # 58 - похож на предыдущий, но, в целом, работает как положено
        '231000811-ОПР\\231000811-ОПР V-FO-0001A ЛИМАК КОНСТРАКШН (ГПК в сост. комплекса переработки этансодерж. газа Усть-Луга).docx',  # 59 - тут есть блок, в котором два клапана. Первый должен быть обычным, потому что вертикальным, а другой - рециркуляционным, потому что горизонтальный, и там и там есть SR
        'П7 201035150г-ОПР М1 Проект (Медцентр, Оренбург, ул. Зиминская, д. 35).docx',  # 60 - тут программа вылетает
        '201008606-ОПР\\201008606-ОПР ГРИБАНОВ В.В (Кафе Лаборатория,ул.Земляной Вал).docx',  # 61 - тут нормально расписанное ЖТУ, аллилуя!!!
        '231004130-ОПР П1 ВБ-СЕРВИС ООО (Офис, г.Москва, ул. Магистральная д.17 стр4).doc',  # 62 - тут программа вылетает из-за дебильной фильтрации!!!
        '231004178-ОПР В1.3 ИСО СКП (Республиканская детская клиническая больница г. Сыктывкар ).doc',  # 63 - взрывозащита, не должен подбираться бланк...
        'БЗ Регион\\17.10.36528-ННВ.doc',  # - 64 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\17.10.36529-ННВ.doc',  # - 65 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\17.13.01320-ННВ.doc',  # - 66 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\191010470в-СПБ.doc',  # - 67 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\191010471б-СПБ.doc',  # - 68 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\211022081-ПРМ.doc',  # - 69 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\211022083-ПРМ.doc',  # - 70 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\211033573б-САР.doc',  # - 71 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\211033716б-САР.doc',  # - 72 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\221002659-САР.doc',  # - 73 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\221002664-САР.doc',  # - 74 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\221016908а-СПБ.doc',  # - 75 бланки из регионов, просто проверка работоспособности
        'БЗ Регион\\221023835-СИМ.docx',  # - 76 бланки из регионов, просто проверка работоспособности - не работал, потому что дебильный док или типа того, так что я перегнал в докс-формат (и советую это делать в таких случаях, если оно вылетает и это док или ртф)
        '231006347-ОПР\\231006347-ОПР П2 ПАРАДИГМА ООО (Санаторий «Марьино» Управления делами Президента РФ).doc',  # 77 - тут два вентилятора, два двигателя и ещё какая-то лажа с капиллярами...
        '231001558а-ОПР\\231001558а-ОПР П1 СТАНДАРТПРОЕКТ (ЖД, Москва,Соколиная гора, ул. Вольная, вл. 285).doc',  # 78 - тут проблема с тем, что у нас резервный двигатель не находится и не определяется - надо снова поработать на эту тему. Поработал, вроде работает
        '211006810в-ОПР П1(К) НИИПРОЕКТ ГБУ МО (Поликлиника Хотьково, КДЦ).doc',  # 79 - тут обнаружилась такая ерунда, что в первом фильтре осведения не было, но оно всплыло во втором и третьем...
        '231006136а-ОПР ПВ7 ТПОРЕЗЕРВ ООО (СОШ  в мкр.Павшинская пойма г.о.Красногорск ).doc',  # 80 - тут придётся всё-таки придумать, как быть с фильтрами...
        'ФИТО ООО НПФ\\211035945а-ОПР П4 ФИТО ООО НПФ(Тепличный комбинат ТюменьАгро дер.Нариманова).doc',  # 81 - с ними всё хорошо, но пусть будут для массы
        'ФИТО ООО НПФ\\211023816б-ОПР П1 ФИТО ООО НПФ(Тепличный комбинат ТюменьАгро дер.Нариманова).doc',  # 82 - с ними всё хорошо, но пусть будут для массы
        'ФИТО ООО НПФ\\211023817б-ОПР ФИТО ООО НПФ(Тепличный комбинат ТюменьАгро дер.Нариманова).doc',  # 83 - с ними всё хорошо, но пусть будут для массы
        'ФИТО ООО НПФ\\211023818б-ОПР П3 ФИТО ООО НПФ(Тепличный комбинат ТюменьАгро дер.Нариманова).doc',  # 84 - с ними всё хорошо, но пусть будут для массы
        'СТРОЙСФЕРА ООО\\231010824-ОПР К2 СТРОЙСФЕРА ООО (ЦКБ Управления делами Президента РФ).doc',  # 85 - тут резервные вентиляторы и почему-то возникла лажа с обозначениями. Оказалось, беда была в том, что я не исправил несколько проблем, возникшие из-за опрометчивого переименования переменной code в key
        'СТРОЙСФЕРА ООО\\231010823-ОПР К1 СТРОЙСФЕРА ООО (ЦКБ Управления делами Президента РФ).doc',  # 86 - тут резервные вентиляторы и почему-то возникла лажа с обозначениями. Оказалось, беда была в том, что я не исправил несколько проблем, возникшие из-за опрометчивого переименования переменной code в key
        '231013284а-ОПР К1.1 МАКСПРОЕКТ (Хирургический корпус 2-й градской больницы, Москва, Ленинский просп, д10, к12).doc',  # 87 - не находилась температура, оказывается, она была записана со звёздочкой. Зубёзудочука
        '231010994-ОПР ПОДЗЕМПРОЕКТ(НПП Исток им. Шокина)П30.2.docx',  # 88 - новый бланк - надо понять, как он работает. Работает превосходно
        'пример с бз\\231008488-ОПР ПД14.1А ЦНИИПРОМЗДАНИЙ (Зона активного отдыха, Ноябрьск, ЯНАО).doc',  # 89 - тут про ШКВАЛы
        'пример с бз\\231008489-ОПР ПД9.1А ЦНИИПРОМЗДАНИЙ (Зона активного отдыха, Ноябрьск, ЯНАО).doc',  # 90 - тут про ШКВАЛы
        'пример с бз\\231008490-ОПР ПД13Б ЦНИИПРОМЗДАНИЙ (Зона активного отдыха, Ноябрьск, ЯНАО).doc',  # 91 - тут про ШКВАЛы
        '231024147-ОПР ПВ1 ИРМАСТ-ИНЖИНИРИНГ (Реконструкция аэропортового комплекса Орел Южный).docx',  # 92 - какая-то залупа с Версами
        '231020884-ОПР ПВ1\\231020884-ОПР ПВ1 ПРОЕКТ МСК  (Высотное офисное здание. г.Москва Ул. Иловайская).doc',  # 93 - тут засада с резервными вентиляторами и гермиком на резерве
        'Корпус А1\\231027398-ОПР A1.В1.1 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 94 - тут должен быть основной/резервный вентилятор
        'Корпус А1\\231027399-ОПР A1.В1.2 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 95 - 
        'Корпус А1\\231027400-ОПР A1.В2.1 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 96 - 
        'Корпус А1\\231027401-ОПР A1.В3.1 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 97 - 
        'Корпус А1\\231027402-ОПР A1.В5.1 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 98 - 
        'Корпус А1\\231027403-ОПР A1.В5.2 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 99 - 
        'Корпус А1\\231027404-ОПР A1.В7 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  #  100 - 
        'Корпус А1\\231027405-ОПР A1.В8.1 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 101 - 
        'Корпус А1\\231027406-ОПР A1.В9.1 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 102 - 
        'Корпус А1\\231027407-ОПР A1.ВА12 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 103 - 
        'Корпус А1\\231027629-ОПР A1.ПД4.2 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 104 - тут надо "проработать алгоритм для зоны МГН"
        'Корпус А1\\231027630-ОПР A1.П4 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 105 - 
        'Корпус А1\\231027631-ОПР A1.П8 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 106 - 
        'Корпус А1\\231027632-ОПР A1.П9 СЗ ГРАНДСОЮЗИНВЕСТ (МЖК г.Москва, Лужнецкая набережная 24 ).doc',  # 107 - 
        '231028713-ОПР ПВ1 МКС (Производственное здание г.о. Подольск, с. Сынково, 81).doc',  # 108 - "Вот у этого бланка клапан в КА не вылез и для ТО вектор не подобрался. И для роторного теплоутилизатооора контроля по перепаду нет"
        '231031697-ОПР.doc',  # 109 - какого-то хера сбилась нумерация
    ))

    all_test_files_CHANAL = tuple(f'{TEST_FOLDER}\\Каналка\\' + file for file in (  # А тут, стало быть, бланки на каналку. Забыл сказать, что очень долгое время эта программа тестировалась на Веросах, именно им уделено основное внимание. И мне надоело каждый раз при создании файла писать вначале путь к папке, поэтому пусть за меня это делает генератор списков! Да, новые значения добавлять во внутренний кортеж
        'В4Мед - Таня.docx',  # 0 - самые первые бланки, которые мне дала Таня, максимально простой
        'ПВитп - Таня.docx',  # 1 - самые первые бланки, которые мне дала Таня, тут приток и вытяжка
        'П1 - Рус.docx',  # 2 эти бланки мне дал Руслан, есть жидкостный нагреватель, но гликоль 45%
        'П2 - Рус.docx',  # 3 эти бланки мне дал Руслан, есть жидкостный нагреватель, но гликоль 45%
        'П3 - Рус.docx',  # 4 эти бланки мне дал Руслан, есть жидкостный нагреватель, но гликоль 45%
        'П4 - Рус.docx',  # 5 эти бланки мне дал Руслан, есть жидкостный нагреватель, но гликоль 45%
        'П5 - Рус.docx',  # 6 эти бланки мне дал Руслан, есть жидкостный нагреватель, работает на воде
        'П7 - Рус.docx',  # 7 эти бланки мне дал Руслан, есть жидкостный нагреватель, работает на воде
        'П8 - Рус.docx',  # 8 эти бланки мне дал Руслан, есть жидкостный нагреватель, работает на воде
        'П2 - Таня - 1.docx',  # 9 - электронагреватель
        'П2 - Таня - 2.docx',  # 10 - ещё электронагреватель
        'П3 - Таня - 1.docx',  # 11 - нагреватель водяной
        'П3 - Таня - 2.docx',  # 12 - электронагреватель
        'ПВ3А - Таня.docx',  # 13 - приток и вытяжка
        'П5 - Таня.docx',  # 14 - по два клапана и по два вентилятора!
        'V-FC-0016 - Регина.docx',  # 15 - вылетает, потому что бланк какой-то странный. Я пока сделал временный костыль под этот случай, но, полагаю, подобные этому бланки ещё будут всплывать, так что нужно будет придумывать более элегантное решение
        'ПР-1 - Лена.docx',  # 16 - вылетает, не было нужного двигателя в табличке, исправлено
        'В4  Версия 2 - Таня.docx',  # 17 - проблемы с оформлением, я полагаю
        'П1.3 - Лена.docx',  # 18 - вроде норм бланки, но пусть будут
        'В1.7 - Лена.docx',  # 19 - вроде норм бланки, но пусть будут
        'ДОО на 220. п. Сосенское, пос. коммунарка ППТ 2-3 участок № 32.1-П4 - Лена.docx',  # 20 - это бланк каналки. Оказалось, я канальное оборудование нахожу максимально идиотским способом, но я его модернизировал... То есть, сделал ещё тупее, лооооооооол. А ещё это был ртф-файл, но я его сконвертировал
        'П1, П3 - Лена.docx',  # 21 - короче, в клапанах и вентиляторах было написано "2шт", а не "2 шт". Мне в голову не могло прийти, что мробелов может не быть, а зря... И если бы на этом проблемы закончились! Хохма в том, что тут у нас ДВЕ СИСТЕМЫ, то есть, программа должна создавать ДВА РАЗНЫХ БЛАНКА НА КАЖДУЮ СИСТЕМУ
        'П7В81 - Лена.docx',  # 22 - тут как минимум один клапан подписан как рециркуляция, но почему-то программа его не увидела
        'В1.2_Версия 2 - Лена.docx',  # 23 - тут была проблема с вентиляторами - не находились обороты в минуту, но они в канальном и не особо нужны
        'В1.3.1 - Лена.docx',  # 24 - тут была проблема с вентиляторами - не находились обороты в минуту, но они в канальном и не особо нужны
        'В1.1_Версия 2 - Лена.docx',  # 25 - тут была проблема с вентиляторами - не находились обороты в минуту, но они в канальном и не особо нужны
        'П1.1_Версия 3 - Лена.docx',  # 26 - тут была проблема с вентиляторами - не находились обороты в минуту, но они в канальном и не особо нужны
        'В5 - Таня.docx',  # 27 - а тут неправильно подбирается Верса - не определяется двигатель. Оказалось, у меня была одна единственная ошибка, где не находились двигатели для силы тока 6, потому что 6 ампер были за пределами видимости!!! Я это исправил
        'П1.3_Версия 3 - Лена.docx',  # 28 - тут проблема с электрокалорифером
        '1Ф-ОХР-П1, 1Ф-ОХР-П1.1 - Лена.docx',  # 29 - тут в одном бланке несколько систем, тут они записаны через запятую
        'В5.18-В5.23 - Лена.docx',  # 30 - тут в одном бланке несколько систем, тут через дефис (значит, их много)
        'В5.1-В5.3 - Лена.docx',  # 31 - тут в одном бланке несколько систем, тут через дефис
        'В5.11-В5.15 - Лена.docx',  # 32 - тут в одном бланке несколько систем, тут через дефис
        'V-FC-0004, V-FC-0007 - Лена.docx',  # 33 - тут в одном бланке несколько систем, тут через запятую
        'V-FC-0001, V-FC-0003, V-FC-0005, V-FC-0011- V-FC-0015 - Лена.docx',  # 34 - тут в одном бланке несколько систем, а тут полный хаос и бардак - часть через запятую, а часть - через дефис с лишним пробелом!
        'ПВ9 - Регина.docx',  # 35 - в бланке была ошибка из-за того, что это очередной кривой бланк, сделанный в той идиотской программе - пришлось исправить руками
        'В5.11а-В10.11а - Лена.docx',  # 36 - искусственно созданный мной бланк с максимально ебанутой системой
        'П5 - Николай.docx',  # 37 - была проблем внутри моего модуля - решена
        'П26о.docx',  # 38 - просто пример того, чтобы было обозначение "-ЭК1(3кВт; ~1)-"
        'ДП7.1 .docx',  # 39 - есть нагрев в шквале, надо указывать дополнительные строки
        'ПД3 - Лена.docx',  # 40 - неправильный КАНАЛ-ЭКВ, 5.1. Предусмотрено включение системы при поступлении сигнала пожар и при закрытой двери в зону МГН (контроль по путевому выключателю - при закрытой двери контакт замкнут). 5.2. Предусмотрена регулируемая задержка по времени на запуск вентилятора (настройка в меню контролера).
        'ПВС-1-20 - 20шт.',  # 41 - с теплоутилизатором разобрался, осталось разобраться с СИСТЕМАМИ
        'В1ап.docx',  # 42
        'П4,В6.docx',  # 43
        'П6.docx',  # 44
    ))

    all_test_files_VENTIS = tuple(f'{TEST_FOLDER}\\Вентиляторы\\' + file for file in (  # Здесь у нас, стало быть, бланки по вентиляторам. Они все будут типа вытяжными, но в них могут быть разные клапаны (стам или типа того). А ещё тут могут быть пдф-файлы, что тоже надо отслеживать
        'В6_версия 4.docx',  # 0 - просто общепромка
        'В1 от 09.01.23 (ВРАН6-090-Т80).docx',  # 1 - крышник, вроде всё норм
        'В1.doc',  # 2 - тут СТАМ с приводом
        'ДУ2.1 версия 3.docx',  # 3 - скинутые Русланом бланки от Феди - не работают только у Руслана, но он это уже исправил
        'ДУ2.2 версия 2.docx',  # 4 - скинутые Русланом бланки от Феди - не работают только у Руслана, но он это уже исправил
        'ДУ2.2 версия 3.docx',  # 5 - скинутые Русланом бланки от Феди - не работают только у Руслана, но он это уже исправил
        'ДУ2.3 версия 2.docx',  # 6 - скинутые Русланом бланки от Феди - не работают только у Руслана, но он это уже исправил
        'ДУ2.3 версия 3.docx',  # 7 - скинутые Русланом бланки от Феди - не работают только у Руслана, но он это уже исправил
        'ПД1 версия 2.docx',  # 8 - скинутые Русланом бланки от Феди - не работают только у Руслана, но он это уже исправил
        'ДУ1 версия 2.docx',  # 9 - скинутые Русланом бланки от Феди - не работают только у Руслана, но он это уже исправил
        'ДУ1 версия 3.docx',  # 10 - скинутые Русланом бланки от Феди - не работают только у Руслана, но он это уже исправил
        'ДУ2.1 версия 2.docx',  # 11 - скинутые Русланом бланки от Феди - не работают только у Руслана, но он это уже исправил
        'ВИР330-045(2)-Т80-Н-00300(2)-У2-1-RD0_1700м3_2800Па.pdf',  # 12 - пдф-файл для индустриальника
        'МО2_ВИР800-045(1)_11(2F)_RD0_9100м3_2400Па.pdf',  # 13 - пдф-файл для индустриальника
        'МО3_ВИР800-050(1)_15(2F)_RD0_13000м3_2400Па.pdf',  # 14 - пдф-файл для индустриальника
        'МО1_ВИР800-050(1)_15(2F)_RD0_10800м3_2400Па.pdf',  # 15 - пдф-файл для индустриальника, есть частотник!
        'МО4, МО5_ВИР800-080(1)_22(4F)_RD0_15600м3_2400Па.pdf',  # 16 - пдф-файл для индустриальника
        'ПД1а МГН (ПКВ взамен Канал-ВЕНТ).doc',  # 17 - тут про ШКВАЛы
        'ВД1 (1).docx',  # 18 - тут про ШКВАЛы
        'ПД4.docx',  # 19 - тут про ШКВАЛы
        'ВД1.docx',  # 20 - тут про ШКВАЛы
        'ПД3.docx',  # 21 - тут про ШКВАЛы
        'ДУ3.1.docx',  # 22 - должен быть шквал, но шквала нет. Оказалось, для систем ДУ тоже нужен ШКВАЛ
        'ДУ3.2.docx',  # 23 - должен быть шквал, но шквала нет. Оказалось, для систем ДУ тоже нужен ШКВАЛ
        'ДУ1.1.docx',  # 24 - должен быть шквал, но шквала нет. Оказалось, для систем ДУ тоже нужен ШКВАЛ
        'ДУ1.2.docx',  # 25 - должен быть шквал, но шквала нет. Оказалось, для систем ДУ тоже нужен ШКВАЛ
        'ДУ2.1.docx',  # 26 - должен быть шквал, но шквала нет. Оказалось, для систем ДУ тоже нужен ШКВАЛ
        'ДУ2.2.docx',  # 27 - должен быть шквал, но шквала нет. Оказалось, для систем ДУ тоже нужен ШКВАЛ
        'КДУ1с.docx',  # 28 - тут тоже шквалы, и с ними вроде нет особой хрени
        'ДП7.docx',  # 29 - тут тоже шквалы, и с ними вроде нет особой хрени
        'ДУ1.1ж_Версия 2.docx',  # 30 - тут тоже шквалы, и с ними вроде нет особой хрени
        'ДП6.docx',  # 31 - лишний Хэ - пусть они сами уже решат, блин, нужно ли это в маркировке или нет, по инструкции нужно
        'ДВ1.docx',  # 32 - не делает КА, разобрался с ошибкой
        'ДП11.docx',  # 33 - обычная приточка
    ))

    all_test_files_DIFFER = tuple(f'{TEST_FOLDER}\\Вперемешку\\' + file for file in (  #
        '1\\А1.ДУ1.1.docx',  # 0 -
        '1\\А1.ДУ1.2.docx',  # 1 -
        '1\\А1.ДУ1.3.docx',  # 2 -
        '1\\А1.ПД1.1.docx',  # 3 -
        '1\\А1.ПД2.1.1 .docx',  # 4 -
        '1\\А1.ПД2.1.docx',  # 5 -
        '1\\А1.ПД3.1.docx',  # 6 -
        '1\\А1.ПД3.3.docx',  # 7 - Вот тут возникла залупа конская! Ебучие пробелы!
        '1\\А1.ПД3.5.docx',  # 8 -
        '1\\А1.ПД4.1.docx',  # 9 -
        '1\\А1.ПД8.1.docx',  # 10 -
        '1\\В2.2 .docx',  # 11 -
        '1\\В5.3.docx',  # 12 -
        '1\\В6.docx',  # 13 -
        '1\\В8.2.docx',  # 14 -
        '1\\В9.2.docx',  # 15 -
        '1\\В10.docx',  # 16 -
        '1\\ДУа.12.docx',  # 17 -

        '2\\В1 БКТ1.docx',  # 18 - "Клапан с обогревом (гермик С)", "нет реле перепада давления на вентиляторе", "Пуск с помощью ПЧ"
        '2\\В1 БКТ2.docx',  # 19 -
        '2\\В1 БКТ3.docx',  # 20 -
        '2\\В1.docx',  # 21 -
        '2\\В2 БКТ1.docx',  # 22 -
        '2\\В2 БКТ2.docx',  # 23 -
        '2\\В2 БКТ3.docx',  # 24 -
        '2\\В2.docx',  # 25 -
        '2\\В3.docx',  # 26 -
        '2\\В4.docx',  # 27 -
        '2\\В5.docx',  # 28 -
        '2\\П БКТ1.docx',  # 29 - 1. Нет перепадников на вентилятор, 2. Нет перепадников на фильтрах, 3. Нет датчиков защиты от замораживания ТО, 4. Клапаны с обогревом, 5. Пуск с ПЧ надо добавить 
        '2\\П БКТ2.docx',  # 30 -
        '2\\П БКТ3.docx',  # 31 -
        '2\\П1.docx',  # 32 -
        '2\\П2.docx',  # 33 -
        '2\\П3.docx',  # 34 -
    ))

def test_automata() -> bool:
    """Тестовая процедура, которая просто делает то же, что и обычная программа, только внутри VSCode

    Ради чего я вообще создаю отдельную процедурку для тестов? Внутри Visual Studio Code очень сложно отслеживать изменения, когда уже создана оконная форма, а мне очень часто нужно что-то отладить, и именно поэтому мне принципиально, чтобы всё то, что делает оконная форма, идеально делалось и без неё (с поправкой на те вещи, которые уникальны только для оконной формы).

    Сама по себе процедура не отличается чем-то необычным - просто набор тестовых данных из главного тела программы передаётся главной функции. Причём логика всегда такая - сначала обрабатывается только один бланк, а потом - абсолютно все. Сделано это за тем, чтобы, закончив работу с одним бланком, убедиться, что проделанная работа не затронула всё остальное. Или если надо найти бланки со специфическими условиями. Или ещё зачем

    Returns:
        bool: FAST_MODE - быстрый режим без всплывающих окон
    """

    def test_inner(the_list:list, the_index:int):
        """Проверка однотипная - сначала проверяется один файл, а потом - все остальные. Осуществляет логику, описанную мной в шапке тестовой функции

        Args:
            the_list (list): список файлов конкретного типа
            the_index (int): индекс файла, который надо проверить в первую очередь. Если этого делать не надо, напишите число меньше 0 (или больше последнего индекса, но лучше меньше нуля, чтобы меньше думать)
        """
        global FAST_MODE, to_continue

        if the_index in tuple(range(0, len(the_list))):  # Что означает эта проверка? защита от дураков - чтобы нельзя было ввести индекс за пределами списка
            main_part(the_list[the_index], debug_mode_on=True)  # Мы всё ближе к разговору о главной функции программы. Собственно, тут делается прогон выбранного файла

        if not to_continue:
            # sg.popup('Мне лень здесь делать точку останова, поэтому просто всплывает окно, чтобы создать паузу. Нажми ОК, чтобы дальше работало')
            to_continue = True

        time_start = perf_counter()  # Просто для счётчика времени
        for test_file in the_list:  # Ну а здесь прогоняются абсолютно все бланки
            print(f"==============================Текущий тестовый файл: {test_file}==============================")  # Заголовок - на случай, если что-то пошло не так, чтобы понять, где же оно пошло не так
            main_part(test_file, debug_mode_on=True, multiple_files=True)
            print(f"==============================Текущий тестовый файл: {test_file}==============================")
            vm.ideal_message(the_list.index(test_file) + 1, len(the_list), 'файлов', time_start)  # Просто инфрмационная строка
            pass
        vm.xlsx_file_beautifulication(FILE_PIVOT_TABLE, DF_RESULT)  # Результаты заносятся в сводную таблицу. О сводной таблице будет рассказано в моём модуле

    global TEST_FOLDER, FAST_MODE, to_continue  # Быстрый режим подразумевает, что разные окошки с выбором разного говна не будут появляться. Мне просто надоело каждый раз тыкать "ок", если возникает очередной пропиленгликоль, поэтому вот. Эта строчка кочует туда-сюда, и теперь вообще где-то потерялась!

    to_continue = False
    FAST_MODE = vm.popup_true_false('Включить быстрый режим (чтобы не было всплывающих окон)?')  # Я надеюсь, больше никогда в жизни эту строчку не буду двигать!!!
    # ============================== ГЛАВА I ==============================

    test_inner(TestValues.all_test_files_VEROSA, 0)  # Проверяем веросы
    test_inner(TestValues.all_test_files_CHANAL, 44)  # Проверяем каналку
    test_inner(TestValues.all_test_files_VENTIS, 8)  # Проверяем вентиляторы
    test_inner(TestValues.all_test_files_DIFFER, 29)  # Проверяем то, что тут есть
    # ============================== КОНЕЦ ГЛАВЫ I ==============================
    pass

# ====================================================================================================================================================================================

def main_part(FILENAME:str, *args, debug_mode_on=False, window_version=False, flask_version=False, streamlit_version=False, multiple_files=False, ruslan_collab_folder='')  -> list|tuple|None:
    """Самая основная, самая важная, самая ключевая часть программы. Вынесена в отдельную процедуру, когда выяснилось, что можно очень легко приспособить это дело под отдельную функцию, которую можно использовать за пределами конкретно этой программы.

    Если вкратце, как вообще работает алгоритм создания бланков комплектов автоматики? Берётся бланк Веросы (или каналки, или ещё чего-то, для чего можно сделать комплект автоматики) после чего из него по ключевым словам в заголовке табличек забирается информация, которая определяет, какие нужно внести параметры в лист для завода, какие нужны датчики, и ещё некие дополнительные параметры, которые будут влиять на дополнительную информацию в бланках. 

    Args:
        FILENAME (str): имя файла. Служит ещё и как сигналом того, что мы будем иметь дело с искусственно созданными бланками (да, я на полном серьёзе буду использовать терминологию "искусственно созданный бланк" - если у вас возникли ассоциации с Серийными Евангелионами, то я не знаю, кем нужно быть)

        debug_mode_on (bool, optional): Если это тестовый прогон, то должен быть равен True, во всех остальных случаях - False.

        window_version (bool, optional): Определяется, было ли это запущено в оконной форме. Defaults to False.

        flask_version (bool, optional): Определяется, было ли это запущено через Фласк. Defaults to False. (Тут ещё работать и работать...)

        streamlit_version (bool, optional): Определяется, было ли это запущено через Стримлит. Defaults to False. 

        multiple_files (bool, optional): Если обрабатывается несколько файлов, то настройки, заданные в программе, не учитываются, поэтому по умолчанию False.

        ruslan_collab_folder (str, optional): Переменная, в которую Руслан будет передавать путь к своим папкам. По умолчанию ничему не равна, и у меня никак не будет задействована, а вот у Руслана...

    Raises:
        ValueError: _description_

        TypeError: _description_

    Returns:
        list|tuple|None: _description_
    """
    # ============================== ГЛАВА II ==============================
    # Основное повествование дошло до главной функции, где происходит абсолютно всё. Важно сказать следующее - из-за того, что здесь у меня уровень вложенностей функции достигает трёх (или четырёх, зависит от того, как считать), главы начнут сменяться одна за другой. Здесь лишь общая вступительная речь, которая нужна, чтобы претворить происходящее. Пятая глава будет после абсолютно всех внутренних функций
    # ============================== КОНЕЦ ГЛАВЫ II ==============================

    def create_cell_new_content(for_blank_with_codes:dict) -> tuple[dict, list, str, str, dict]:
        """Основное место, где происходит вся работа по определению параметров для комплекта автоматики.

        Суть вкратце: по кодированию состава системы и технических характеристик для КА, есть шестнадцать полей, каждое из которых заполняется уникальным (как будет дальше видно - почти уникальным) способом для каждого из кодов. К каждому коду нужен индивидуальный подход, и поэтому, чтобы корректно отобразить эту информацию, нужно каждый раз заново прогонять содержимое бланка на поиск необходимой информации

        Args:
            main_info (dict): Вся главная информация о веросе
            main_info_list (list): Вся необходимая информация из бланка
            for_blank_with_codes (dict): Вся предустановленная информация

        Returns:
            dict, list, str, str, dict: all_results, automation_devices, typical_circuit_design_long, typical_circuit_design_short, all_amounts: Результаты, устройства автоматики, две маркировки типовых схемных решений и количества
        """

        # ============================== ГЛАВА IV ==============================
        # Итак, с чего всё началось? Научившись обрабатывать бланк, я столкнулся со своеобразной проблемой - для абсолютно каждого пункта из основной таблицы в шаблоне требовался свой подход, который требовал раз за разом прогонять бланк. Так, я же так и не сподобился рассказать о том, что вообще представляет собой и шаблон, и та самая важная таблица... Ладно. потом. Седьмая глава будет идти после функции "через_всю_главную_информацию" 
        # ============================== КОНЕЦ ГЛАВЫ IV ==============================

        def through_all_main_info(code:str) -> tuple[list, str, int, list]:
            """Так как для каждого кода необходимо раз за разом пробегать всё содержимое бланка, то я эту процедуру выделил в отдельную функцию. 

            Как уже говорилось, главная проблема, которая встала передо мной - это необходимость без малого одиннадцать раз (с пункта 3 по 13) прогонять бланк от начала и до конца, искать ключевые слова, которые покажут, что перед нами именно тот блок, который нам нужен, и извлекать из него информацию. Как видно, мне пришлось эту функцию вынести отдельно, и для каждого случая прописать свою модель поведения. Однако в общем случае эта функция работает так: перед входом в цикл включается счётчики и накопитель текущих данных, а в конце они обрабатываются в случае необходимости, после чего передаются в функцию выше уровнем, вот и всё. При этом каждый из 11 случаев ещё и получил отдельную функцию, о чём будет сказано позже в индивидуальном порядке

            Args:
                code (str): Текущий рассматриваемый код по обозначению полей

            Returns:
                tuple: Содержит четыре переменные: curr_automation_devices, curr_result, curr_amount, curr_typical_circuit_design. Текущие приборы автоматики, текущий результат, текущее количество и текущиее типовое схемное решение соответственно.
            """
            # ============================== ГЛАВА VI ==============================
            # Собственно, отсюда и далее начинаются бесконечные вложенные функции. Пока что они нас вообще не волнуют, нас волнует то, что начнётся после вложенных функций, а это начинается где-то на 1300-ых строках. Да, нужно промотать тысячу строчек кода (буквально!).
            # ============================== КОНЕЦ ГЛАВЫ VI ==============================

            def for_WIL(W:int|float|str, I:int|float|str, pha_pow:int|float|str, value:str):
                """Обозначение формата W[i]1/3L встречается минимум восемь раз, и потому процесс забора данных переносится в отдельную процедурку.

                Args:
                    W (int | float | str): мощность, кВт
                    I (int | float | str): ток, А
                    pha_pow (int | float | str): тип питания
                    value (str): значение, забранное из словаря с предустановленными параметрами

                Returns:
                    W, I, pha_pow: изменённые (или нет) значения
                """
                # ========== ПРИЛОЖЕНИЕ 2 К ГЛАВЕ X ==========
                res_WIL = re.findall(r'([Ww]|\d+?[.,]?\d*?)\[([Ii]|\d+?[.,]?\d*?)\]([13]L)', value, re.IGNORECASE)  # Итак, здесь у нас будет то, что внёс пользователь. Пользователь мог ничего не внести, и поэтому рес будет пустым. Однако мы не хотим терять найденные программой значения, именно поэтому мы их, кстати, и тянули за собой
                if res_WIL:  # Если он не пустой, значит. пользователь что-то внёс. Осталось понять. что он внёс
                    res_WIL = res_WIL[0]  # понижаем степень вложенности
                    if res_WIL[0].upper() != 'W':  # Если он изменил напряжение, то мы его переносим
                        W = res_WIL[0]
                    if res_WIL[1].upper() != 'I':  # Аналогично с током
                        I = res_WIL[1]
                    pha_pow = res_WIL[2]  # А фазность мы забираем и так
                else:  # Пользователь может быть идиотом и где-то налажать. Именно поэтому надо пользователя об этом уведомить
                    if not streamlit_version:
                        pass
                        # sg.popup('Было введено некорректное значение, поэтому будут использоваться параметры, найденные самой программой')
                # Таким образом, если у нас пустое значение, то функция, по сути, ничего и не сделает. Если было непустым - изменит то, что можно изменить. Нельзя изменить - не будет трогать. идеально же
                # ========== КОНЕЦ ПРИЛОЖЕНИЯ 2 К ГЛАВЕ X ==========
                return W, I, pha_pow

            def range_select(pv:int|float) -> str:
                """Определение диапазона

                Args:
                    pv (int|float): давление, Па

                Returns:
                    str: сообщение, содержащее собой диапазон
                """
                if 30 <= pv <= 300:
                    return '30-300Па'
                elif 50 <= pv <= 500:
                    return '50-500Па'
                elif 100 <= pv <= 1500:
                    return '100-1500Па'
                else:
                    return '100-1500Па'

            def vector_creation(Gzh:float, control_device:str, schema:int):
                """Функция определяет необходимые параметры вектора, заносит его обозначение в словарь и возвращает необходимые параметры. Для нахождения типоразмера вектора важно знать три параметра - давление G, регулирующее устройство и схему. Мы пробегаемся по таблице данных и ищем эти три значения

                Args:
                    Gzh (float): _description_
                    control_device (str): управляющее устройство - либо 'С', либо 'Ш'
                    schema (int): схема, от 1 до 6

                Returns:
                    tuple: phase_begin, phase_power, pum_W, pum_I, options, valve_power, valve_contr - начальная фаза насоса, мощность насоса, напряжение насоса, сила тока насоса, опции насоса, напряжение крана, контур крана
                """
                global VECTOR_NAME
                # ========== ПРИЛОЖЕНИЕ 1 К ГЛАВЕ X ==========
                pdmo(Gzh, control_device, schema)
                pass
                for data in VECTOR_DATA:  # Итак, 
                    if eval(data[5].replace('G', str(Gzh/1000)).replace(',', '.')) and data[2] == control_device and data[0] == schema:  # Функция евал - настоящее чудо! Просто текст превращается в функцию, не красота ли? Так что да, мы просто подставляем в табличный диапазон имеющийся и смотрим, совпало ли оно. Если выполнились три условия, то мы нашли нужный типоразмер

                        # ========== БЛОК ПОИСКА ПАРАМЕТРОВ НАСОСА ==========
                        # Насос предполагается в схемах 2, 4, 5. Обычно здесь используется только вторая схема, но я сделаю условие для всех случаев
                        if schema in [2, 4, 5]:
                            phase_begin = '~' + data[9][0]  # Начальная фаза определяется как первый знак в значении в десятом столбце, но требуется только в самом конце главы
                            pum_W, pum_I = data[11], data[10]  # Напряжение и сила тока забираются из соседних ячеек
                            phase_power = curr_contentum['Насос']['Питание']['однофазное питание'][-2] if int(data[9][2:5]) == 230 else curr_contentum['Насос']['Питание']['трехфазное питание'][-2]  # Мощность определяется как три символа, начиная с третьего (их там всегда три). Если 230 - однофазное питание, всё остальное - трёхфазное. В словаре оно записано как W[I]1L или W[I]3L, так что нам нужен предпоследний знак
                            if curr_code_for_blank['Насос']['Питание']:  # Наверное, мог возникнуть вопрос, а куда пропал словарь с предустановленными значениями? Дело в том, что по моей задумке пользователь должен в шаблоне W[I]1L или W[I]3L руками изменить В и И. Однако он мог этого не сделать. Из-за этого...
                                pum_W, pum_I, phase_power = for_WIL(pum_W, pum_I, phase_power, curr_code_for_blank['Насос']['Питание'])  # И появилась эта занятная функция. Подробное её объяснение будет внутри неё
                            options = f"-{curr_code_for_blank['Насос']['Опции']}" if curr_code_for_blank['Насос']['Опции'] else ''  # Дополнительных опций у насоса не бывает, так что тут всё вносится только руками
                        else:  # Чтобы программа не вылетала с ошибкой, просто задаём пустые значения, если насоса в векторе не предусматривается по схеме
                            phase_begin, phase_power, pum_W, pum_I, options = [''] * 5
                        # ========== КОНЕЦ БЛОКА ПОИСКА ПАРАМЕТРОВ НАСОСА ==========

                        # ========== БЛОК ПОИСКА ПАРАМЕТРОВ РЕГУЛИРУЮЩЕГО КРАНА ==========
                        curr_code_for_blank_temp = curr_code_for_blank if code == '1.8' else curr_code_for_blank['Регулирующий кран'] if code == '1.5' else curr_code_for_blank['ЖТУ']['Привод'] # В случае поиска параметров регулирующего клапана я намеренно сделал максимально однотипные указатели в справочном файле, чтобы можно было сделать общий адрес, так как я знал, что рано или поздно понадобится эту функцию делать обособленной. Именно поэтому не стоит в джсон-файле пытаться что-то там стандартизировать и унифицировать дополнительно - я уже всё сделал до вас, правда
                        contentum_temp = curr_contentum if code == '1.8' else curr_contentum['Регулирующий кран'] if code == '1.5' else curr_contentum['ЖТУ']['Привод']  # В случае поиска параметров регулирующего клапана я намеренно сделал максимально однотипные указатели в справочном файле, чтобы можно было сделать общий адрес, так как я знал, что рано или поздно понадобится эту функцию делать обособленной
                        if curr_code_for_blank_temp['Питание']:
                            valve_power = curr_code_for_blank_temp['Питание']
                        else:  # Нам нужны значения из седьмого столбца, а именно параметр мощности
                            valve_power = contentum_temp['Питание']['питание 24В; DC'] if int(data[6].split()[0][:-1]) == 24 else contentum_temp['Питание']['питание 230В АС']  # Задаётся питание регулирующего крана. Проверка осуществляется через довольно старую ерунду, где я разбиваю всё на массив по пробелам, забираю первое значение и отсекаю последний символ. Это можно улучшить

                        if curr_code_for_blank_temp['Управление']:
                            valve_contr = curr_code_for_blank_temp['Управление']
                        else:
                            valve_contr = contentum_temp['Управление']['аналоговое (0... 10В)'] if data[7] == '0…10 В' else contentum_temp['Управление']['аналоговое (4...20mA, 2-х проводная)']  # Тут всё ещё проще - абсолютно везде написано "0...10 В", а это аналоговое управление. В другом случае тоже аналоговое, но другое

                        VECTOR_NAME['нагревателя' if code == '1.5' else 'охладителя'].append(f"ВЕКТОР-{schema}-{control_device}-{data[3]}-П(Л)-С+")  # Как говорилось, нам нужно знать обозначение всех векторов. Оно довольно простое. Заносим в ту позицию, по какому ключу мы сюда пришли. Вариантов не особо много. Возможно, для большей корректности это нужно будет вынести за пределы функции, а сама функция будет дополнительно возвращать и название текущего вектора
                        # ========== КОНЕЦ БЛОКА ПОИСКА ПАРАМЕТРОВ РЕГУЛИРУЮЩЕГО КРАНА ==========
                        break  # Найдя все значения из строки, можно спокойно выходить из цикла - брейк наше всё. А вместе с брейком выходим полностью из функции
                else:  # Если каким-то непостижимым образом вектор не был найден (если только мы намеренно не ввели невыполнимые условия, как мы делаем в случае с гликолями больше 40%), то тогда пусть будут такие заглушки
                    phase_begin, phase_power, pum_W, pum_I, options, valve_power, valve_contr = '', '', 0, 0, '', '', ''
                # ========== КОНЕЦ ПРИЛОЖЕНИЯ 1 К ГЛАВЕ X ==========
                return phase_begin, phase_power, pum_W, pum_I, options, valve_power, valve_contr

            def Gzh_t1_t2_creation() -> tuple[float, float, float]:
                """На основе информации из бланка возвращает три параметра

                Returns:
                    tuple[float, float, float]: Gzh, t1, t2
                """
                Gzh_t1_t2 = re.findall(r'.*?[GV]ж=\s*?(\d+[.,]?\d*?)\D.*?tжн\*?=\s*?(-?\d+[.,]?\d*?)\D.*?tжк\*?=\s*?(-?\d+[.,]?\d*?)\D.*', info.replace(',', '.'), re.IGNORECASE)  # Можете на этом примере наглядно увидеть, насколько регулярные выражения эффективнее и проще, чем если делать без них. Нам нужно три параметра - Gж, tжн и tжк. Расшифровка нас не слишком волнует, главное, чтобы эти параметры были
                if Gzh_t1_t2:  # Вот интересно, что эти параметры всегда будут в информации, однако проверка осталась на всякий случай. Так что можно вообще сократить до одной строчки: Gzh, t1, t2 = map(float, re.findall(r'.*?Gж=(\d+[.,]?\d*?)\D.*?tжн\*?=(\d+[.,]?\d*?)\D.*?tжк\*?=(\d+[.,]?\d*?)\D.*', info)[0], re.IGNORECASE). Делать это или нет - оставляю на ваше усмотрение
                    Gzh, t1, t2 = map(float, Gzh_t1_t2[0])  # Нам эти переменные нужны как числа с запятой
                else:  # А теперь просто посмотрите на того монстра Франкенштейна, которого я сотворил, когда ещё не овладел регулярными выражениями. Оно тут осталось как памятник, но полезный - однажды я смог сюда выйти, хотя сам того не ожидал!
                    Gzh, t1, t2 = (
                        float(''.join(takewhile(lambda x: x.isdigit(), parapa.split('=')[1]))) 
                        for parapa in 
                        (hehehe for hehehe in info.split('; ') for j in ('Gж=', 'tжн*=', 'tжк*=') if j in hehehe))
                # return map(float, Gzh_t1_t2[0]) if Gzh_t1_t2 else (float(''.join(takewhile(lambda x: x.isdigit(), parapa.split('=')[1]))) for parapa in (hehehe for hehehe in info.split('; ') for j in ('Gж=', 'tжн*=', 'tжк*=') if j in hehehe))  # Вот интересно, что эти параметры всегда будут в информации, однако проверка осталась на всякий случай. Нам эти переменные нужны как числа с запятой. Условие оставьте, пожалуйста - просто посмотрите на того монстра Франкенштейна, которого я сотворил, когда ещё не овладел регулярными выражениями. Оно тут осталось как памятник, но полезный - однажды я смог сюда выйти, хотя сам того не ожидал!
                return Gzh, t1, t2

            def show_file(the_request:str) -> str|bool:
                """Для удобства пользователей необходимо открывать файл с бланком, чтобы те смотрели, почему вообще возникло всплывающее окно. Поэтому и появилась эта функция

                Args:
                    the_request (str): код в текстовом формате, который создаёт всплывающее окно. Из-за того, что напрямую вписать функцию вызова всплывающего окна нельзя, используется этот обходной путь

                Returns:
                    str|bool: result - либо текст, либо булевая переменная
                """
                from win32com import client as wc

                window.minimize() if window_version else ...  # Я не могу поверить, что это сработало! Короче, в таких случаях, когда второе условие не нужно, можно просто написать троеточие. Для чего это вообще надо было? Нужно на секунду свернуть окно программы, чтобы впереди появилось окно с вордом. Этого делать не надо, если у нас нет оконной формы (слава богу, что я спустя полгода догадался сделать отдельный флаг для обозначения того, в окне ли мы работаем или нет)
                doc = wc.Dispatch('Word.Application')  # Но вообще нужно просто открыть файл. Для этого нужно создать диспатченный объект-клиент. Можно было бы это сделать в одну строку, однако есть кое-какое "но"
                doc.Visible = True  # Это "но" - видимость окна. Почему-то в этом случае при закрытии файла само окно Ворда не исчезает. Поэтому его надо прятать
                doc_doc = doc.Documents.Open(FILENAME.replace('/', '\\'), ReadOnly=True)  # Открываем файл. Параметр ридонли не работает ни хрена
                pdmo(the_request)
                result = eval(the_request)  # Заковыка оказалась в том, что действие нужно прописать как строку, потому что если некое действие прописано как, ну, кусок кода, то оно выполняется В МОМЕНТ ОБРАЩЕНИЯ К ЭТОЙ ФУНКЦИИ. А нам нужно, чтобы появился ворд, а уже потом появилось всплывающее окошко с выбором чего бы то ни было
                try:  # Пользователь может закрыть Ворд ещё до выбора. Тогда при попытке программы закрыть окно, будет ошибка. И чтобы этого избежать, нужен этот трай-эксепт
                    doc_doc.Close()
                    doc.Visible = False  # Так мы и прячем окно самого Ворда, которое не исчезает, если закрыть файл
                except AttributeError:  # Если будет иная ошибка, вы об этом узнаете мигом
                    pass
                finally:
                    window.maximize() if window_version else ...  # Разворачиваем окно с программой обратно, хотя смысла в этом нет
                    return result
                pass

            #====================================================================================================================================================================================

            def for_1_3(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА VIII. ПАРАМЕТРЫ ГРУППЫ КЛАПАНОВ ==============================
                """Самое главное тут - определить привод, так как от привода на клапане зависит абсолютно всё

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                global we_came_from_venti, SHKVAL, FIREVENT, all_drive_units, recycling_split
                if IS_VEROSA:
                    drive_units = re.findall(r'клапан.+?привод: (.+?)(;|\s|$)', info, re.IGNORECASE)  # Собственно, обозначение привода следует сразу за конструкцией "привод: ". Причём важно отметить, что клапанов и приводов может быть несколько. Чем хорош файндолл, так это тем, что он возвращает массив кортежей, где внутри кортежа - каждая найденная группировка. Подробнее о принципах работы регулярных выражений я тут останавливаться не буду - этого добра в интернете больше, и объяснят лучше меня.
                elif IS_CHANAL:
                    drive_units = re.findall(r'КЛАБ-\d{1,}\*?\d{0,}-[02]\*ф-\D-(.+)-[10Z]-[10KК]|[Пп]ривод: (.+?);', info, re.IGNORECASE)
                elif IS_OBPROM:  # Общепромка тоже может содержать в себе клапаны - они находятся в некоторых исключительных СТАМах. Обычно если в конце СТАМа что-то записано, то это привод, и надо с ним работать
                    drive_units = re.findall(r'СТАМ[-\s]?\d{3}[-\s]?\d{2}[-\s]?[НК]1?-(.+?)\s', info, re.IGNORECASE)
                pdmo(header, info, drive_units, we_came_from_venti)
                pass

                c_amount -= 1  # Проблема заключается в том, что у нас в одном блоке может быть два клапана, но количество-то будет всего одно! Поэтому мы уменьшаем эту переменную - мы будем считать заново
                all_drive_units = []  # Тут я сохраню все найденные движки клапанов. Применение этому должно было быть, но оно отпало за ненадобностью, почему пусть будет пока
                for i in range(len(drive_units)):  # Собственно, из-за этого нужно прогнать все найденные результаты. Однако если ничего не нашлось, то массив будет пустым, и цикл попросту не запустится, и он сразу промотается дальше.
                    drive_unit = drive_units[i]
                    pdmo(drive_unit)
                    c_amount += 1  # Тут начинаем считать заново
                    if IS_VEROSA:                        
                        drive_unit = drive_unit[0]  # Так как в кортеже два значения (привод и признак окончания), то мы забираем только привод     
                    elif IS_CHANAL:
                        drive_unit = drive_unit[0] if drive_unit[0] else drive_unit[1]
                    elif IS_OBPROM:
                        pass
                    drive_unit = drive_unit.replace(';', '').strip().replace('М', 'M')  # Как же порой по-ебаному могут быть записаны обозначения движков привода!!!
                    pdmo(drive_unit)
                    all_drive_units.append(drive_unit)
                    SHKVAL_devices.append(f'Электропривод воздухозаборного клапана {drive_unit}')  # Для бланка Шквала нужно указывать клапаны. Укажем, мне несложно

                    # ========== БЛОК ПОИСКА ОБОГРЕВА КЛАПАНА ==========
                    # В клапане может быть обогрев, в таком случае в информации будет параметр Nтэн. Если он есть, то в конце обозначения будет написано W[P], а в типовом схемном решении - Сп(кВт). Расшрифровывать эти обозначения я не буду - считается, что инструкция лежит перед вами
                    if curr_code_for_blank['Обогрев клапана']:  # "Курр_код_фор_бланк" - это те значения комплекта автоматики, которые мы ввели вручную в программе. Поэтому нам надо всегда проверять, а что вообще нашлось. В общем случае все эти конструкции работают так - "если значение не пустое, то мы сохраняем это значение. Иначе делаем что-то ещё". Поэтому далее, когда будет всплывать такая конструкция, я долго останавливаться на ней не буду - считается, что вы это уже и так знаете
                        if curr_code_for_blank['Обогрев клапана'] != curr_contentum['Обогрев клапана']['отсутствует']:  # Как же хорошо, что нам сразу же встретился пример с графой "отсутствует". Как можно легко заметить, я проверяю НАЛИЧИЕ ХОТЬ ЧЕГО-ТО В ЭТОЙ ГРАФЕ. А в случае с отсутствием у меня есть что-то - прочерк. Следовательно, строка есть, и мы заходим сюда. Но если нам тут ничего не надо, то смысл записывать? Поэтому здесь и далее, где есть раздел "отсутствует", я останавливаться подробно не буду - считается, что вы это уже и так знаете
                            drive_unit_heater = curr_code_for_blank['Обогрев клапана']
                            drive_unit_heater_info = f"Сп({drive_unit_heater}кВт)"
                        else:
                            drive_unit_heater = ''
                            drive_unit_heater_info = ''
                    else:
                        if IS_VEROSA:
                            drive_unit_heating = re.findall(r'.*?Nтэн=(.+?)[а-яА-ЯЁё].*', info, re.IGNORECASE)  # Как уже говорил, нужно найти в тексте параметр Nтэн. Важное примечание - очень часто я для обозначения результата работы функции файндолл буду использовать переменную рес. В этом нет особо смысла, это просто сложившаяся традиция, данную переменную можно переименовать, но внимательно следить, откуда она и куда идёт!
                        elif IS_CHANAL:
                            drive_unit_heating = re.findall(r'Нагрев=(.+?)\s?кВт', info, re.IGNORECASE)
                        else:
                            drive_unit_heating = []
                        pdmo(drive_unit_heating)
                        pass
                        if drive_unit_heating:  # Если он есть...
                            drive_unit_heater = f'-W[{drive_unit_heating[0]}]'  # То просто записываем его куда надо. Так как многие параметры должны писаться через дефис, то используются ф-строки, где в начале добавляется дефис. Это будет очень частая конструкция, поэтому её надо запомнить
                            drive_unit_heater_info = f"Сп({drive_unit_heating[0]}кВт)"  # То просто записываем его куда надо
                            SHKVAL_devices.append(f"Электрообогрев привода клапана Nтэн={drive_unit_heating[0]}кВт" + (f"; Iтэн={re.findall(r'.*?Iтэн=(.+?)[а-яА-ЯЁё].*', info, re.IGNORECASE)[0]}А" if IS_VEROSA else ''))
                            pdmo(SHKVAL_devices)
                            pass
                        else:  # Ну а на нет и суда нет
                            drive_unit_heater = ''
                            drive_unit_heater_info = ''
                    # ========== КОНЕЦ БЛОКА ПОИСКА ОБОГРЕВА КЛАПАНА ==========

                    # ========== БЛОК ОПРЕДЕЛЕНИЯ ТИПА КЛАПАНА ==========
                    main_info_name = ''.join(re.findall(r'(П|В)', SYSTEM_NAME, re.IGNORECASE))  # Самое сложное в определнии клапана - его тип. Это очень легко отследить, посмотрев в сам бланк, но программа-то так делать не умеет. Поэтому нужно предусматривать различные варианты. Важный параметр - поток установки. Иногда этот поток может быть неверно указан, поэтому в качестве предохранительной меры можно отследить, начинается ли название установки с буквы П или В, и есть ли вообще эти буквы там. Часто бывают названия установок формата "П№", "В№", "П№/В№", где № - некий номер.
                    pdmo(main_info_name)

                    if curr_code_for_blank['Типы клапанов']:  # В идеальном мире бы руками это определять... Но, увы, ручной труд - слишком большая потеря времени
                        drive_unit_type = curr_code_for_blank['Типы клапанов']
                        for_curr_typical_circuit_design = create_circuit_design(code, c_amount, curr_code_for_blank['Типы клапанов'], drive_unit_heater_info, drive_unit)
                        # for_curr_typical_circuit_design = f"{'Кр' if curr_code_for_blank['Типы клапанов'] == curr_contentum['Типы клапанов']['рециркуляционный клапан'] else 'К' if curr_code_for_blank['Типы клапанов'] == curr_contentum['Типы клапанов']['воздухозаборный клапан (на входе в установку)'] else 'Кп' if curr_code_for_blank['Типы клапанов'] == curr_contentum['Типы клапанов']['приточный клапан (на выходе из установки)'] else 'Кв' if curr_code_for_blank['Типы клапанов'] == curr_contentum['Типы клапанов']['вытяжной клапан'] else 'Ко' if curr_code_for_blank['Типы клапанов'] == curr_contentum['Типы клапанов']['противопожарный (огнезадерживающий) клапан'] else ''}({drive_unit})"  # К сожалению, нужно задавать так, потому что нельзя переводить, увы, буквы из латиницы в кириллицу. А если и можно, то это слишком ненадёжный модуль. Так что тут просто проверка того, что введено, и на основе введённого - нужный результат
                    else:
                        if 'ркуляц' in header.lower() or ('горизонтальный' in header.lower() and 'SR' in info):  # Все клапаны делятся глобально на два типа - рециркуляционный и все остальные. Так что если клапан не рециркуляционный, то начинаются проблемы. Часто о рециркуляционности написано в заголовке, однако бывают случаи, когда рециркуляционный клапан записан как горизонтальный. Тогда у него аналоговое управление, и в приводе должен быть постфикс SR. Но и тогда есть одна серьёзная сложность
                            pdmo(header, main_info)
                            recycling_split = header.split('+')  # В одном блоке может быть два клапана - один вертикальный, другой горизонтальный. И тогда вертикальный не является рециркуляционным, а горизонтальный - очень даже является. Но тогда поступим так - вертикальный будет первым, а горизонтальный - вторым. Логично же?
                            pdmo(i, recycling_split, drive_units)
                            drive_unit_type = curr_contentum['Типы клапанов']['воздухозаборный клапан (на входе в установку)'] if 'вертикальный' in recycling_split[i] else curr_contentum['Типы клапанов']['рециркуляционный клапан']  # Для того и нужен json-файл со всеми кодами. На случай, если изменится кодировка, то будет достаточно внести изменения в json-файл. Есть проблема - очень часто я в дальнейшем делаю проверку лениво, просто по тексту, а не по тому, как оно записано в json-файле. Но пока оно сойдёт и так
                        else:  # А дальше начинаются сложности. Если это не рециркуляционный, то блок может быть каким угодно. Самое главное - понять, какой он по счёту
                            if c_amount == 1:  # Если он первый, то это либо воздухозаборый на входе в установку или же вытяжной
                                drive_unit_type = curr_contentum['Типы клапанов']['воздухозаборный клапан (на входе в установку)'] if 'приток' in THE_STREAM or 'П' in main_info_name else curr_contentum['Типы клапанов']['вытяжной клапан']  # Зависит от того, есть ли приточный поток в установке. Если он есть, то это воздухозаборный/ Если нет, то это вытяжной клапан в вытяжной установке. В приточно-вытяжной установке первый клапан будет воздухозаборным
                            else:  # А если это не первый клапан, то...
                                if 'вытяжка' not in THE_STREAM or (main_info_name == 'П'):  # Но приточный клапан на выходе из установки есть в чисто приточных установках
                                    drive_unit_type = curr_contentum['Типы клапанов']['воздухозаборный клапан (на входе в установку)'] if 'блок подготовки воздуха' in header.lower() else curr_contentum['Типы клапанов']['приточный клапан (на выходе из установки)']
                                elif 'вытяжка' in THE_STREAM or 'В' in main_info_name:  # Во всех остальных случаях это будет вытяжной клапан
                                    drive_unit_type = curr_contentum['Типы клапанов']['вытяжной клапан']
                                else:  # Заглушка
                                    drive_unit_type = curr_contentum['Типы клапанов']['вытяжной клапан']
                        pdmo(drive_unit_type, drive_unit_heater_info, drive_unit)
                        for_curr_typical_circuit_design = create_circuit_design(code, c_index, c_amount, drive_unit_type, drive_unit_heater_info, drive_unit)
                    pdmo(for_curr_typical_circuit_design)
                    pass
                    # ========== КОНЕЦ БЛОКА ОПРЕДЕЛЕНИЯ ТИПА КЛАПАНА ==========
                    
                    # ========== БЛОК ОПРЕДЕЛЕНИЯ ПИТАНИЯ ПРИВОДА КЛАПАНА ==========
                    if curr_code_for_blank['Питание привода']:
                        drive_unit_power = curr_code_for_blank['Питание привода']
                    else:  # Тут всё максимально просто - постоянный ток не используется (кроме исключительных случаев, но это руками пропишут), так что везде есть лишь переменный ток. Написано 230 - 230, 24 - 24, всё остальное - тоже 230.
                        drive_unit_power = re.findall(r'(2[23]0|24|FA)', drive_unit, re.IGNORECASE)[0]  # В маркировке привода никогда не будет варианта, когда FA будет относиться к чему-то, кроме питания привода. Вообще
                        pdmo(drive_unit_power)
                        if drive_unit_power == '230':
                            drive_unit_power = curr_contentum['Питание привода']['питание 230В АС']
                        elif drive_unit_power == '24':
                            drive_unit_power = curr_contentum['Питание привода']['питание 24В АС']
                        else:
                            drive_unit_power = curr_contentum['Питание привода']['питание 230В АС']
                    # ========== КОНЕЦ БЛОКА ОПРЕДЕЛЕНИЯ ПИТАНИЯ ПРИВОДА КЛАПАНА ==========

                    # ========== БЛОК ОПРЕДЕЛЕНИЯ УПРАВЛЕНИЯ ПРИВОДА КЛАПАНА ==========
                    posfix = re.findall(r'(S[2R]?)\b', drive_unit, re.IGNORECASE)
                    if curr_code_for_blank['Управление приводом']:
                        drive_unit_cntrl = curr_code_for_blank['Управление приводом']
                    else:  # Тут всё относительно просто - если в приводе есть постфикс SR - это аналоговое управление (возвращаясь к теме с горизонтальным клапаном). Если есть постфикс S или S2 - дискретное. Во всех остальных случаях тоже дискретное. Почему нельзя объединить оба случая в один? Хорошший вопрос. Но постфикс ещё понадобится                                    
                        pdmo(posfix)
                        posfix = posfix[0] if posfix else ''
                        if posfix == 'SR':
                            drive_unit_cntrl = curr_contentum['Управление приводом']['аналоговое управление (0... 10В)']
                        elif posfix in ['S', 'S2']:
                            drive_unit_cntrl = curr_contentum['Управление приводом']['дискретное управление']
                        else:
                            drive_unit_cntrl = curr_contentum['Управление приводом']['дискретное управление']
                    # ========== КОНЕЦ БЛОКА ОПРЕДЕЛЕНИЯ УПРАВЛЕНИЯ ПРИВОДА КЛАПАНА ==========

                    # Есть два довольно абстрактных параметра - количество одинаковых клапанов и количество одинаковых приводов на клапан. Долгое время я это не понимал, а теперь, кажется, начал понимать...
                    if IS_VEROSA:
                        drive_unit_N = re.findall(r'\((\d{1,})', drive_unit, re.IGNORECASE)  # Информация о них будет написана в скобках в обозначении привода
                        drive_unit_N = drive_unit_N[0] if drive_unit_N else ''
                    elif IS_CHANAL:
                        drive_unit_N = re.findall(r'(\d{1,})\s?шт', header, re.IGNORECASE)[0] if 'шт' in header and system_count == 1 else ''
                    elif IS_OBPROM:  # Просто заглушка, чтобы программа не вылетала на общепромке
                        drive_unit_N = ''

                    drive_unit_n = ''  # Тут нужно узнать, что именно считается количеством клапанов - типа, по идее, клапаны, находящиеся в начале и конце должны по-разному обозначаться, и в общий зачёт не идут, разве нет? 
                    pdmo(drive_unit_n, drive_unit_N)

                    if curr_code_for_blank['Дополнительные параметры']:
                        drive_unit_additional = f"-{curr_code_for_blank['Дополнительные параметры']}" if curr_code_for_blank['Дополнительные параметры'] != curr_contentum['Дополнительные параметры']['отсутствует'] else ''
                    else:  # Есть два вида дополнительных параметров - наличие одного или двух встроенных в привод выключателей положения с переключащим сухим контактом. Это зависит от постфикса - если он равен S, то такой выключатель один, S2 - два
                        if posfix == 'S':
                            drive_unit_additional = f"-{curr_contentum['Дополнительные параметры']['наличие одного, встроенного в привод выключателя положения с переключающим «сухим» контактом']}"
                            FIREVENT = False  # Вот тот случай, о котором я говорил, когда не надо применять файрвент, даже если у нас шквал
                        elif posfix == 'S2':
                            drive_unit_additional = f"-{curr_contentum['Дополнительные параметры']['наличие двух, встроенных в привод выключателей положения с переключающими «сухими» контактами']}"
                        else:
                            pdmo(drive_unit)
                            if SHKVAL and 'MV220' not in drive_unit:  # А вот ещё занятный случай. Во всех тех случаях, когда нет "концевиков", КРОМЕ указанного, не применяется шквал и файрвент. Вообще
                                # sg.popup('Отсутствуют концевые выключатели!')  # Вообще тут пользователя надо заставлять делать выбор, но я сюда ещё ни разу не попадал, а если кто и попадёт... Надеюсь, дожить до этого мига
                                SHKVAL, FIREVENT = False, False
                                pass
                            drive_unit_additional = ''
                    
                    pdmo(we_came_from_venti)  # А тут начинается самое интересное. Как я уже упоминал, бывают установки с резервным потоком. Если этот резервный поток осуществляется не через резервную установку, то всё просто - мы здесь быть не должны. А если через резервный внетилятор, то на него есть блок перехода, а в блоке перехода - клапан. Как оказалось, такой клапан является одинаковым для всех блоков перехода в установке. Однако его нужно маркировать не в пункте 1.3, а в пункте 1.12 или 1.13. Именно поэтому дальше по тексту будет сказано, что из 1.12 и 1.13 эта функция снова вызывает саму себя, где ищет клапаны. Однако при вызве эта переменная будет равна истине. Истинность переменной задаётся в другом месте, тут же лишь проверяется, вышли ли мы сюда вообще

                    if we_came_from_venti:  # Если мы и в самом деле здесь оказались после вентиляторов, то...
                        if 'Блок перехода на резервный вентилятор' in header:  # ...надо проверить, а блок ли перехода это? Потому что обычно если это блок перехода, он скипается.
                            we_came_from_venti = False  # Раз мы здесь оказались, то выключаем эту переменную - нам надо лишь единожды здесь оказаться
                        else:  # А если это обычный клапан, то...
                            c_amount -= 1  # ...уменьшаем количество...
                            continue  # ...и идём отсюда
                    else:  # А если мы пришли не от вентиляторов, то...
                        if 'Блок перехода на резервный вентилятор' in header:  # ...проверяем, блок ли перехода? Как уже сказано, нам его не надо записывать в 1.3
                            continue  # Если это оно, то уходим отсюда
                    c_result.append(f"{drive_unit_power}{drive_unit_cntrl}{drive_unit_n}{drive_unit_type}{drive_unit_N}{drive_unit_heater}{drive_unit_additional}")  # Итак, раз мы здесь оказались, то, скорее всего, всё получилось. Теперь нужно лишь объединить все параметры в единое целое
                    
                    # Итак, новые вводные. Так как клапаны - такая важная штука, то для них нужно отдельно и чуть ли не вручную прописывать индексы. Логика в том, что сразу на приточным клапаном нужен рециркуляционный, ежели он есть, хотя тут пусть лучше ещё раз уточнят, потому что мне эта идея кажется сомнительной. Но что мне точно не кажется сомнительным, так это тот факт, что в блоке подготовки воздуха содержится аж три вещи: клапан, нагреватель (жидкостный или электрический) и ещё один клапан, и в типовом схемном решении нужно их описать именно в таком порядке.
                    if len(drive_units) > 1 and 'блок подготовки воздуха' in header.lower():  # Так что да, если блок подготовки и клапанов больше одного, то...
                        for_curr_typical_circuit_design[0] = for_curr_typical_circuit_design[0] + pow(-1, i + 1) * 0.5  # Мы просто схитрим - у нас-то индексы целые числа, но ничто не мешает нам их сделать дробными! У нас бесконечность заключена между двумя целыми числами!
                        pdmo(for_curr_typical_circuit_design[0])
                    if 'Кв(' in for_curr_typical_circuit_design[1]:  # А вот вытяжной клапан всегда надо писать в самом конце. так что...
                        for_curr_typical_circuit_design[0] += 100  # просто херачим сотню. Опять же, не должно быть Веросы с сотней блоков!!!
                    elif 'Кр' in for_curr_typical_circuit_design[1]:  # А вот это снова скользкий момент, в котором я не до конца уверен. То есть, серьёзно, рециркуляционный нужно всегда упоминать сразу за обычным?..
                        pdmo(for_curr_typical_circuit_design[0])
                        pdmo(curr_typical_circuit_design)
                        for cu_ty_ci_de in curr_typical_circuit_design:  # Собственно, ищем индекс первого попавшегося клапана...
                            if 'К(' in cu_ty_ci_de[1]:
                                for_curr_typical_circuit_design[0] = cu_ty_ci_de[0] + 0.5
                                break
                        pdmo(for_curr_typical_circuit_design[0])
                    pdmo(for_curr_typical_circuit_design)
                    c_typical_circuit_design.append(for_curr_typical_circuit_design)  # Записываем в типовое схемное решение всю эту махинацию с числами
                recycling_split = recycling_split and len(recycling_split) > 1
                # ============================== КОНЕЦ ГЛАВЫ VIII ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
            
            def for_1_4(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА IX. ФИЛЬТРЫ ==============================
                """Тут всё максимально просто. Из фильтра нам нужен ровно один параметр, но и то лишь для обозначения реле перепада. Ннам важно лишь наличие фильтра и его местоположение

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                global illumination_theory

                pdmo(header, info)
                pdmo(THE_STREAM.lower())  # А местоположение можно определить отчасти по потоку установки
                c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount))  # В типовое схемное решение сразу записывается Ф№
                pdmo(c_typical_circuit_design)
                if c_amount == 1:  # Итак, логика в чём? Если фильтр только один, то он всегда на притоке - даже если это вытяжка
                    c_result = [curr_contentum['на притоке']]
                else:  # А если их больше, то начинается интересное
                    if 'вытяжка' in THE_STREAM.lower() or (SYSTEM_NAME[0] == 'В'):  # При наличии вытяжного потока последний фильтр всегда будет на вытяжке, так что нужно лишь записать, сколько будет фильтров на притоке (а их всегда колво минус 1).
                        if c_amount == 2:
                            all_filters = [i for i in range(len(ALL_MAIN_INFO)) if 'фильтр' in ALL_MAIN_INFO[i][0].lower()]
                            c_result = [f"{c_amount}{curr_contentum['на притоке']}"] if abs(all_filters[0] - all_filters[-1]) == 1 and IS_VEROSA else [f"{c_amount - 1}{curr_contentum['на притоке']}{INNER_DELIMITER}1{curr_contentum['на вытяжке']}"]
                        else:
                            c_result = [f"{c_amount - 1}{curr_contentum['на притоке']}{INNER_DELIMITER}1{curr_contentum['на вытяжке']}"]  # Можно было обратить на то, что я не добавляю в результат значение, а задаю ему значение в виде массива из одного элемента. Напоминаю, что это связано с тем, как в конце работы этой функции будет обрабатываться результат
                    else:
                        c_result = [f"{c_amount}{curr_contentum['на притоке']}"]
                pdmo(c_result)

                filter_d = float(re.findall(r'd[Pp]в[рн]?=(\d+[.,]?\d+)\s?Па', info, re.IGNORECASE)[0].replace(',', '.'))  # В фильтрах нам нужно забрать зачение давления, которое может быть записано либо как dрвр, либо как dвр, либо как dврн. Это нам нужно для определения диапазона работы реле. На всякий пожарный - раньше тут была другая маска: dpв[рн]?=(\d+)Па
                pdmo(filter_d)
                if not SHKVAL:  # Итак, Шквалы. Логика тут такая - для Шквалов особо много девайсов не надо, достаточно лишь особенных, которые будут с электрокалориферами
                    c_automation_devices = create_automation_devices(code, c_amount, range_select(filter_d))  # Итоговый результат по всем приборам автоматики - это матрица, поэтому мы, по сути, создаём одну строчку, а потом эту строчку приплюсуем к итоговому результату. Поэтому тут у нас, строго говоря, матрица размером 1х3. За подробностями - в эту функцию. О принципе работы функуии "ранж_селект" описано в заголовке. Диапазоны тоже там расписаны


                if illumi:  # Как уже было сказано, нужно будет указывать, есть ли освещение. Возможно, его не надо указывать постоянно...
                    illumination_theory[code].append('освещение' in header.lower() or 'освещение' in info.lower())  # Я говорил, что в блоке фильтров может быть освещение. Если об этом что-то сказано, то просто прибавляем к счётчику. Именно для этого я так и записал ключи в том словаре
                # ============================== КОНЕЦ ГЛАВЫ IX ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design

            def for_1_5(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА X. ПАРАМЕТРЫ ТО ==============================
                """Здесь речь идё в первую очередь о Векторах. Вектор определяется по трём параметрам, которые подставляются в таблицу, а дальше уже из этой таблицы забираются нужные значения. Алгоритм не предполагал, что ключей может быть несколько, а ради одного единственного случая менять его нерационально, поэтому ключ максимально общий. И поэтому надо будет в дальнейшем понять, что именно нашлось

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                global glycol_blank, tvn_15_list, tvn_15, tvk_15
                pdmo(header, info)
                if 'жидкостный' in header.lower() or 'подготовки воздуха,нагрев(вода)' in header.lower() or 'водяной' in header.lower():  # Тут должно быть два случая - либо в шапке есть "воздухоНАГРЕВатель жидкостный", либо же "подготовки воздуха,НАГРЕВ(вода)". Во всех остальных случаях уменьшаем количество найденных значений и всё

                    the_liquid = re.findall(r'([Пп]роп|[Ээ]т)иленг?л?и?к?о?л?ь?:?\s?(.+?)%;', info.lower(), re.IGNORECASE)   # Жидкостный нагреватель, как следует из названия, работает на той или иной жидкости. Это может быть вода, пропиленгликоль или этиленгликоль. И если это что-то, кроме воды, то начинаются серьёзные проблемы. Тут мы определяем содержимое - оно находит только если есть либо пропиленгликоль, либо этиленгликоль. Если просто вода, то будет пустой массив, и хвала богам, если будет он!
                    pdmo(the_liquid)

                    Gzh, t1, t2 = Gzh_t1_t2_creation()  # Для определения векторов нам нужно три параметра. Эти же параметры требуются в пункте 1.8, так что процедуру их создания я вынес в отдельную функцию. Можно заглянуть в неё и посмотреть, что там происходит
                    pdmo(Gzh, t1, t2)

                    if the_liquid:  # Итак, если у нас не вода, то нужно определить процентное отношение гликоля
                        the_liquid = int(the_liquid[0][1])
                        if the_liquid <= 40:  # Если он меньше сорока, то всё просто
                            schema = 3  # Просто нужна другая схема
                            glycol_blank.append('')
                        else:  # В остальных случаях узел рассчитывается где-то отдельно, вручную, но об этом нужно дать указание
                            for_unusial_files['glycol_blank'][0] = True
                            for_unusial_files['glycol_blank'][1].append('')

                            if streamlit_version or flask_version:
                                glycol_blank.append(f"НОМЕР_БЛАНКА_{len(for_unusial_files['glycol_blank'][1]) - 1}")
                            else:
                                pass
                                # glycol_blank.append(show_file(f"sg.popup_get_text('Введите номер бланк-заказа для водосмесительного узла ТО{curr_amount}')") if not FAST_MODE else 'НОМЕР_БЛАНКА')  # Введённый номер бланка будет ещё дополнительно внесён в бланк для заказчика. И да, счётчик количества нагревателей не надо менять - нагреватель-то есть, просто его считает не эта программа, а что-то ещё
                            schema = 7
                            pdmo(glycol_blank, c_result, c_amount)
                    else:  # По умолчанию обычно тут всегда вторая схема используется
                        schema = 2
                        glycol_blank.append('')

                    if schema in [2, 4, 5]:  # От схемы зависит, какое будет управляющее устройство. В шестой всегда Ш, в 1 и 3 - С, а в остальных случаях нужно разбираться отдельно
                        if 120 > t1 >= 100:  # Итак, t1 - это нижняя температура работы вектора. И от неё зависит тип регулирующего устройства - либо Сидельное, либо Шаровое
                            control_device = 'С'  # Сидельное бывает лишь в диапазоне температур от 100 до 120
                        elif t1 < 100:  # Шаровое нужно лишь в температурах до сотни
                            control_device = 'Ш' if Gzh <= 14_000 else 'С'  # Занятный вышел тут баг - шаровой в теории работает только до 14к Гж, а выше уже требуется сидельный. Ввёл такой вот костылик. Всё ещё считаю, что правильнее будет подбрать в таком случае по программе Руслана, ну да ладно
                        else:  # Однако что будет, если температура работы вектора выше ста двадцати градусов? Это физически очень сложно - в векторе вода, как бы, она выше ста градусов сохраняет жидкую форму лишь при повышенном давлении, поэтому выше ста двадцати градусов её сложно будет разогнать. но в таком случае...
                            if window_version:
                                control_device = 'С' if show_file(f"popup_true_false('Температура на выходе из источника тепла составляет нестандартные {t1} градусов. Нажмите Yes, если нужно выбрать С. Нажмите No - Ш')") else 'Ш'  # нужно задать вопрос, что выбрать. Эта конструкция сработает, кстати, даже если мы в тестовом режиме - просто из ниоткуда появится окошко
                            else:
                                control_device = 'С'
                    elif schema == 6:
                        control_device = 'Ш'
                    else:
                        control_device = 'С'

                    tvn_tvk_15 = re.findall(r'tвн=(.+?)°C;.*?tвк\*?=(.+?)°C', info, re.IGNORECASE)  # Помните мы задали эти переменные в начале программы? Вот они и всплыли в первый раз. Здесь мы их лишь задаём. Они понадобятся через главу
                    if tvn_tvk_15:  # Если что-то нашлось (а оно обычно находится), то мы...
                        tvn_15, tvk_15 = map(float, tvn_tvk_15[0])  # ...переводим в число...
                        tvn_15_list.append(tvn_15)  # ...и сохраняем в общий массив
                    pdmo(info, tvn_tvk_15, tvn_15, tvk_15, tvn_15_list)  # На этом про эти переменные можно забыть

                    pump_phase_begin, pump_phase_power, pump_W, pump_I, pump_options, control_valve_power, control_valve_contr = vector_creation(Gzh, control_device, schema)  # В какой-то момент мне это всё надоело, и в итоге я создал отдельную функцию, которая внутри себя проходит по таблице информации о векторах и возвращает нужные параметры. Подробнее об этом расписано внутри самой функции, так что за уточнением прошу проследовать туда, а мы продолжаем
                    pdmo(pump_phase_begin, pump_phase_power, pump_W, pump_I, pump_options, control_valve_power, control_valve_contr)

                    # Отсюда могут начаться сложности, потому что дополнительные параметры теплообменника... довольно сложные  
                    if curr_code_for_blank['Дополнительные параметры']['Дополнительные параметры']:
                        additional = curr_code_for_blank['Дополнительные параметры']['Дополнительные параметры']
                    else:
                        air_preparation_unit = any('подготовки воздуха,нагрев(эл)' in the_header for the_header, _ in ALL_MAIN_INFO)  # Смотрите, какая штука. Нам нужно уже здесь узнать об электронагревателе, хотя программа до него ещё не дошла. решение - быстро заглянуть в будущее и, по сути, ещё раз прогнать весь файл, вытащить все найденные блоки подготоки воздуха черех электронагреватель. Зачем нам это?
                        pdmo(air_preparation_unit, tvn_15_list)
                        if (curr_amount > 1 and tvn_15_list[1] > tvn_15_list[0]) or air_preparation_unit:  # Потому что от этого зависит, в каком режиме будет работать этот теплообменник. И да, я соврал - нам уже тут нужны температуры. Вернее, они сыграют свою роль, если теплообменников два. и если у второго температура выше первого, или же если это вообще второй нагреватель после электроподготовительного...
                            additional = curr_contentum['Дополнительные параметры']['Дополнительные параметры']['работа в режиме «Зима» в качестве дополнительного нагревателя (общий датчик)']  # То он работает в режиме, описанном в ключе
                        else:  # Во всех остальных случаях ТО является основным нагревателем. Иных вариантов нет (пока)
                            additional = curr_contentum['Дополнительные параметры']['Дополнительные параметры']['работа в режиме «Зима» в качестве основного нагревателя (общий датчик)']
                    pump_I = f"[{pump_I}]" if pump_I else '' # Чтобы упростить мне процедуру записи результата, я проверяю, а есть и сила тока, которая должна быть записана в квадраных кавычках
                    control_valve_power = f'-{control_valve_power}' if pump_W and pump_I and pump_phase_power else control_valve_power # Перед параметрами крана должен быть дефис, а его не должно быть, если нет насоса
                    if schema > 6:
                        c_result.append("Внести данные из бланка вручную")
                    else:
                        c_result.append(f"{pump_W}{pump_I}{pump_phase_power}{pump_options}{control_valve_power}{control_valve_contr}-{additional}")  # Добавляем результат - но на этом работа с вектором не окончена!
                    pdmo(c_result)
                    pass

                    # ========== БЛОК ПОИСКА ДЛИНЫ ШЛАНГА ==========
                    if IS_VEROSA:  # Длина шланга зависит от типоразмера Веросы (В кна)
                        shlang_indexes = [shlang[1] for shlang in SHLANG_DATA]  # Как я упоминал вскользь, не все индексы представлены в таблице. Поэтому нам надо найти ближайший индекс к требуемому. Для этого нам нужны вообще все индексы
                        pdmo(shlang_indexes, verosa_type_size)  # на всякий случай проверяем и веросу, и индексы
                        if verosa_type_size:
                            verosa_tipe = min(shlang_indexes, key=lambda x:abs(x - int(verosa_type_size[2])))  # А теперь начинается самое весёлое. Итак, у нас есть все виды индексов. Однако если индекс текущей установки отличен от них, то мы находим ближайший, а ближайший - это, очевидно, тот, кто минимальный по модулю. Лямба-функции - наше всё
                            pdmo(verosa_tipe)
                            
                            for shlang in SHLANG_DATA:  # Пробегаемся по таблице
                                pdmo(shlang)
                                if verosa_tipe == shlang[1]:  # И осознаём весёлое - типоразмер Веросы нам вообще не требуется, самое главное - индекс Веросы.
                                    shlang_lengths = shlang[2]
                                    # [tuple(map(int, shlang_term.split('х'))) for shlang_term in shlang[2].split(inner_delimiter)]  # Короче, тут всё настолько просто, что даже несмешно. Итак, в таблице значения даны в виде "ЧИСЛО1хЧИСЛО2 + ЧИСЛО3хЧИСЛО4". ЧИСЛО1 и ЧИСЛО3 - это КОЛИЧЕСТВО требуемых капилляров, а ЧИСЛО2 и ЧИСЛО4 - это ДЛИНА ОДНОГО КАПИЛЛЯРА. Логика в том, что нам нужно внести в таблицу упоминание про капилляры с указанием ДЛИНЫ КОНКРЕТНОГО ТИПА КАПИЛЛЯРА и с указанием КОЛИЧЕСТВА ДАННЫХ КАПИЛЛЯРОВ
                                    pdmo(shlang_lengths)  # Проверяем результат и выходим - больше тут делать нечего
                                    break
                        else:  # Заглушка для противодействия эйрмейтам - надо будет узнать вообще, 
                            shlang_lengths = '1х3'
                    elif IS_CHANAL:
                        shlang_lengths = '1х3'
                    # ========== КОНЕЦ БЛОКА ПОИСКА ДЛИНЫ ШЛАНГА ==========
                    if not SHKVAL:
                        c_automation_devices = create_automation_devices(code, c_amount, the_liquid, shlang_lengths, schema)

                    c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, pump_phase_begin))  # Заносим в стиповое схемное решение. Именно для этого нам и нужна была та странная переменная начала фазы
                else:
                    c_amount -= 1
                # ============================== КОНЕЦ ГЛАВЫ X ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design

            def for_1_6(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА XI. ДРУГИЕ ТИПЫ НАГРЕВАТЕЛЕЙ ==============================
                """В этом разделе рассматриваются паровые, газовые и дизельные нагреватели. Хотя газовых нагревателей очень мало, а о дизельных вообще никто не знает, поэтому, по сути, тут речь о паровых

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                if 'паровой' in header.lower():  # С паровыми всё максимально просто - там всегда будет обозначение PO-1au, кроме каких-то особых случаев, которые внесут руками. Поэтому я позволю себе тут не останавливаться на каждой строчке, которая работает по принципу "если есть внесённые руками значения, бери их, иначе бери значения по умолчанию"
                    c_contentum = curr_contentum['ПО']
                    c_code_for_blank = curr_code_for_blank['ПО']
                    po_power = c_code_for_blank['Питание привода'] if c_code_for_blank['Питание привода'] else c_contentum['Питание привода']['питание 24В; DC']
                    po_engine = c_code_for_blank['Управление приводом'] if c_code_for_blank['Управление приводом'] else c_contentum['Управление приводом']['аналоговое (0... 10В)']
                    po_addit = f"-{c_code_for_blank['Дополнительные параметры']}" if c_code_for_blank['Дополнительные параметры'] else ''
                    c_result.append(f"{c_contentum['Наличие']['присутствует']}-{po_power}{po_engine}{po_addit}")  # Сохраняем результат
                elif 'газовый' in header.lower():  # Если верить таблице, то тут нужно снова считать мощность, ток и тип питания, так что может понадобиться функция фор_ВИЛ, но пока что имеем то, что тут у нас лишь заготовки. Но бланки в природе существуют. Но их так мало, что даже не найти такой...
                    c_contentum = curr_contentum['ГН']
                    c_code_for_blank = curr_code_for_blank['ГН']
                    c_result.append(c_contentum['Наличие']['присутствует'])  # Но если это чудо произойдёт, я всё-таки внесу его в результаты
                    # ''  # Не забыть это вставить впереди итогового результата
                elif 'дизельный' in header.lower():   # Если верить таблице, то тут нужно снова считать мощность, ток и тип питания, так что может понадобиться функция фор_ВИЛ, но пока что имеем то, что тут у нас лишь заготовки. А в существовании дизельных нагревателей сомневаются даже старожилы, которые тут работают почти столько же, сколько жив я сам (а сам я уже неприлично стар)
                    c_contentum = curr_contentum['ДН']
                    c_code_for_blank = curr_code_for_blank['ДН']
                    c_result.append(c_contentum['Наличие']['присутствует'])  # Но если это чудо произойдёт, я всё-таки внесу его в результаты
                else:
                    c_amount -= 1  # Во всех остальных случаем уменьшаем количество - это значит, что програма нашла любой другой нагреватель
                # ============================== КОНЕЦ ГЛАВЫ XI ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design

            def for_1_7(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА XII. ЭЛЕКТРОНАГРЕВАТЕЛИ ==============================
                """Как и в случае с жидкостным нагревателем, тут тоже нужно два ключа

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                global tvn_15_list, tvn_15, tvk_15, air_preparation_unit

                pdmo(header, info)
                if 'электрический' in header or 'подготовки воздуха,нагрев(эл)' in header:  # Тут должно быть два случая - либо в шапке есть "электрический НАГРЕВатель", либо же "подготовки воздуха,НАГРЕВ(эл)". Во всех остальных случаях уменьшаем количество найденных значений и всё
                    if curr_code_for_blank['Питание']:
                        electric_heater_power = curr_code_for_blank['Питание']
                    else:  # Тут снова сложности в зависимости от того, вероса это или каналка
                        electric_heater_the_index = re.findall(r'Индекс: (.+?);', info, re.IGNORECASE)  # В первую очередь нам нужно забрать индекс электронагревателя
                        pdmo(electric_heater_the_index)
                        electric_heater_the_index = electric_heater_the_index[0] if electric_heater_the_index else ''  # Но с этим индексом есть засада - его может не быть. Ничего - ставим заглушку, всё равно там, где он нужен, он есть
                        if IS_VEROSA:
                            electric_heater_power = curr_contentum['Питание']['питание 400В АС, З фазы ЗP']  # По умолчанию для верос такое питание
                        elif IS_CHANAL:  # Тут сложность в том, что ничего не прописано, но... совершенно верно! Это всё уже есть в каталоге! А потом эти же данные нам потребуются для определения фазности, так что мы тут найдём всё, что необходимо, а в следующем разделе просто добавим нужные значения. Однако если бы всё было так просто...
                            electric_heater_mask = r'(ЭКВ)-(К|\d{0,3})-(\d+?)-(.+)'  # Это регулярное выражение будет потом расширяться - пока что считается, что нагреватель может быть либо ЭКВ, либо ЭКВ-К, и я не знаю, есть ли ещё какие-то. Но оно нужно, чтобы разбить на элементы. "Но постой, почему нельзя просто сплитнуть по дефису?" - сразу появляется вопрос. И это хороший вопрос. Я бы сказал, что не знаю, но вообще логика в том, что я хочу потом расширить эту маску... хотя я не знаю, правда...
                            electric_heater_the_index = re.findall(electric_heater_mask, electric_heater_the_index.replace(',', '.'), re.IGNORECASE)[0]  # Как бы там ни было, я тут слишком активно балуюсь с регулярными выражениями, и меня уже не остановить. Ради чего так заморачиваться? В канальном оборудовании могут встречаться устаревшие электронагреватели, кеоторых уже нет в каталоге, и данных на них нет. Поэтому мы подбираем то, что ближе всего по параметрам (читай, по обозначению), к тому, что находится в бланке с огруглением в верхнюю сторону
                            pdmo(electric_heater_the_index)
                            for channel_pair in pairwise(CHANNEL_ELECTRIC_HEATER_DATA):  # Как часто вам встречалась задачка "нужно сравнить что-то в двух соседних значениях списка"? Думаю, постоянно. А если я вам скажу, что для этого есть в модуле итертулс отдельный итератор пейрвайз, который выплёвывает попарно соседние элементы: то есть, из списка 0, 1, 2, 3 он создаёт 0-1, 1-2, 2-3! Невероятно крутая хрень!
                                # pdmo(channel_pair)
                                curr_elec_heat_the_index_1, curr_elec_heat_the_index_2 = (re.findall(electric_heater_mask, cp[0].replace(',', '.'), re.IGNORECASE)[0] for cp in channel_pair)  # Для начала разбиваем сами строки с обозначениями на два отдельных списочка.
                                # pdmo(curr_elec_heat_the_index_1, curr_elec_heat_the_index_2)
                                if curr_elec_heat_the_index_1[1] == 'К' and curr_elec_heat_the_index_2[1] == 'К' and electric_heater_the_index[1] == 'К':  # Есть два случая - когда у нас ЭКВ-К и когда у нас просто ЭКВ. Отличаются, очевидно, наличием буквы К во второй позиции индекса. Так что если она есть и там, и там, то это ЭКВ-К. Если нет ни там, ни там - это ЭКВ. Так что мы находим лишь расстояния того типа нагревателя, который у нас находится в бланке
                                    cehti_1, ehti, cehti_2 = curr_elec_heat_the_index_1[2:], electric_heater_the_index[2:], curr_elec_heat_the_index_2[2:]  # Нам нужно работать с числовыми частями обозначения. В одном случае они начинаются со второго индекса
                                elif curr_elec_heat_the_index_1[1] != 'К' and curr_elec_heat_the_index_2[1] != 'К' and electric_heater_the_index[1] != 'К':
                                    cehti_1, ehti, cehti_2 = curr_elec_heat_the_index_1[1:], electric_heater_the_index[1:], curr_elec_heat_the_index_2[1:]  # А в другом - с первого
                                else:  # В таблице у меня есть одно место, где в паре окажется ЭКВ и ЭКВ-К. Очевидно, нас это категорически не устраивает, поэтому...
                                    continue  # ...скипаем
                                temp = tuple(map(lambda xxx:(float(xx) for xx in xxx), zip(cehti_1, ehti, cehti_2)))
                                if all(pre <= x <= aft for pre, x, aft in map(lambda xxx:(float(xx) for xx in xxx), zip(cehti_1, ehti, cehti_2))):  # Строчка небольшая, но сколько в ней смысла! В интернете, помнится, сравнивали Питон с японской красавицей в кимоно, которая вся изящная, элегантная, красивая, но неловкая, неспешная, семенит в своём тесном кимоно и ничего не может поделать. Я полностью согласен с этим сравнением: в этом изяществе сокрыто столько смыслов, за парой слов выражено столько, что быстрота уходит на второй план - смысл мне лететь вперёд, если меня окружает ЭСТЕТИКА в чистом виде? Короче говоря, давайте разбирать эту поэзию кода поэтапно. Нам нужно сравнить между собой ряд значений, которых либо два, либо три. Сравниваем мы попадание икса в диапазон. Для этого мы сначала зипуем три расчленённые строки с числами, потом прогоняем через мап, посредством лямбда-функции конвертируя в числа. В мапе у нас получается итератор из двух-трёх итераторов, таящих в себе по три числа каждый. И мы их начинаем выплёвывать, разворачивая это шаг за шагом. Какая же красота!
                                    pdmo(cehti_1, ehti, cehti_2)
                                    electric_heater_the_index, electric_heater_steps, electric_heater_power = channel_pair[0] if cehti_1 == ehti else channel_pair[1]  # Ну а если наше верхнее условие случилось, то нужно проверить, а вообще в каком месте совпало? Тут всё просто - если оно совпало по нижней границе, берём её, во всех других случаях - верхняя, потому что, напоминаю, если значение лежит между, то нужно брать по верхней границе
                                    break
                                pass
                            pdmo(electric_heater_the_index, electric_heater_steps, electric_heater_power)  # Жалко, что весь старый алгоритм оказался невостребован... Ну, я его сохраню, но в другом месте
                            pass
                                
                            pdmo(electric_heater_the_index, electric_heater_steps, electric_heater_power)
                            if electric_heater_power == 'А-1':  # Тут всё прозаично - от схему подключения зависит питание. За уточнениями прошу проследовать в каталог или к автоматчикам.
                                electric_heater_power = curr_contentum['Питание']['питание 230В АС']
                            elif electric_heater_power == 'А-3':
                                electric_heater_power = curr_contentum['Питание']['питание 400В АС, 2 фазы']
                            else:
                                electric_heater_power = curr_contentum['Питание']['питание 400В АС, З фазы ЗP']

                    if curr_code_for_blank['Силовая часть']:
                        electric_heater_power_part = curr_code_for_blank['Силовая часть']
                    else:  # Самое сложное в электронагревателе - определение словой части. По умолчанию она всегда внутри шкафа, но маркировка... Итак, проблемы с ней в случае с веросами и каналкой совершенно разные.
                        if IS_VEROSA:  #  В бланке ступени расписаны, однако нужно расписать КАЖДУЮ ступень, в то время как в самом бланке повторяющиеся ступени записаны как произведение. Объясняю: в бланке может быть написано 1+3*2 - это значит четыре ступени: 1, 2, 2, 2. В бланке КА должно быть записано 1+2+2+2
                            electric_heater_steps = re.findall(r".*?Qгрвкл=(.+?)[а-яА-ЯЁё].*", info, re.IGNORECASE)[0]  # Но сначала нам вообще надо найти это обозначение. Оно будет всегда, можно не волноваться. А дальше... Дальше начинаются сложности. Само это обозначение нам ещё понадобится для типового схемного решения, потому что там нужно в сокращённой форме, а в бланках - в длинной. Такой вот парадокс
                            electric_heater_steps_full = []  # Мы переписываем все эти ступени, и сохраним результаты в новый список, потому что старый нам ещё понадобится
                            pdmo(electric_heater_steps)
                            for electric_heater_step in electric_heater_steps.split('+'):  # По сути, нам вообще не нужно создавать отдельную переменную для разбитого по пробелам обозначения. Совсем не нужно. Правда не нужно, поверьте мне
                                electric_heater_step = electric_heater_step.split('*')  # Зато нужно разбить каждый элемент разбитого массива
                                if len(electric_heater_step) == 2:  # И если он разбился, то...
                                    electric_heater_step_kol, electric_heater_step_pow = map(float, electric_heater_step)  # ...первое число - это множитель, второе - напряжение
                                    electric_heater_step_pow = int(electric_heater_step_pow) if electric_heater_step_pow - int(electric_heater_step_pow) == 0 else electric_heater_step_pow   # С напряжением есть определённая проблема - дробное напряжение людям не нравится, именно поэтому я использую настолько дуболомную конструкцию по выделению целой части. Максимально неээфективно, прекрасно знаю, но мне некуда деваться
                                    electric_heater_step = '+'.join([str(electric_heater_step_pow)] * int(electric_heater_step_kol))  # А теперь начинается мякотка - нам нужно ЦЕЛОЕ ЧИСЛО РАЗ записать в массив СТРОКОВОЕ ОБОЗНАЧЕНИЕ НАПРЯЖЕНИЯ. Таким образом, у нас будет массив из нескольких копий одного и того же напряжения. А потом соедянем это в строчку
                                else:  # А если нет множителя...
                                    electric_heater_step = electric_heater_step[0]  # ...то просто сохраняем результат
                                electric_heater_steps_full.append(electric_heater_step)  # И полученную ступень или ступени заносим в полное обозначение
                            pdmo(electric_heater_steps_full)  # Проверяем
                            electric_heater_power_part = f"EK2[{'+'.join(electric_heater_steps_full)}]"  # Записываем в строку
                        elif IS_CHANAL:  # А тут уже всё расписано за нас в каталоге. Хоть что-то в каталоге сделано не через жопу!
                            electric_heater_power_part = f"EK2[{electric_heater_steps}]"
                        c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, electric_heater_steps, electric_heater_power))  # Добавляем в схемное решение
                        SHKVAL_devices.append(f'Электрокалорифер {electric_heater_the_index}; Qгрвкл = {electric_heater_steps}кВт')  # Электронагреватель тоже надо указывать в бланке шквала, как и его маркировку

                    # Пару глав назад мы создавали переменные, которые означали гранциы температурного режима работы жидкостного теплообогревателя. Логика в том, что нужно понять, накладываются ли друг на друга режимы работы жидкостного и электрического нагревателей, потому что если да...
                    tvn_tvk_17 = re.findall(r'tвн=(.+?)°C;.*?tвк=(.+?)°C', info, re.IGNORECASE)  # Проблема в том, что у электронагревателя может быть не две, а три температуры. Первые два будут всегда...
                    tvn_tvkk_17 = re.findall(r'tвк\*=(.+?)°C', info, re.IGNORECASE)  # А вот третьей может и не быть. Но найти её надо в любом случае
                    pdmo(tvn_tvk_17, tvn_tvkk_17)
                    if tvn_tvk_17:
                        tvn_17, tvk_17 = map(float, tvn_tvk_17[0])  # Если температуры есть, переводим их в числа - их нужно будет потом сравнивать
                        pdmo(tvn_17, tvk_17)
                    if tvn_tvkk_17:
                        tvkk_17 = float(tvn_tvkk_17[0])  # Если температуры есть, переводим их в числа - их нужно будет потом сравнивать
                        pdmo(tvkk_17)

                    if curr_code_for_blank['Управление']:
                        electric_heater_control = curr_code_for_blank['Управление']
                    else:
                        if all_results['1.5'] != '0':  # Впрочем всё может обойтись, если нет жидкостного электронагревателя. Может вознзикнуть вопрос, а что делать, если кроме электрического нагревателя есть что-то из раздела 1.6? Я не знаю, таких примеров я не встречал, серьёзно.
                            pdmo(tvn_15, tvk_15)
                            electric_heater_control = curr_contentum['Управление']['работа в режиме «Переходный»'] if (tvk_15 >= tvk_17 or tvk_15 >= tvkk_17) and (tvn_15 <= tvn_17) else curr_contentum['Управление']['работа в режиме «Зима» в качестве основного нагревателя (общий датчик)']  # Нам нужно сравнить кое-что. Итак, если электрообогреватель находится в пределах нагревателя жидкостного, то это Переходный. Во всех остальных он будет работать в общем режиме
                        else:  # Во всех остальных случаях он будет работать в общем режиме
                            electric_heater_control = curr_contentum['Управление']['работа в режиме «Зима» в качестве основного нагревателя (общий датчик)']

                        # Дальше интересно - нам нужно выяснить, работает ли электронагреватель совместо с охладителем на осушение. Это определяется так - если электронагреватель стоит после фреонового или жидкостного охладителя, то тогда он может теоретически работать на осушение.
                        all_liquid_cooler = [i for i in range(len(ALL_MAIN_INFO)) if key_words['1.8'] in ALL_MAIN_INFO[i][0].lower()]  # Именно поэтому нужно найти все точки вхождения жидкостных охладителей
                        all_liquid_cooler = all_liquid_cooler[0] if all_liquid_cooler else 100  # И выбрать первое найденное значение - этого хватит. 100 нужно просто как заглушка - если вдруг всплывёт ВЕРОСА, где электронагреватель будет на 101-ой позиции, дайте знать!
                        all_freon_cooler = [i for i in range(len(ALL_MAIN_INFO)) if key_words['1.9'] in ALL_MAIN_INFO[i][0].lower()]  # Именно поэтому нужно найти все точки вхождения фреоновых охладителей
                        all_freon_cooler = all_freon_cooler[0] if all_freon_cooler else 100  # И выбрать первое найденное значение - этого хватит. 100 нужно просто как заглушка - если вдруг всплывёт ВЕРОСА, где электронагреватель будет на 101-ой позиции, дайте знать!
                        pdmo(c_index - 1, all_liquid_cooler, all_freon_cooler)
                        if (all_freon_cooler < c_index - 1 or all_liquid_cooler < c_index - 1) and tvn_17 > 0:  # проверка условия - ещё важно, чтобы температура самого электронагревателя была выше нуля
                            if not FAST_MODE:
                                for_unusial_files['electric_heater'][0] = True
                                electric_heater_control = curr_contentum['Управление']['работа в режиме «Лето» совместно с охладителем для осушения воздуха'] if (show_file("popup_true_false('Электрический нагреватель работает совместно с охладителем на осушение?')") if not FAST_MODE and not flask_version and not streamlit_version else True) else curr_contentum['Управление']['работа в режиме «Переходный»']  # Один из немногих случаев, когда без ручного ввода вообще ну никак не обойтись при всём желани. Во всех остальных случаях оно работает как Переходный
                            else:  # Заглушка
                                electric_heater_control = curr_contentum['Управление']['работа в режиме «Переходный»']

                        air_preparation_unit = any('подготовки воздуха,нагрев(эл)' in the_header for the_header, _ in ALL_MAIN_INFO)  # А теперь начинается интересное. Нам снова нужна переменная эир_преперейшн_юнит, но она у нас уже в этом моменте времени задана! Мы её перезадём ещё раз на всякий пожарный - ведь в прошлый раз мы могли туда не зайти из-за ручного вода. Можно ли её задать за пределами цикла? Допускаю. Буду ли я это делать? посмотрим. Зачем нам это снова понадобилось? Ведь электронагреватель работает в особом режиме, если есть подготовка воздуха и есть несколько электронагревателей
                        all_electric_heaters = sum(1 if (key_words[code] in the_header.lower() or key_words[code] in the_info.lower()) and ('электрический' in the_header or 'подготовки воздуха,нагрев(эл)' in the_header) else 0 for the_header, the_info in ALL_MAIN_INFO)  # Нам нужно уже тут узнать, сколько будет электронагревателей, поэтому мы, формально, быстро прогоняем цикл ещё раз, где просто считаем количество электронагревателей. Да, пересчитывается раз за разом, но от этоги никуда не деться
                        pdmo(air_preparation_unit, all_electric_heaters)
                        if air_preparation_unit and all_electric_heaters > 1:  # Так что если у нас несколько электронагревателей, из которых минимум один - подготовки воздуха, то да, работа в особомом режиме
                            electric_heater_control = curr_contentum['Управление']['работа в режиме «Зима» по своему датчику температуры']
                    pdmo(electric_heater_control)
                    c_result.append(f"{electric_heater_power}{electric_heater_power_part}-{electric_heater_control}")
                    if SHKVAL:  # Единственный случай, когда нам нужно указывать что-то специально для шквалов!
                        c_automation_devices = [[
                            'Выключатель путевой',
                            '15к21А231.8',
                            f'{c_amount} шт.'
                        ], [
                            'Канальный датчик температуры приточного воздуха с установочным фланцем',
                            'ДТС405PT1000.В2.320',
                            f'{c_amount} шт.'
                        ]]
                else:
                    c_amount -= 1
                # ============================== КОНЕЦ ГЛАВЫ XII ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design

            def for_1_8(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА XIII. ЖИДКОСТНЫЙ ОХЛАДИТЕЛЬ (ХАРАКТЕРИСТИКИ КРАНА) ==============================
                """Здесь мы снова ищем параметры вектора. Происходящее здесь практически идентично тому, что было в 1.5, только попроще, поэтому я тут останавливаться подробно не буду

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                pdmo(header, info)
                Gzh, t1, t2 = Gzh_t1_t2_creation()
                pdmo(Gzh, t1, t2)
                control_device = 'С'
                schema = 3
                pump_phase_begin, pump_phase_power, pump_W, pump_I, pump_options, control_valve_power, control_valve_contr = vector_creation(Gzh, control_device, schema)
                pdmo(pump_phase_begin, pump_phase_power, pump_W, pump_I, pump_options, control_valve_power, control_valve_contr)
                additional = curr_code_for_blank['Управление'] if curr_code_for_blank['Опции'] else curr_contentum['Опции']['работа на поддержание температуры']  # Разве что опции у охладителя в разы проще задаются.
                c_result.append(f"{control_valve_power}{control_valve_contr}-{additional}")
                c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount))
                # ============================== КОНЕЦ ГЛАВЫ XIII ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design

            def for_1_9(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА XIV. ФРЕОНОВЫЙ ОХЛАДИТЕЛЬ ==============================
                """Тут всё максимально просто - по умолчанию обозначение будет nFO2t, где n - количество контуров, а оно указывается в обозначении

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                # pdmo(info)
                freon_cooler_contur = re.findall(r'контуры=(\d{1,})', info, re.IGNORECASE)[0]  # Просто находим всё количество, пункт про контуры будет всегда
                freon_cooler = '' if int(freon_cooler_contur) == 1 else freon_cooler_contur  # Если их один, то ничего не пишется
                freon_cooler_turnon = curr_code_for_blank['Включение'] if curr_code_for_blank['Включение'] else curr_contentum['Включение']['по датчику']  # по умолчанию FJ2
                freon_cooler_additional = curr_code_for_blank['Дополнительные параметры'] if curr_code_for_blank['Дополнительные параметры'] else curr_contentum['Дополнительные параметры']['работа на поддержание температуры'] # по умолчанию t
                freon_cooler += freon_cooler_turnon + freon_cooler_additional
                c_result.append(freon_cooler)
                for _ in range(int(freon_cooler_contur)):  # Как ни странно, нужно внести каждый контур в схемное решение
                    c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount))
                # ============================== КОНЕЦ ГЛАВЫ XIV ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design

            def for_1_10(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА XV. ПАРАМЕТРЫ РЕКУПЕРАТОРА ==============================
                """С роторным всё просто, с пластинчатым - муторно, а с жидкостным всё настолько сложно, что легко. Но обо всём по порядкпе

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                global JTU_blank
                if 'роторный' in header.lower():  # По умолчанию значение будет TR0[p], кроме каких-то особых случаев. Больше тут нечего говорить
                    c_contentum = curr_contentum['ТР']
                    c_code_for_blank = curr_code_for_blank['ТР']

                    frost_control = c_code_for_blank['Параметр контроля обмерзания'] if c_code_for_blank['Параметр контроля обмерзания'] else c_contentum['Параметр контроля обмерзания']['по перепаду давления']
                    frost_control_freq_cntrl = c_code_for_blank['Частотный преобразователь'] if c_code_for_blank['Частотный преобразователь'] else c_contentum['Частотный преобразователь']['внутри шкафа']
                    
                    c_result.append(f"{c_contentum['Наличие']['присутствует']}{frost_control_freq_cntrl}[{frost_control}]")
                    if not SHKVAL:
                        c_automation_devices = create_automation_devices(code, c_amount, range_select(150), c_contentum['Наличие']['присутствует'])
                    pdmo(c_automation_devices)
                    c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, c_contentum['Наличие']['присутствует'], '0,37кВт'))

                elif 'пластинчатый' in header.lower():  # Текст тут слегка громоздкий, что связано с тем, что в случае с TP0 нужно оказывать параметр контроля обмерзания, в остальных - не надо
                    c_contentum = curr_contentum['ТП']
                    c_code_for_blank = curr_code_for_blank['ТП']
                    frost_control = c_code_for_blank['Параметр контроля обмерзания'] if c_code_for_blank['Параметр контроля обмерзания'] else c_contentum['Параметр контроля обмерзания']['по перепаду давления']  # По умолчанию контроль обмерзания всегда по перепаду давления
                    if c_code_for_blank['Наличие перекрёстноточного теплоутилизатора']:
                        drive_unit_power = f"{c_code_for_blank['Наличие перекрёстноточного теплоутилизатора']}[{frost_control}]" if c_code_for_blank['Наличие перекрёстноточного теплоутилизатора'] != c_contentum['Наличие перекрёстноточного теплоутилизатора']['без привода обводного клапана'] else curr_code_for_blank['Наличие перекрёстноточного теплоутилизатора']  # О чём и речь - если без привода обводнго клапана, то нет парметра контроля обмерзания
                    else:
                        drive_unit = re.findall(r'привод: (.+?);', info, re.IGNORECASE)  # Этот параметр зависит от привода пластинчатого рекуператора, так что находим привод. Его может не быть, если, например, это канальное оборудование
                        if drive_unit:
                            drive_unit = drive_unit[0]
                            pdmo(info, drive_unit)
                            drive_unit_power = re.findall(r'(230|24|FA)', drive_unit, re.IGNORECASE)[0]  # Забираем оттуда ватты
                            pdmo(drive_unit_power)
                            if drive_unit_power == '230':  # По ваттам определяем наличие или отсутствие привода обводного канала
                                drive_unit_power = f"{c_contentum['Наличие перекрёстноточного теплоутилизатора']['с приводом обводного клапана 230В АС']}[{frost_control}]"
                            elif drive_unit_power == '24':
                                drive_unit_power = f"{c_contentum['Наличие перекрёстноточного теплоутилизатора']['с приводом обводного клапана 24В, АС']}[{frost_control}]"
                            else:
                                drive_unit_power = c_contentum['Наличие перекрёстноточного теплоутилизатора']['без привода обводного клапана']
                        else:  # Если у нас нет привода, то для таких случаев есть специальная маркировка, как бы...
                            drive_unit_power = c_contentum['Наличие перекрёстноточного теплоутилизатора']['без привода обводного клапана']

                    if c_code_for_blank['Управление приводом']:
                        drive_unit_cntrl = c_code_for_blank['Управление приводом']
                    else:  # Управление приводом зависит от уже знакомых нам постфиксов. Логика тут такая же, как и в случае с клапанами, подробно останавливаться не буду
                        if drive_unit_power != c_contentum['Наличие перекрёстноточного теплоутилизатора']['без привода обводного клапана']:  # Если у нас есть привод, то нужно указать тип управления, что очевидно
                            posfix = re.findall(r'(S[2R]?)\b', drive_unit, re.IGNORECASE)[0]
                            pdmo(posfix)
                            if posfix == 'SR':
                                drive_unit_cntrl = c_contentum['Управление приводом']['аналоговое управление (0... 10В)']
                            elif posfix in ['S', 'S2']:
                                drive_unit_cntrl = c_contentum['Управление приводом']['дискретное управление']
                            else:  # Эту строчку я добавил, когда расписывал комментарии, но, видимо, в ней не было нужды, но я решил предостеречься
                                drive_unit_cntrl = c_contentum['Управление приводом']['дискретное управление']
                        else:
                            drive_unit_cntrl = ''

                    c_result.append(f"{c_contentum['Наличие']['присутствует']}{drive_unit_power}{'-' + drive_unit_cntrl if drive_unit_cntrl else drive_unit_cntrl}")  # Тут тоже говорить нечего - добавляем то, что надо туда, куда надо
                    if not SHKVAL:
                        c_automation_devices = create_automation_devices(code, c_amount, range_select(150), c_contentum['Наличие']['присутствует'])
                    c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, c_contentum['Наличие']['присутствует'], drive_unit))  # И нужно указать сам привод, не потерять его по ходу дела

                elif 'нагреватель' in header:  # Итак, ЖТУ. В бланке должно быть два блока - "Теплоутилизатор-нагреватель" и "Теплоутилизатор-охладитель", но самое комичное, что, во-первых, второго блока может тупо не быть, и он не нужен, если есть первый, а первый будет всегда. Тут всё максимально просто - мы заносим в результат упоминание про ЖТУ и что его надо внести вручную. Всё. 
                    pdmo(header, info)
                    c_contentum = curr_contentum['ЖТУ']
                    c_code_for_blank = curr_code_for_blank['ЖТУ']
                    c_result.append('JTU (заполните вручную)')
                    c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, c_contentum['Наличие']['присутствует'], ''))  # Да, на заводе в скобки всё сами впишут
                    if not SHKVAL:
                        c_automation_devices = create_automation_devices(code, c_amount, range_select(150), c_contentum['Наличие']['присутствует'])
                    for_unusial_files['JTU_blank'][0] = True
                    JTU_blank = 'НОМЕР_БЛАНКА'
                elif 'охладитель' in header:
                    pdmo(header, info)
                # ============================== КОНЕЦ ГЛАВЫ XV ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design

            def for_1_11(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА XVI. ПАРАМЕТРЫ УВЛАЖНИТЕЛЯ ==============================
                """С увлажнителями логика такова - с паровым всё легко, с сотовым всё посложнее, и сложнее всего с форсуночным. Так что будем говорить по порядку

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                global honeycomb_index
                if 'форсуночная' in header.lower():  # По умолчанию тут только управление насосом (по датчику влажности). опций для насоса по умолчанию нет, а вот питание насоса надо определять отдельно
                    pdmo(header, info)
                    c_contentum = curr_contentum['ФУ']
                    c_code_for_blank = curr_code_for_blank['ФУ']                    
                    humid_name, humid_Ny, humid_U = re.findall(r'.*?назв: (.+?);.*?Ny=(\d+[.,]?\d*?)\D.*?U=(\d+[.,]?\d*?)\D.*', info, re.IGNORECASE)[0]  # Нам от форсуночной камеры требуется три параметра - напряжение, мощность и количество полюсов, а количество полюсов записано в названии камеры
                    humid_pole = int(humid_name[-1])  # Записано последним символом
                    humid_Ny, humid_U = map(float, (humid_Ny, humid_U))  # Конвертируем в числа с запятой
                    pdmo(humid_pole)
                    humid_I = for_engine_I(humid_pole, humid_Ny, humid_U)  # А теперь начинается очень интересное. Чтобы определить силу тока, нужно посмотреть ту импортированную таблицу с двигателями. Вообще та таблица нужна в первую очередь для вентиляторов, однако конкретно зедсь, в форсуночных увлажнителях, она тоже может пригодиться. Подробнее о той функции будет сказано в самой функции
                    pdmo(humid_I)
                    
                    humid_phase = c_contentum['Питание насоса']['однофазное питание'][-2] if humid_U == 230 else c_contentum['Питание насоса']['трехфазное питание'][-2]  # Как и в прошлый раз фазность питания зависит от мощности, и мы забираем предпоследний символ в обозначении, только и всего

                    pdmo(humid_Ny, humid_U, humid_I, humid_phase)
                    if c_code_for_blank['Питание насоса']:  # снова используем функцию фор_ВИЛ с случае, если всплыл ручной ввод
                        humid_Ny, humid_I, humid_phase = for_WIL(humid_Ny, humid_I, humid_phase, c_code_for_blank['Питание насоса'])
                    pdmo(humid_Ny, humid_U, humid_I, humid_phase)
                    
                    humid_option = f"-{c_code_for_blank['Опции для насоса']}" if c_code_for_blank['Опции для насоса'] else ''  # Опций по умолчанию нет
                    humid_manager = c_code_for_blank['Управление насосом'] if c_code_for_blank['Управление насосом'] else c_contentum['Управление насосом']['включение по датчику влажности']  # Управление насосом осуществляется по умолчанию по датчику влажности

                    c_result.append(f"{c_contentum['Наличие']['присутствует']}-{humid_Ny}[{humid_I}]{humid_phase}{humid_option}-{humid_manager}")
                    pdmo(c_result)

                elif 'сотовая' in header.lower():  # С сотовыми логика почти такая же, как и с форсуночным, вот только есть одно серьёзное послабление...
                    c_contentum = curr_contentum['СУ']
                    c_code_for_blank = curr_code_for_blank['СУ']                    
                    honeycomb_W, honeycomb_I, honeycomb_ph = 0.31, 1.43, '1L'  # Насос имеет фиксированные параметры, поэтому их даже высчитывать не надо!
                    if c_code_for_blank['Питание насоса']:  # нет, ну если какой-то особый случай, то можно, но это уж руками
                        honeycomb_W, honeycomb_I, honeycomb_ph = for_WIL(honeycomb_W, honeycomb_I, honeycomb_ph, c_code_for_blank['Питание насоса'])

                    honeycomb_protection = f"-{c_code_for_blank['Опции для насоса']}" if c_code_for_blank['Опции для насоса'] else ''  # Снова, кстати, нет опций по умолчанию
                    honeycomb_plump_control = c_code_for_blank['Управление насосом'] if c_code_for_blank['Управление насосом'] else c_contentum['Управление насосом']['включение по датчику влажности']  # Снова управление по датчику
                    
                    c_result.append(f"{c_contentum['Наличие']['присутствует']}-{honeycomb_W}[{honeycomb_I}]{honeycomb_ph}{honeycomb_protection}-{honeycomb_plump_control}")
                    c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, c_contentum['Наличие']['присутствует']))

                    honeycomb_index = re.findall(r'индекс: (.+?);', info, re.IGNORECASE)  # Однако есть кое-какой параметр, который необходимо сохранить. Вот всплыла одна из глобальных переменных - нам нужно сохранить на будущее индекс сотового увлажнителя. Это понадобится ой как нескоро
                    pdmo(honeycomb_index)
                    if honeycomb_index:
                        honeycomb_index = honeycomb_index[0][-1] != '1'
                    else:
                        honeycomb_index = False
                    pdmo(honeycomb_index, c_result)
                    pass

                elif 'паровая' in header.lower():  # По умолчанию всегда внешнее питание парогенератора. В остальных случаях пусть от руки пишут. больше тут нечего сказать
                    c_contentum = curr_contentum['ПУ']
                    c_code_for_blank = curr_code_for_blank['ПУ']
                    c_result.append(f"{c_contentum['Наличие']['присутствует']}-{c_code_for_blank['Питание парогенератора'] if c_code_for_blank['Питание парогенератора'] else c_contentum['Питание парогенератора']['питание ПУ внешнее']}")
                    c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, c_contentum['Наличие']['присутствует']))
                # ============================== КОНЕЦ ГЛАВЫ XVI ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design

            def for_1_12(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:  # ============================== ГЛАВА XVII. ПАРАМЕТРЫ ПРИТОЧНЫХ И ВЫТЯЖНЫХ ВЕНТИЛЯТОРОВ ==============================
                """Самое сложное, самое запутанное и самое странное место всей программы - вентиляторы. Во-первых, алгоритм работы для приточных и вытяжных абсолютно одинаков, из-за чего тут происходит объединение. Во-вторых, сложно отличить приточные вентиляторы от вытяжных, но это решаемо

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """

                def venti_arguments(the_mask:str, the_type:type, default_value):
                    """Процедура, которая задаёт значение переменной по переданному регулярному выражению, переводит в заданный тип, а если значение по регулярному выражнеию не нашлось, возвращает значение по умолчанию

                    Args:
                        the_mask (str): регулярное выражение, по которому будет искаться и определяться переменная
                        the_type (type): тип возвращаемой переменной
                        default_value (_type_): значение по умолчанию, если переменная не была найдена. Должна быть того же типа, что и предыдущая переменная

                    Returns:
                        _type_: тот же типа, что и передан переменной the_type
                    """
                    the_argument = re.findall(the_mask, info, re.IGNORECASE)
                    return the_type(the_argument[0].replace(',', '.')) if the_argument else default_value

                global THE_BACKUP_STREAM, THE_BACKUP_VENTI, we_came_from_venti, all_distances, switching_typical_circuit_design, illumination_theory, venti_index, venti_venti_amount, venti_engine_Ny

                pdmo(code, header, info)
                if IS_VEROSA:
                    if 'двигатель' not in info and 'рабочая точка' not in info:  # Короче, логика в чём? Если это вентилятор ВЕРОСА, то всегда будут эти пункты. Если их нет, то это что-то иное (обычно просто блок перехода на резервный ВЕНТИЛЯТОР)
                        pdmo('Не вентилятор, а что-то связанное с ним')
                        c_amount -= 1
                        return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design  # Как бы говорим самим себе - скатертью дорога! 

                pdmo(code, header, info)  # И только теперь начинаем разговор о вентиляторах. В первую очередь, нам нужно семь параметров - количество вентиляторов, количество двигателей, Nу двигателя, I двигателя, nдв двигателя, pv двигателя, наличие частотника двигателя. Каждый из них будем считать отдельно, потому что разные параметры по-разному извлекаются.
                
                venti_engine_amount = venti_arguments(r'двигатель.+?колич=(\d{1,})шт', int, 1)  # К счастью, эти пять параметров есть во всех бланках - и Веросах, и каналках
                venti_engine_Ny = venti_arguments(r'Ny=(.+?)\s?кВт' if not IS_INDUST else r'Nу, \[кВт\]; (.+?);', float, 0)  # К счастью, эти пять параметров есть во всех бланках - и Веросах, и каналках
                venti_freq_contr = venti_arguments(r'ЧР: (.+?);' if not IS_INDUST else r'Регулирование; (.+?);', str, '')  # К счастью, эти пять параметров есть во всех бланках - и Веросах, и каналках
                venti_engine_pv = venti_arguments(r'pv=(.+?)\s?Па' if IS_VEROSA or IS_OBPROM else r'Pполн, \[Па\]; (.+?);' if IS_INDUST else r'Pполн=(.+?)\s?Па', float, 0)  # К счастью, эти пять параметров есть во всех бланках - и Веросах, и каналках, вот только тут, как можно заметить, нужно подставлять разные маски
                venti_index = header.split()[1] if IS_OBPROM else venti_arguments(r'[Ии]ндекс: (.+?);', str, '')  # Вообще в Веросах индекс двигателя не нужен, он критически важен для канального оборудования
                venti_name = venti_arguments(r'назв: (.+?);', str, '')  # Название, требуется вообще только для Шквалов, но, как ни парадоксально, более-менее работает везде (или я просто такой могучий, что умудрился сделать ту функцию безотказной?)
                pdmo(venti_engine_amount, venti_engine_Ny, venti_freq_contr, venti_engine_pv, venti_index, venti_name)
                pass

                if IS_CHANAL:  # Загвоздка в том, что в бланках есть количество оборотов в минуту, но нет силы тока, и только в бланках канальников ровно наоборот. Поэтому сначала будет условие про канальное оборудование, а только потом - про всё остальное
                    venti_venti_amount = int(re.findall(r'(\d{1,})\s?шт', header, re.IGNORECASE)[0]) if 'шт' in header and system_count == 1 else 1
                    venti_venti_amount = venti_venti_amount - 1 if 'резерв' in info.lower() or 'резерв' in header.lower() else venti_venti_amount
                    pdmo(venti_venti_amount, venti_index)
                    pass
                    for channel_engine_rotation in CHANNEL_ENGINE_ROTATION_DATA:  # Логика поиска оборотов следующая - у нас есть каталог, в котором для каждого двигателя указаны обороты в минуту. Я скопировал частично тот каталог, и буду по нему пробегать в поисках необходимого, а для этого мне надо забрать индекс двигателя. Как и всегда в таких случаях просто проходим по всей таблице
                        pdmo(channel_engine_rotation)
                        res_ndv = re.findall(fr'{channel_engine_rotation[0]}', venti_index, re.IGNORECASE)
                        pdmo(res_ndv)
                        if res_ndv:  # Ищем нужное
                            venti_engine_ndv = channel_engine_rotation[1]  # Забираем
                            break  # Уходим
                    else:  # Оказалось, что в идиотском каталоге не у всех, мать его, вентиляторов проставлены обороты! А так как эти обороты в канальном оборудовании нахер не упали, то я поставлю такую заглушку, чтобы программа не вылетала - обороты нужны в веросах для рассчёта тока, а тут у нас-то ток дан, так что и обороты не нужны
                        venti_engine_ndv = 0
                    pdmo(venti_engine_ndv)
                    engine_phase = venti_arguments(r'Uпит=~(.+?) В', int, 220)  # Фазность указывается, и, в отличие от Верос, она влияет на разное
                    engine_phase = curr_contentum['Параметры двигателя']['Питание']['однофазное питание'][-2:] if (220 <= engine_phase <= 230) else curr_contentum['Параметры двигателя']['Питание']['трехфазное питание'][-2:]  # По-моему, тут всё очевидно. Слава тернарным операциям!
                    venti_engine_I = venti_arguments(r'Iпот=(.+?)[AА]', float, 0)  # Сила тока просто прописана в бланке. Почему в Веросах так нельзя, ещё раз?
                else:
                    venti_venti_amount = venti_arguments(r'вентилятор.+?колич=(\d{1,})шт', int, 1)  # Этот параметр есть и в канальном оборудовнии, но там задаётся сильно иначе
                    venti_engine_ndv = venti_arguments(r'nдв=(.+?)[мо][иб]н?' if not IS_INDUST else r'n рк, \[об\]; (.+?);', float, 0)
                    if 1500 < venti_engine_ndv <= 3000:  # Определяем количество полюсов - оно зависит от вращающего момента или как эта ерунда вообще называется?
                        venti_engine_poles = 2
                    elif 1000 < venti_engine_ndv <= 1500:
                        venti_engine_poles = 4
                    elif 750 < venti_engine_ndv <= 1000:
                        venti_engine_poles = 6
                    elif venti_engine_ndv <= 750:
                        venti_engine_poles = 8
                    pdmo(venti_engine_poles)
                    engine_phase = curr_contentum['Параметры двигателя']['Питание']['трехфазное питание'][-2:]  # в двигателях вентиляторов верос всегда трёхфазное питание. Вообще однофазное питание может встречаться лишь в канальном оборудовании, как оказалось
                    venti_engine_I = for_engine_I(venti_engine_poles, venti_engine_Ny, 230 if engine_phase == '1L' else 380)  # Так как нам нигде напряжение толком не нужно, то мы можем его объявить буквально здесь, чтобы передать значение в функцию и забрать силу тока
                pdmo(venti_engine_amount, venti_engine_Ny, venti_freq_contr, venti_engine_pv, venti_index, venti_venti_amount, venti_engine_ndv, engine_phase, venti_engine_I)  # Проверяем
                for_SHKVAL = f'Двигатель вентилятора: {venti_name}; индекс: {venti_index}; Ny={venti_engine_Ny}кВт; nдв={venti_engine_ndv}об/мин'  # Для бланка шквалов нужно вот такое вот обозначение
                if for_SHKVAL not in SHKVAL_devices:  # Во избежание дублирования нужна такая проверка. Всё легко
                    SHKVAL_devices.append(for_SHKVAL)

                if curr_code_for_blank['Параметры двигателя']['Питание']:  # Снова используем фор_ВИЛ
                    venti_engine_Ny, venti_engine_I, engine_phase = for_WIL(venti_engine_Ny, venti_engine_I, engine_phase, curr_code_for_blank['Параметры двигателя']['Питание'])
                if curr_code_for_blank['Параметры двигателя']['Опции']:
                    engine_options = curr_code_for_blank['Параметры двигателя']['Опции']
                else:  # В параметрах двигателя по умолчанию именно эта опция, НО ТОЛЬКО ЕСЛИ НЕ КАНАЛ ВЕНТ                    
                    engine_options = curr_contentum['Параметры двигателя']['Опции']['использовать встроенное термореле двигателя']
                curr_curr_result = f"{venti_engine_amount}x" if venti_engine_amount > 1 else ''  # Если двигателей несколько, надо об этом указать
                if venti_venti_amount > 1:  # Если вентиляторов несколько, надо об этом указать... и заодно изменить количество вентиляторов!
                    if f"{venti_venti_amount}x" not in curr_curr_result:
                        curr_curr_result += f"{venti_venti_amount}x"
                    c_amount = c_amount - 1 + venti_venti_amount
                    pdmo(c_amount)

                curr_curr_result += f"{venti_engine_Ny}[{venti_engine_I:.2f}]{engine_phase}-{engine_options}"  # Да, мы объявляем текущий текущий результат, потому что мы будем очень долго и очень подробно редактировать текущий текущий результат

                only_one_type = tuple(value for value in curr_code_for_blank['Тип управления двигателем'].values() if value and value != '-')  # Ох, с чего бы начать? Насколько я понимаю, для вентилятора может быть только один тип управления (о случаях, когда нужно много, мне никто не говорил). При этом выбор этого единственного режима делается из нескольких пунктов, где их может быть дофига и больше... Я только что понял, что могу просто устранить все эти уровни! Ну ладно, потом этим займусь. Главное, что тут я проверяю, как много пользователь понавыбирал в оконной форме (если её нет, то словарь пустой, так что насрать)

                match len(only_one_type):  # А теперь начинается потеха - нам нужно понять, а сколько вообще пользователь понатыкал вариантов?
                    case 1:  # Если он поступил как умный мальчик (или девочка (или боевой вертолёт или ещё какой гендер)), то мы просто добавляем выбранное значение
                        curr_curr_result += f"-{only_one_type[0]}"
                    case 0:  # Если ничего не выбрал, то оставляем ту часть, что про частотные преобразователи. Один из основных типов управления двигателей, который пока был рассмотрен - частотый преобразователь. Дальше, возможно, пойдёт речь о некиих ЕС-двигателях, но пока что о них никто не заикается. С частотниками всё относительно просто - сначала мы ищем, указано ли об этом в разделе "ЧР: да/нет"
                        if venti_freq_contr in ('да', 'Частотное') :
                            curr_curr_result += f"-{curr_contentum['Тип управления двигателем']['частотный преобразователь']['вне шкафа']}"
                        elif venti_freq_contr != 'нет':  # Потом на всякий случай проверяем вообще всю информацию - есть ли там упоминание частотника. Ради этого мне пришлось прям поработать над моим модулем!
                            pdmo(ALL_MAIN_INFO)
                            pass
                            if 'частотн' in info:
                                curr_curr_result += f"-{curr_contentum['Тип управления двигателем']['частотный преобразователь']['вне шкафа']}"  # Если частотника нет, то и хрен с ним
                            else:
                                if IS_CHANAL:
                                    if 'Регулятор' in ALL_MAIN_INFO[-1][1]:
                                        curr_curr_result += f"-{curr_contentum['Тип управления двигателем']['частотный преобразователь']['вне шкафа']}"  
                                        pass
                    case _:  # А если он, дурак(дура) умудрился выбрать два и больше (или меньше нуля, хотя я хуй знает, как это можно сделать), то...
                        message = 'Было выбрано несколько типов управления двигателем! Не будет указан ни один из них. В следующий раз укажите только один!!!'  # Посылаем его нахер
                        # sg.popup(message) if window_version else pdmo(message)
                        pass

                venti_engine_Ny = int(venti_engine_Ny) if venti_engine_Ny - int(venti_engine_Ny) == 0 else venti_engine_Ny  # Для вычислений требовались точные значения параметров, однако в графу типового схемного решения надо указать целые числа. Не будем им в этом отказывать
                venti_engine_ndv = int(venti_engine_ndv) if venti_engine_ndv - int(venti_engine_ndv) == 0 else venti_engine_ndv  # Для вычислений требовались точные значения параметров, однако в графу типового схемного решения надо указать целые числа. Не будем им в этом отказывать
                for_curr_typical_circuit_design = f'(Nу={venti_engine_Ny}кВт; nдв={venti_engine_ndv}об/мин)' if IS_VEROSA else f'(Nу={venti_engine_Ny}кВт; Iпот={venti_engine_I}А; ~{engine_phase[0]})'
                pdmo(for_curr_typical_circuit_design)

                if 'резерв' in info.lower() or 'резерв' in header.lower():  # Речь здесь идёт либо о резервном двигателе, либо о резервном вентиляторе. Резервный поток будет рассмотрен позже. Важное примечание - если у нас два вентилятора и два двигателя, то это ещё не значит, что они резервные! 
                    pdmo(info)
                    if IS_VEROSA:
                        back_engine = re.findall(r'резервн?[а-я]{0,3} двигател[а-я]{1,3}', info.lower(), re.IGNORECASE)  # Нас вообще не волнует, что написано про двигатели. Главное, чтобы хоть что-то да было написано
                        back_ventil = re.findall(r'резервн?[а-я]{0,3} вентилятор[а-я]{0,3}', info.lower(), re.IGNORECASE)  # Нас вообще не волнует, что написано про вентиляторы. Главное, чтобы хоть что-то да было написано
                    elif IS_CHANAL:
                        back_engine = 'резерв' in info.lower()
                        back_ventil = 'резерв' in header.lower()
                    pdmo(back_engine, back_ventil)
                    pass
                    THE_BACKUP_VENTI = True

                    if back_engine and back_ventil:  # Я их использую как своеобразные булевые переменные. Нужно указать то, что есть. Есть оба - указываем оба
                        curr_curr_result += f"-{curr_contentum['Резервирование']['наличие резервного двигателя']}/{curr_contentum['Резервирование']['наличие резервного вентилятора']}"
                    elif back_engine:
                        curr_curr_result += f"-{curr_contentum['Резервирование']['наличие резервного двигателя']}"
                    elif back_ventil:
                        curr_curr_result += f"-{curr_contentum['Резервирование']['наличие резервного вентилятора']}"
                        c_amount += 1  # А ещё раз у нас есть дополнительный вентилятор, то их количество увеличится, само собой разумеется.
                    else:  # 
                        THE_BACKUP_VENTI = False
                    for_curr_typical_circuit_design_part_1 = 'АВп'
                else:
                    for_curr_typical_circuit_design_part_1 = ''
                pdmo(for_curr_typical_circuit_design_part_1)
                pass
                
                if THE_BACKUP_STREAM:  # А теперь начинается самое интересное - если есть резервный поток. Мы до этого уже в разделе клапонов узнали, что если он есть, то мы придём отсюда от вентиляторов? Вот, собственно, здесь мы и начинаем это рассматривать
                    if curr_contentum['Резервирование']['наличие резервного вентилятора'] not in curr_curr_result:
                        curr_curr_result += f"-{curr_contentum['Резервирование']['наличие резервного вентилятора']}"

                    # Помните мы создавали все расстояния? Итак, урок в теории графов!
                    max_otr = [max(distance for distance in distances if distance < 0) if [distance for distance in distances if distance < 0] else 0 for distances in all_distances]  # Если у двух разных вентиляторов есть одинаковое общее максимальное отрицательное расстояние, то это означает наличие блока перехода до вентилятора, и эти блока находятся на указанном расстоянии. Ноль - заглушка на случай, если ничего нет
                    min_pol = [min(distance for distance in distances if distance > 0) if [distance for distance in distances if distance > 0] else 0 for distances in all_distances]  # Если у двух разных вентиляторов есть одинаковое общее минимальное положительное расстояние - наличие блока перехода после вентилятора на этом вот расстоянии. Ноль - заглушка на случай, если ничего нет
                    they_are_behind, they_are_ahead = len(set(max_otr)) == 1, len(set(min_pol)) == 1  # Так как мы ищем расстояния для двух вентиляторов, то и расстояний должно быть по два. Но они должны быть одинаковыми, чтобы можно было сказать, что сзади или спереди что-то есть
                    
                    pdmo(max_otr, min_pol)
                    pdmo(they_are_behind, they_are_ahead)
                    
                    we_came_from_venti = True  # Вот тут и меняется та переменная про "мы_пришли_от_вентиляторов"
                    switching_automation_devices, switching_results, switching_amount, switching_typical_circuit_design = through_all_main_info('1.3')  # Обращаемся к этой же самой функции (рекурсия!), однако только вытаскиваем клапаны. Как мы помним, если активен триггер "мы_пришли_от_венти", то тогда мы заберём только один клапан, находящийся в блоке перехода на резервный клапан. Из этого всего многообразия нам нужен только результат и привод клапана. Но тут нам нужен результат.
                    # "Но Саня, - спросите вы, - а какого хера ты обращаешься к этой функции, если специально для этого существует функция фор_3?" Отличный вопрос, на самом деле! Понимаете, все функции "фор_число" работают только когда мы нашли в потоке ячейку с нужными данными. так что нам нужно ещё раз прогнать весь бланк. "Фор_число" не сработает, потому что мы бы здесь не прогоняли бланк, а пытались бы вычитать значение из этой же ячейки, в которой у нас, напоминаю, вентилятор.
                    # pdmo(switching_automation_devices, switching_results, switching_amount, switching_typical_circuit_design)
                    we_came_from_venti = False  # Хоть мы уже отключили переменную, отключить ещё раз будет нелишним
                    if switching_results != '0':  # Хоть оно и должно всегда находить клапаны, лишняя мера предосторожности не помешает
                        switching_results = ''.join(re.findall(r'(1|3)(d|ai|au)', switching_results, re.IGNORECASE)[0])  # Ну а если оно нашлось, то можно без особого зазрения совести извлекать обозначения, которые будут записаны с указанием на то, где они находятся - сзади или спереди
                        if they_are_behind:
                            curr_curr_result += f" + {switching_results}{curr_contentum['Приводы отсечных клапанов']['Отсечной клапан']['до вентилятора']}"
                        if they_are_ahead:
                            curr_curr_result += f" + {switching_results}{curr_contentum['Приводы отсечных клапанов']['Отсечной клапан']['после вентилятора']}"
                        
                        for_curr_typical_circuit_design_part_1 = 'АВ'  # В таком случае будет особое обозначение в типовом схемном решении
                        pdmo(curr_curr_result)
                        if curr_curr_result in c_result:  # Итак, так как эта программа дважды цепляет один и тот же вентилятор, принимая его то за приточный, то за вытяжной, то мне надо исключить дублирование в том случае, если у нас явно во второй раз произошло повторение
                            pdmo(c_amount)
                            c_amount -= 1  # Если есть, то снова уменьшаем количество
                            return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                    c_amount += 1
                else:
                    switching_typical_circuit_design = ''  # Так как этот параметр нам ещё понадобится, то нам надо его объявить хотя бы тут, чтобы не было ошибки
                    for_curr_typical_circuit_design_part_1 = for_curr_typical_circuit_design_part_1 if for_curr_typical_circuit_design_part_1 else ''
                pdmo(for_curr_typical_circuit_design_part_1)
                pass
                
                if 'клапан' in info:
                    pdmo(info)
                    klapan_number = re.findall(r'Гермик-[А-Я]+?-\d{4}-\d{4}-[А-Я]+?-[А-Я]+?-(\d{2})', info, re.IGNORECASE)[0]
                    pdmo(klapan_number)
                    match klapan_number:
                        case '02':
                            klapan_name = ''
                        case '03':
                            klapan_name = ''
                        case '04':
                            klapan_name = ''
                        case '05':
                            klapan_name = ''
                        case '06':
                            klapan_name = ''
                        case '07':
                            klapan_name = ''
                        case '08':
                            klapan_name = ''
                        case '09':
                            klapan_name = ''
                        case '10':
                            klapan_name = ''
                        case '11':
                            klapan_name = ''
                        case '12':
                            klapan_name = ''
                        case '13':
                            klapan_name = ''
                        case '14':
                            klapan_name = ''

                        case '21':
                            klapan_name = 'M24-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 24В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['аналоговое управление (4...20mA, 2-проводная)']
                            klapan_addd = ''
                        case '22':
                            klapan_name = 'M24-S-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 24В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['дискретное']
                            klapan_addd = curr_contentum['Приводы отсечных клапанов']['Дополнительные параметры']['наличие одного, встроенного в привод выключателя положения с переключающим «сухим» контактом']
                        case '23':
                            klapan_name = 'M230-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 230В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['аналоговое управление (4...20mA, 2-проводная)']
                            klapan_addd = ''
                        case '24':
                            klapan_name = 'M230-S-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 230В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['дискретное']
                            klapan_addd = curr_contentum['Приводы отсечных клапанов']['Дополнительные параметры']['наличие одного, встроенного в привод выключателя положения с переключающим «сухим» контактом']
                        case '25':
                            klapan_name = 'M24-SR-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 24В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['аналоговое управление (0...10В)']
                            klapan_addd = ''
                        case '26':
                            klapan_name = 'M24-SR-S2-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 24В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['аналоговое управление (0...10В)']
                            klapan_addd = curr_contentum['Приводы отсечных клапанов']['Дополнительные параметры']['наличие двух, встроенных в привод выключателей положения с переключающими «сухими» контактами']
                        case '27':
                            klapan_name = 'M230-SR-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 230В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['аналоговое управление (0...10В)']
                            klapan_addd = ''
                        case '28':
                            klapan_name = 'M230-SR-S2-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 230В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['аналоговое управление (0...10В)']
                            klapan_addd = curr_contentum['Приводы отсечных клапанов']['Дополнительные параметры']['наличие двух, встроенных в привод выключателей положения с переключающими «сухими» контактами']
                        case '29':
                            klapan_name = 'F24-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 24В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['аналоговое управление (4...20mA, 2-проводная)']
                            klapan_addd = ''
                        case '30':
                            klapan_name = 'F24-S-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 24В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['дискретное']
                            klapan_addd = curr_contentum['Приводы отсечных клапанов']['Дополнительные параметры']['наличие одного, встроенного в привод выключателя положения с переключающим «сухим» контактом']
                        case '31':
                            klapan_name = 'F230-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 230В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['аналоговое управление (4...20mA, 2-проводная)']
                            klapan_addd = ''
                        case '32':
                            klapan_name = 'F230-S-V'
                            klapan_supp = curr_contentum['Приводы отсечных клапанов']['Питание привода']['питание 230В АС']
                            klapan_ctrl = curr_contentum['Приводы отсечных клапанов']['Управление приводом']['дискретное']
                            klapan_addd = curr_contentum['Приводы отсечных клапанов']['Дополнительные параметры']['наличие одного, встроенного в привод выключателя положения с переключающим «сухим» контактом']

                    if klapan_name:
                        pdmo(klapan_name)
                        curr_curr_result += f" + {klapan_supp}{klapan_ctrl}{curr_contentum['Приводы отсечных клапанов']['Отсечной клапан']['до вентилятора']}{'-' + klapan_addd if klapan_addd else ''} + {klapan_supp}{klapan_ctrl}{curr_contentum['Приводы отсечных клапанов']['Отсечной клапан']['после вентилятора']}{'-' + klapan_addd if klapan_addd else ''}"
                        pdmo(curr_curr_result)
                        pass
                    pass

                pdmo(for_curr_typical_circuit_design_part_1)
                pass

                if 'АВ' not in for_curr_typical_circuit_design_part_1:  # Логика в том, что если у нас нет этого обозначения, то надо прописать обозначение "Вп" или "Вв" в зависимости от типа вентилятора. Но и тут всё не так просто...
                    if venti_venti_amount > 1:  # Если у нас несколько вентиляторов в одном блоке (и они не резервные, что важно!), то нужно указать ВСЕ вентиляторы, поэтому нужно пробежаться таким вот циклом, где каждый вентилятор добавится отдельно
                        for i in range(venti_venti_amount):
                            c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, f"В{i + 1}{'п' if code == '1.12' else 'в'}", for_curr_typical_circuit_design))  # Тут простенький тернарный оператор, который задаёт вторую букву в обобзначении в зависимости от кода. Всё равно мы сюда не можем попасть в иных случаях, кроме как при кодах 1.12 или 1.13
                    else:
                        c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, f"В{'п' if code == '1.12' else 'в'}", for_curr_typical_circuit_design))
                else:
                    c_typical_circuit_design.append(create_circuit_design(code, c_index, c_amount, for_curr_typical_circuit_design_part_1, for_curr_typical_circuit_design))
                pdmo(c_typical_circuit_design)

                pdmo(curr_curr_result)
                c_result.append(curr_curr_result)

                pdmo(venti_engine_pv)
                if not SHKVAL:
                    c_automation_devices = create_automation_devices(code, c_amount, range_select(venti_engine_pv))
                    # c_automation_devices = [[
                    #     'Реле перепада для контроля работы вентилятора с комплектом монтажных изделий',
                    #     range_select(venti_engine_pv),
                    #     f'{c_amount} шт.'
                    # ]]
                pdmo(c_automation_devices)
                
                if illumi:
                    illumination_theory[code].append('освещение' in header.lower() or 'освещение' in info.lower())  # Снова освещение
                # ============================== КОНЕЦ ГЛАВЫ XVII ==============================
                return c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design

            def for_1_13(c_index:int, c_amount:int, c_result:list, c_automation_devices:list, c_typical_circuit_design:list) -> tuple[int, int, list, list, list]:
                """То же самое, что и в предыдущей функции, но только для вытяжных вентиляторов... Да, эта функция делает ровно одно - вызывает предыдущую функцию!!! Заслуженное первое место в топ-10 главных шизофренических решений в этом коде!
                
                Если серьёзно, то с какой это сделано целью? Раньше у меня была одна функция, которая работала и для кода 1.12, и для 1.13. Однако из-за переделанной структуры, где я отдельно вызывают функции фор_1_12 и фор_1_13, я не придумал, как эти случаи объединить воедино, а так как я не очень люблю решения ad hoc, то поступил так: а что мне мешает вызвать функцию, которая просто вызывает другую функцию? Совершенно верно - абсолютно ничего. 

                Args:
                    c_index (int): текущий индекс
                    c_amount (int): текущее количество
                    c_result (list): текущий результат
                    c_automation_devices (list): текущие устройства автоматики
                    c_typical_circuit_design (list): текущее типовое схемное решение

                Returns:
                    tuple[int, int, list, list, list]: c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design
                """
                # ============================== КОНЕЦ ГЛАВЫ XVII ==============================
                return for_1_12(c_index, c_amount, c_result, c_automation_devices, c_typical_circuit_design)  # Меня веселит, что описание функции в разы длиннее самой функции...

            #====================================================================================================================================================================================

            # ============================== ГЛАВА VII ==============================
            # Ну что, поехали!
            global VECTOR_NAME, THE_BACKUP_STREAM, THE_BACKUP_VENTI_UNIT, SYSTEM_NAME  # Раньше тут было бесконечное количество глобальных переменных, однако теперь они все переехали по своим функциям

            curr_index = 0  # Текущий индекс - нужен, чтобы отсортировать данные для типового схемного решения
            curr_amount = 0  # Текущее количество найденных позиций - один из самых важных параметров
            curr_result = []  # Текущие данные - самый важный параметр. В этот список заносятся все найденные позиции, после чего они объединятся в одну строчку
            curr_automation_devices = []  # Текущие приборы автоматики - иногда может так и остаться пустым
            curr_typical_circuit_design = []  # Текущее типовое схемное решение - как уже говорил, это массив кортежей с индексами и значениями

            key_words = {  # Ключевые слова, по которым будет определяться, нужный ли это блок или нет. Важное замечание - ключевые слова могут быть либо в заголовке блока, либо в тексте блока. Ключи для 1.1, 1.2, 1.14 - 1.16 не применяются, потому удалены
                "1.3" : "клапан" if not IS_OBPROM else "стам",  # Чуть ли не единственный случай, когда ключевое слово обычно находится в теле блока (в веросах уж точно), а не в его заголовке. И снова один из немногих случаев, когда будут задействованы общепромки
                "1.4" : "фильтр ",  # Обычно оно в заголовке. Пробел обязателен, так как обычное обозначение тут "фильтр панельный", а бывают ещё упоминания про "ФИЛЬТРацию", что приводило к ошибке
                "1.5" : "нагрев",  # В идеале здесь должен быть "воздухонагреватель жидкостный", однако есть случаи, когда оно записано как "нагрев(вода)" или типа того
                "1.6" : "воздухонагреватель",  # Так как тут имеется в виду несколько видов нагревателей, то я вынужден использовать более общий термин. Да, неизбежно будет здесь заход и в жидкостные воздухонагреватели, но это не такая уж и проблема
                "1.7" : "нагрев",  # В идеале здесь должен быть "воздухонагреватель электрический", однако есть случаи, когда оно записано как "нагрев(эл)" или типа того
                "1.8" : "воздухоохладитель канальный " if IS_CHANAL else "воздухоохладитель жидкостный",  # Обычно оно в заголовке
                "1.9" : "воздухоохладитель непосредственного",  # Обычно оно в заголовке
                "1.10" : "теплоутилизатор",  # Обычно оно в заголовке
                "1.11" : "камера увлажнения",  # Обычно оно в заголовке
                "1.12" : "вентилятор" if not IS_OBPROM and not IS_INDUST else ALL_MAIN_INFO[0][0].lower(),  # Итак, в Веросах хотелось бы использовать ключ "вентилятор вск", но не во всех веросовских бланках это соблюдается. В канальном будет просто "вентилятор", а вот из-за того, как я прописал мой модуль, то в бланках общепрома в заголовке будет само обозначение вентилятора, так что я решил это реализовать так
                "1.13" : "вентилятор" if not IS_OBPROM and not IS_INDUST else ALL_MAIN_INFO[0][0].lower(),  # Итак, в Веросах хотелось бы использовать ключ "вентилятор вск", но не во всех веросовских бланках это соблюдается. В канальном будет просто "вентилятор", а вот из-за того, как я прописал мой модуль, то в бланках общепрома в заголовке будет само обозначение вентилятора, так что я решил это реализовать так
            }
            pdmo(code)

            for header, info in ALL_MAIN_INFO:  # Нам нужно раз за разом прогнать бланк, без малого одиннадцать раз
                if header == 'Дополнительное оборудование':  # Костыль, который работает, если у нас канальное оборудование - я там оставил этот пункт на случай, если оттуда нам что-то понадобится
                    continue
                curr_contentum = CODES_WITH_CODES[code]  # Как и в прошлый раз, нам нужно сократить длину адреса
                curr_code_for_blank = for_blank_with_codes[code]  # Тот самый словарь, где данные вносятся отчасти вручную. А могут и не вноситься
                curr_index += 1  # Логика в том, что каждый проход означает то или иное место в бланке
                if isinstance(info, list):  # Из-за того, как происходит забор данных в моём модуле, ещё остались случаи, когда данные сохранятся как список, а не как строка. И раз уж инфрмация в виде списка...
                    info = '; '.join(info)  # то мы просто объединяем, используя делиметр точку с запятой с пробелом
                pdmo(header, info)  # Проверяем, что вообще вывелось, а то мало ли.

                if key_words[code] in header.lower() or key_words[code] in info.lower():  # Итак, если мы что-то нашли, то мои поздравления - это лишь начало работы. Возможно, это не тот блок, что мы ищем
                    curr_amount += 1  # Но мы увеличиваем количество найденного на один в любом случае. Отнять единицу всегда успеем.
                    curr_index, curr_amount, curr_result, curr_automation_devices, curr_typical_circuit_design = eval(f"for_{code.replace('.', '_')}(curr_index, curr_amount, curr_result, curr_automation_devices, curr_typical_circuit_design)")  # А теперь узрите кусок кода, который занимает почётное второе место в топ-10 главных шизофренических решений в этом коде! Итак, нам нужно предусмотреть все возможные случаи, так как для каждого случая будет что-то особенное, своё, необычное и непостижимое. О каждом из этих случаев будет рассказано внутри функций, содеращейся в тематической главе. Каждая функция работает для определённого кода, и теперь они названы однотипно: фор_номер_кода. Меня заебало раз 10-11 писать одно и то же, поэтому я вызов функции (!!!) загнал внутрь эвала!!! И просто меняю название вызываемой функции!!! И это работает!!! Эта шизофрения работает!!!
                    pdmo(code, curr_index, curr_amount, curr_result, curr_automation_devices, curr_typical_circuit_design)
                    # ============================== КОНЕЦ ГЛАВЫ VII ==============================

            # ============================== ГЛАВА XVIII ==============================
            # После того, как закончился обрабатывать тот или иной ключ, требуется повторая обработка. Связано это с некоторыми особенностями того, как нужно записывать данные. В первую очередь нужно разобраться с вентиляторами, потому что на данный момент программа ещё не успела разобраться, где какой вентилятор, и найденный результат для 1.12 и 1.13 абсолютно идентичен друг другу
            if 'вытяжка' in THE_STREAM.lower() or (SYSTEM_NAME[0] == 'В'):  # В первую очередь в этой обработке надо понять, а есть ли вытяжной поток, потому что от его наличия очень многое зависит. Вытяжной поток либо прописан в потоке, либо же в названии одна из заглавных букв - В. Да, сейчас это условие выглядит не совсем так, но второе условие нужно скорее как страховка
                match code:  # В случае с вытяжным потоком надо кое-что изменять не только в вентиляторах
                    case '1.4':  # В фильтрах нужно переименовать последний вытяжной фильтр. Почему нельзя это было сделать внутри изначального цикла? Мы не знаем, когда закончатся клапаны, поэтому для всех клапанов по умолчанию пишется в типовом схемном решении, будто они все на притоке. Но последний должен быть на вытяжке
                        pdmo(curr_typical_circuit_design)
                        if curr_typical_circuit_design:  # Проверяем, есть ли вообще у нас клапаны, а если они есть, то массив не будет пустым
                            curr_typical_circuit_design[-1][1] = f'Ф{len(curr_typical_circuit_design)}в' if 'v' in curr_result[-1] else curr_typical_circuit_design[-1][1]  # И переименовываем последний клапан
                        pdmo(curr_typical_circuit_design)
                    case '1.12':  # А теперь начинается самое важное - обработка вентиляторов. По умолчанию считается, что при наличии вытяжного потока все вентиляторы, кроме последнего, будут приточными. Обычно всё равно в установках только два вентилятора максимум (и то в случаях, когда у нас приточно-вытяжная установка), так что это нестрашно
                        curr_result = curr_result[:-1]  # Так что удаляем из результата последнее найденное
                        curr_automation_devices = curr_automation_devices[:-1]  # И из автоматики
                        curr_amount = len(curr_result) - 1 if THE_BACKUP_STREAM else len(curr_result)  # В случае наличия резервного вентилятора резервные вентиляторы учитывать не надо, а так как программа заочно считает сверху плюс один вентилятор, то надо от него избавиться. А количество вентиляторов, очевидно, теперь составлет длину нового массива
                        illumination_theory[code] = illumination_theory[code][:-1]  # Тут тоже учитывается лишний вентилятор
                        curr_typical_circuit_design = curr_typical_circuit_design[:-1]  # И тут тоже
                    case '1.13':  # Раз у нас есть вытяжной поток, то вытяжным вентилятором считается последний найденны, так что...
                        curr_result = curr_result[-1:]  # ...отсекаем все вентиляторы, кроме последнего
                        curr_automation_devices = curr_automation_devices[-1:]  # И тут отсекаем
                        curr_amount = len(curr_result) - 1 if THE_BACKUP_STREAM else len(curr_result)  # Аналогично схожему пункту в 1.12
                        illumination_theory[code] = illumination_theory[code][-1:]  # Аналогично
                        curr_typical_circuit_design = curr_typical_circuit_design[-1:]  # Аналогично
            else:  # Если у нас нет вытяжного потока, то всё относительно легко - все найденные вентиляторы становятся приточными. Почему считается, что если только вытяжной поток, то первый вентилятор всё ещё приточный?.. Я не знаю
                match code:
                    case '1.12':  # Тут всё просто - переименовываем обозначения в типовом схемном решении
                        if THE_BACKUP_STREAM:  # Почему мы вычитаем один из количества освещения в случае наличия резервного вентилятора? Потому что в обозначении нужно указать количество уникальных блоков, требующих освещения. Странно, согласен
                            illumination_theory[code] = illumination_theory[code][:-1]
                    case '1.13':  # А если у нас только приток, то ничего вытяжного по определению быть не может, поэтому все переменные, которые нужно обнулить, обнуляются
                        curr_result = []
                        curr_automation_devices = []
                        curr_amount = 0
                        illumination_theory[code] = []
                        curr_typical_circuit_design = []

            if THE_BACKUP_VENTI_UNIT and code in [f'1.{i}' for i in range (3, 14)]:  # Ещё большие проблемы начинаются в случае, если у нас резервная установка. К этому моменту программа насчитала по две копии одних и тех же комплектующих, а так как для бланка нужно указать лишь один раз экземпляры, то нужно ополовинить все созданные массивы, содержащие информацию
                pdmo(curr_automation_devices, curr_result, curr_amount, curr_typical_circuit_design)
                if code == '1.4':  # Правда с фильтрами проблема - там-то обозначение формата "№p + v", так что нужно ополовинить оба типа клапанов... в теории
                    res = list(re.findall(r'(\d{0,})(.+)', curr_result[0], re.IGNORECASE)[0])  # Выделяем отдельно числа и отдельно обозначение По итогу получается список из двух кортежей, один из них будет ('либо пустота, либо число', 'p'), второй, если не пустой, всегда будет ('', 'v'). Поэтому мы...
                    res[0] = int(res[0]) if res[0] else 1  # ...определяем, сколько у нас приточных фильтров
                    pdmo(res)
                    curr_result[0] = f"{res[0] // 2 + res[0] % 2 if res[0] > 2 else ''}{res[1]}"  # Чтобы записать новое число, которое будет половиной от предыдущего, если оно больше двух. Логика в чём? Если у нас три приточных клапана, то половина от них будет считаться двумя - так надо. А вытяжные фильтры оставляем без изменений
                
                curr_result = half_the_list(curr_result)  # А теперь мы используем функцию, которая объявлена только в случае наличия резервной установки - тот самый обрубатель половины массивов. Используем его на всём, где хоть что-то может задвоиться
                curr_amount = curr_amount // 2 + curr_amount % 2  # Количество тупо делим так
                curr_typical_circuit_design = half_the_list(curr_typical_circuit_design)  # Обрубаем
                VECTOR_NAME['нагревателя'] = half_the_list(VECTOR_NAME['нагревателя'])  # Обрубаем
                VECTOR_NAME['охладителя'] = half_the_list(VECTOR_NAME['охладителя'] )  # Обрубаем
                pdmo(curr_automation_devices, curr_result, curr_amount, curr_typical_circuit_design, VECTOR_NAME)

            curr_result = INNER_DELIMITER.join(curr_result).replace('.', ',') if curr_result != [] else '0'  # Самая важная строчка. К этому моменту у нас существует список из всех найденных элемнетов по данному коду, элементов может быть не один, так что мы объединяем, заменяем все точки на запятые (а точки появляются лишь как обозначение дробной части) и заменяем переменную с листа на строчку. А если массив пустой, то записываем ноль - так надо
            pdmo(curr_automation_devices, curr_result, curr_amount, curr_typical_circuit_design)  # Напоследок проверяем, что нам программа выкинула
            return curr_automation_devices, curr_result, curr_amount, curr_typical_circuit_design  # И передаём четыре переменные (об этом сказано в шапке функции)
            # Мои поздравления, мы закончили обрабатывать каждый из пунктов! Но это только начало, мы ещё даже не добрались до того, чтобы эти результаты хоть куда-то записать Но функция на этом подошла к своему логическому завершению. Дальнейшее повествование продолжится в функции "криейт_олл_нью_контент"
            # ============================== КОНЕЦ ГЛАВЫ XVIII ==============================

        # =====================================================================================================================================================================================
        # ============================== ГЛАВА V ==============================
        # Общая логика тут проста: у нас есть шестнадцать кодов, надо по каждому из кодов по индивидуальному алгоритму что-то сделать, а потом полученные результаты вернуть в главную функцию
        global SHLANG_DATA, ENGINE_DATA, CODES_WITH_CODES, illumination_theory, THE_BACKUP_STREAM, THE_BACKUP_VENTI_UNIT, all_venti_indexes, all_switching_indexes, all_distances, INNER_DELIMITER, SHKVAL  # Снова раздел с разнообразными глобальными переменным. Как я уже сетовал, иногда фнутренние функции, почему-то, не видят переменные, объявленные в функции выше. Надеюсь, однажды я смогу понять причины этого

        all_results = {}  # Все результаты будут занесены в словарь, где ключами будет как раз номер пункта формата "1.Х", где Х от 1 до 16, а содержимым - содержимое
        all_amounts = {}  # Часто важно ещё отследить, сколько элементов той или иной категории, поэтому есть этот словарь, где те же ключи, что и в предыдущем пункте, а содержимым будет количество позиций
        all_automation_devices = []  # Приборы автоматики, которые заносятся во вторую табличку. По итогу этой функции это будет массив массивов, двухмерная табличка, если можно так выразиться
        typical_circuit_design = []  # Схемное решение нужно в обоих бланках, но оно несколько отличается по оформлению, но незначительно. Схемное решение тоже кодируется, но по другим правилам, и тут будет представлять собой тоже двухмерную таблицу, где первый "столбец" - это порядковый индекса, а второй - само обозначение решения
        
        
        # Дальше начинается довольно интересное место. итак, как уже было сказано, бывают случаи, когда есть резервный поток в установке. Однако это может означать либо то, что у нас просто есть резервный вентилятор с блоком перехода на него, а иногда это может означать тупо резервную установку. Как отличить одно от другого? 
        all_venti_indexes = [i for i in range(len(ALL_MAIN_INFO)) if ALL_MAIN_INFO[i][0].endswith('Вентилятор ВСК')]  # Как оказалось, эта строчка вообще даром не упала, но она нужна для моего шедевра в области теории графов!
        all_switching_indexes = [i for i in range(len(ALL_MAIN_INFO)) if ALL_MAIN_INFO[i][0].endswith('Блок перехода на резервный вентилятор')]  # Во-первых, должны быть блоки перехода на резервный вентилятор
        all_distances = [[switching_index_heh - venti_index_heh for switching_index_heh in all_switching_indexes] for venti_index_heh in all_venti_indexes]  # Пока нам это не важно, но потом нам нужно будет знать все расстояния от каждого вентилятора до каждого блока перехода. Пока об этом нет смысла думать. Это расстояние выссчитывалось из того предположения, что блоки перехода на резервные вентиляторы могут быть разными, однако оказалось, что они абсолютно одинаковые, что заметно упрощает жизнь
        pdmo(f'all_venti_indexes: {all_venti_indexes}', f'all_switching_indexes: {all_switching_indexes}', f'all_distances: {all_distances}')  # Выводим эту крайне (не)важную информацию
        THE_BACKUP_STREAM = 'резерв' in THE_STREAM.lower()  # Вот и появилась эта переменная. Тут мы определяем, есть ли резервный поток - об этом должно быть написано в главной информации в разделе "Поток". Если это не написано, то и нет резерва
        THE_BACKUP_VENTI_UNIT = THE_BACKUP_STREAM and not all_switching_indexes  # Резервная установка бывает в том случае, когда есть резервный поток, а блоков перехода на резервные вентиляторы - это. Это значито, что два вентилятора существуют параллельно и, что самое важное, независимо друг от друга в той или иной степени
        if THE_BACKUP_VENTI_UNIT:  # И раз у нас резервная установка...
            # pdmo("Well, we're fucked")  # ...то, во-первых, нам пизда...
            half_the_list = lambda x:x[:len(x) // 2 + len(x) % 2]  # ...а, во-вторых, объявляется функция, которая нужна только в случае наличия резервной установки. Эта функция проста в своей сути - она обрубает массив наполовину. Это нужно из-за того, что в случае резервной установки можно прописать лишь самую первую, а вторая идеально повторяет первую. Данное утверждение я принимаю на веру

        for key in (f'1.{i}' for i in range(1, 17)):  # Итак, определив кое-что перед началом, мы запускаем цикл, где пробегаемся по всем ключам. Важно отметить. что пока что результирующий словарь пуст - там даже ключей нет. Ключи создаются вот тут, но данные будут внесены в конце работы цикла
            CONTENTUM = CODES_WITH_CODES[key]  # Помните, мы из json-файла извлекали всю справочную информацию, а потом копировали, заменяя ключи на коды? Вот это нужно было для этого, чтобы сократить адрес, по которому надо обращаться в словаре

            match key:  # Матч-кейс работает быстро, хоть и выглядит громоздко и расходует на себя целый блок табуляции. Однако в нашем случае он критически важен - так как от конкретного кода зависит, что надо делать
                case '1.1':  # 1.1 - Наличие самозапуска
                    result = for_blank_with_codes[key] if for_blank_with_codes[key] else CONTENTUM['система с самозапуском']  # Система абсолютно всегда с самозапуском. Исключения вносятся руками

                case '1.2':  # 1.2 - Питание
                    result = for_blank_with_codes[key] if for_blank_with_codes[key] else CONTENTUM['питание З фазы (3P/N/PE)']  # Как мне говорили, в Веросах питание всегда трёхфазное, так что потом этот параметр может тоже определяться. Для каналок: если хоть где-то 3L, то 4, иначе 5

                case '1.14':  # 1.14 - Датчики
                    # Когда получены все возможные комплектующие, пришло время последних трёх пунктов, которые зависят от того, что вообще нашла программа. Датчики - одна из самых запутанных штук во всём комплекте автоматики. В папке с ТЗ должен лежать экселевский файл "Датчики и реле", где расписаны названия, обозначения датчиков и условиях и применения. Я об этом тут тоже расскажу, но лучше держать перед собой ту таблицу
                    if not any([all_results[k] != '0' and '3L' in all_results[k] for k in ['1.5', '1.12', '1.13']] + [all_results['1.7'] != '0' and all_results['1.7'][0] != '1']):  # Но прежде чем поговорить о датчиках, надо кое-что решить со вторым пунктом. По умолчанию там всегда трёхфазное питание, однако логика в том, что если у нас будет хотя бы одна трёхфазная херня, то и питание будет соответствующим. Однако в канальном оборудовании может быть только однофазное питание, а для него нужно другое обозначение. Этого нельзя сделать в самом ключе 1.2, потому что на тот момент вообще ничего неизвестно о бланке, поэтому данный костыль всплывает тут, в месте, где всё готово
                        pdmo(all_results)
                        all_results['1.2'] = CODES_WITH_CODES['1.2']['питание 1 фаза с нейтралью (1 P/N/PE)']
                        pdmo(all_results)
                    
                    all_sensors = for_1_14(all_results, all_amounts, THE_BACKUP_VENTI_UNIT)
                    if not SHKVAL:
                        all_automation_devices += create_automation_devices(key, 1, all_sensors)
                    pdmo(all_sensors, all_automation_devices)
                    result = INNER_DELIMITER.join(sensor for sensor in all_sensors[:-1] if sensor)  # Сохраняем результат, идём дальше

                case '1.15':  # 1.15 - Выходные линии связи
                    result = for_blank_with_codes[key] if for_blank_with_codes[key] else CONTENTUM['шина RS-485 (Modbus RTU)'] if CONTROLLER != 'нет' else CONTENTUM['отсутствует']  # Вообще-то тут, по идее, должен быть какой-то сложный выбор, однако как минимум в Веросах всегда используется только эта шина. Спорить не буду. А остальное пусто руками выбирают

                case '1.16':  # 1.16 - Дополнительные параметры
                    result = [CONTENTUM['подключение стандартного пульта ДУ']]  # Выделяется всего два типа дополнительных параметров. Первый есть всегда - и это он
                    pdmo(illumination_theory)  # А вот второй - это освещение, и с ним всё довольно просто
                    illumi_amount = sum(1 if value else 0 for values in illumination_theory.values() for value in values)  # Если у нас оно есть, то нужно написать стандартную фразу и указать их количество
                    pdmo(illumi_amount)
                    if illumi_amount > 1:
                        result.append(f"{illumi_amount}*V1L[0.05]")
                    elif illumi_amount == 1:
                        result.append("V1L[0.05]")
                    result = INNER_DELIMITER.join(result)

                case _:  # Собственно, ради чего нужны были такие сложности? До этого момента всё было легко и очевидно. Однако дальше нужно обрабатывать непосредственно сами бланки, и возникла сложность - надо было каждый раз для каждого из последующих пунктов раз за разом пробегать всю главную информацию от корки до корки, потому что клапаны, фильтры, нагреватели, охладители, увлажнители и двигатели раскиданы как бог на душу положит. Именно поэтому и есть функция "Через_всю_главную_информацию". Дальше я буду лишь объяснять, что требуется для каждого конкретного случая, а восьмая глава будет уже внутри этой самой функции.
                    automation_devices, result, amount, circuit_design = through_all_main_info(key)  # О том, что возвращает конкретно функция, сказано в самой функции. Если вкратце, создаётся четыре результирующие переменные, каждая со своим именем. Девайсы, кёркит и эмаунт заносятся в общий пул, результат - тоже, но чуть позже. Прежде чем узнать о завершении работы с бланком, прошу проследовать в ту функцию
                    # pdmo(automation_devices, result, amount, circuit_design)
                    if kip_shsau:
                        all_automation_devices += automation_devices
                    typical_circuit_design += circuit_design
                    all_amounts[key] = amount
                    # pdmo(all_results, automation_devices, typical_circuit_design, all_amounts)
                    # ============================== КОНЕЦ ГЛАВЫ V ==============================

            # ============================== ГЛАВА XIX ==============================
            pdmo(f"{key}: {result}", all_automation_devices, typical_circuit_design)  # На этом мы закончили обрабатывать бланк. Вся нужная информация нами получена, осталось лишь её проверить и сделать четыре заключительных действия. ...
            all_results[key] = result  # Во-первых - и это самое главное - внести результат в результирующий словарь

        all_automation_devices += [[  # Во-вторых - внести упоминание о шкафе приборов управления. Всё просто - либо ШКВАЛ, либо ШСАУ
            'Шкаф приборов управления автоматики',
            'ШКВАЛ' if SHKVAL else 'ШСАУ',
            '1 шт.'
        ]]

        typical_circuit_design = sorted(typical_circuit_design, key=lambda x:x[0])  # В-третьих - отсортировать массив с типовыми схемными решениями по индексам, которые мы специально за собой тащили
        # pdmo(all_results, automation_devices, typical_circuit_design, all_amounts)
        return all_results, all_automation_devices, '-'.join(sss[1] for sss in typical_circuit_design), '-'.join(''.join(s for s in takewhile(lambda sx: sx != '(', sss[1])) for sss in typical_circuit_design), all_amounts  # И, в-четвёртых, преобразовать массив типовых схемных решений в две строки. В бланк для заказчиков нужно отправлять максимально подробную информацию, а вот в бланк для завода нужно всё, что не в скобках. Тут на выручку нам приходит итертулс и его тейквайл. Раньше это делалось в теле главной функции, но... зачем, если это можно сделать здесь и сейчас, не отходя от кассы и даже не плодя новые переменные?
        # И только теперь, и только сейчас, спустя так много глав, так много действий и шагов, мы возвращаемся в тело главной функции.
        # ============================== КОНЕЦ ГЛАВЫ XIX ==============================
        pass

    # ====================================================================================================================================================================================

    def change_table_content(table, new_content:dict, change_by_row=False):
        """Процедура изменения значений в таблице шаблона. ВНИМАНИЕ: изменения в файл в этой процедуре не вносятся - они заносятся отдельной командой.

        Логика в том, что мы пробегаем всю таблицу построчно. Если содержимое ячейки является ключом из словаря, который передали извне, то тогда программа запоминает, что в следующую ячейку надо что-то внести. При этом если нам нужно изменить лишь следующую ячейку, то меняется только она, после чего программе даётся знать, что дальше изменять ничего не надо, и надо проверять является и содержимое ячейки ключом. 

        Args:
            table (_type_): Нужная таблица (тут должна быть таблица, созданная через модуль docx)
            new_content (dict): Новые значения с ключами, обозначающими, в какую ячейку нужно внести
            change_by_row (bool): если нужно изменить всю строку, то True. По умолчанию False
        """
        # ============================== ГЛАВА XXII ==============================
        activated = ''  # Эта переменная означает, какой именно ключ должен быть активирован на следующем проходе
        next_cell = False  # Эта переменная означает, что в следующую ячейку надо внести значения
        all_points = {key : False for key in new_content.keys()}  # Как я уже говорил, таблица "Тип шкафа системы автоматического управления" построчно выглядит как мешанина: 1, 8, 2, 9, ..., 7, 15, 8, 16, и поэтому нам важно знать, какие ключи уже были, а какие - нет

        for row in table.rows:
            current_cell = 0  # Если нам нужно изменить всю строку, то важно знать порядковый номер столбца, который надо изменить
            for cell in row.cells:
                cell_text = cell.text  # Просто чтобы не писать это раз за разом
                if next_cell:  # Итак, сначала мы проверяем, является ли эта ячейка следующей - той, в которую надо что-то внести? Обычно ключ находится в первой, так что мы сюда попадём в лучшем случае во второй ячейке
                    pdmo(cell_text)
                    pdmo(new_content[activated])
                    de.change_cell_applying_its_style(cell, new_content[activated][current_cell - 1] if change_by_row else new_content[activated])  # Если мы сюда попали, то нужно внести содержимое по активированному ранее (позже по тексту, ранее по логике событий) ключу, причём если мы вносим построчно, то нужно рассчитать индекс места, куда это надо внести
                    if not change_by_row:  # Если мы меняем лишь одну ячейку, то надо уже здесь дать понять, что не надо следующую ячейку надо менять
                        next_cell = False

                if cell_text in all_points and not all_points[cell_text]:  # Итак, если мы нашли один из ключей, и при этом его ещё не активировали, то...
                    # pdmo(cell_text)
                    activated = cell_text  # ...сохраняем активированный ключ, чтобы потом (выше по тексту) по этому ключу внести значения
                    all_points[cell_text] = True  # Даём понять, какой именно ключ активирован
                    next_cell = True  # Даём понять, что следующая ячейка - нужная
                current_cell += 1
            if change_by_row:  # Если меняем построчно, то даём знать, что следующую ячейку трогать не надо, только в конце строки, очевидно
                next_cell = False

        for row in table.rows[:-1]:  # А теперь надо удалить лишние строки. Лишними считаются те, где есть хотя бы одна пустая ячейка. Исключнеие - последняя строка, так как в ней должны быть пустые строки. Ни в каком случае в таблице не будет пустых значений, поэтому если есть пустая ячейка - это значит, что и вся строчка пустая
            for cell in row.cells:
                cell_text = cell.text
                if not cell_text:
                    de.remove_row(table, row)
                    break
        # ============================== КОНЕЦ ГЛАВЫ XXII ==============================
        pass

    def working_with_paragraphs(paragraphs:list, new_content:dict, file_number:int):
        """Работа с доковским файлом - отдельный вид мазохистского искусства, которым может овладеть только постигший всю неудобность, контринтуитивность и неоднозначность этого модуля. Главная логика этой процедуры проста - мы проходим каждый параграф, и ищем параграфы-заголовки разделов, а они содержат в себе "3.", "4.", "5.". После этого мы добавляем абзац, если выполняется то или иное условие. Предыдущая версия этой функции была совсем странной - изначально в каждом из шаблонов содержались все возможные варианты абзацев, а уже потом они удалялись, если условие не выполнялось. Очевидно, это противоречит человеческой логике, но это было проще реализовать на тот момент. Сейчас же я овладел искусством добавлять абзацы, поэтому всё тут теперь подчинено человеческой логике

        Args:
            paragraphs (list): список параграфов
            new_content (dict): результаты обработки файла - они могут понадобиться для удаления и/или добавления новых файлов
            file_number (int): номер бланка: первый, второй или третий
        """
        
        def adding_paragraph_with_condition(condition:bool, paragraph_text:str, count:int, previous_paragraph):
            """Добавляет параграф и обновляет счётчик, если выполняется условие

            Args:
                condition (bool): условие добавления нового параграфа
                paragraph_text (str): текст параграфа
                count (int): счётчик
                previous_paragraph (_type_): предыдущий параграф как объект

            Returns:
                _type_: count, previous_paragraph - обновлённые и изменённые счётчик и параграф
            """
            if condition:
                previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, paragraph_text, new_blank_document)
                count += 1
            return count, previous_paragraph 
        
        def vector_changing(count:int, previous_paragraph):
            """Для описания векторов нужно учитывать много параметров - сколько их всего, охладитель это или нет, есть ли резервная установка

            Args:
                count (int): номер абзаца
                previous_paragraph (_type_): предыдущий абзац в виде объекта-параграфа

            Returns:
                _type_: count, previous_paragraph - обновлённые и изменённые счётчик и параграф
            """
            # ============================== ПРИЛОЖЕНИЕ 1 К ГЛАВЕ XXIII ==============================
            ordinal_scale = {  # Русский язык - штука сложная, и ещё сложнее необходимость писать полную форму числительного в нужном падеже. Тут всё просто - порядковый номер означает нужное числительного
                0: 'первого',
                1: 'второго',
                2: 'третьего',
                3: 'четвёртого',
                4: 'пятого',
                5: 'шестого',
                6: 'седьмого',
                7: 'восьмого',
                8: 'девятого',
                9: 'десятого',
            }
            for vector_type in VECTOR_NAME:  # Именно для этого ключи в том словаре были заданы в форме родительного падежа - чтобы сам ключ можно было подставить куда-нибудь как текст
                pdmo(vector_type)
                vector_names, vector_count = VECTOR_NAME[vector_type], len(VECTOR_NAME[vector_type])  # Собственно, забираем все найденные узлы данного типа и считаем их, чтобы понять, как много их надо добавить.
                if vector_names:  # Если, конечно, эти узлы есть.
                    if vector_count > 1:  # Общий формат сообщения: "Предусмотрено подключение Х-ого водосменительного узла нагревателя/охладителя (название_системы, если есть резерв) название_вектора (проходит отдельной строкой по счёту)". Так что все эти извращения нужны, чтобы создать эту строчку. И ещё потому что тут какие-то ошибки, связанные с ф-строками, так что будет так муторно...
                        the_new_paragraph_text = f"{res_main}{count}.\tПредусмотрено подключение (проходят отдельной строкой по счёту):"
                        for i in range(vector_count):
                            the_new_paragraph_text += '\t\n\t- ' + f"{ordinal_scale[i]} водосмесительного узла {vector_type}{' ' + SYSTEM_NAME + ' ' if THE_BACKUP_VENTI_UNIT else ' '}{vector_names[i]}"
                    else:
                        the_new_paragraph_text = f"{res_main}{count}.\tПредусмотрено подключение водосмесительного узла {vector_type}{' ' + SYSTEM_NAME + ' ' if THE_BACKUP_VENTI_UNIT else ' '}{vector_names[0]} (проходит отдельной строкой по счёту)."  # Общий формат сообщения: "Предусмотрено подключение водосменительного узла нагревателя/охладителя (название_системы, если есть резерв) название_вектора (проходит отдельной строкой по счёту)"
                    pdmo(the_new_paragraph_text)
                    previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, the_new_paragraph_text, new_blank_document)  # Добавляем получившийся абзац
                    count += 1
                    if THE_BACKUP_VENTI_UNIT:  # Если есть резервная установка, надо для резервной установки прописать наличие тех же самых водосмесительных узлов
                        if vector_count > 1:  # Общий формат сообщения: "Предусмотрено подключение Х-ого водосменительного узла нагревателя/охладителя название_системы_рез название_вектора (проходит отдельной строкой по счёту)"
                            the_new_paragraph_text = f"{res_main}{count}.\tПредусмотрено подключение (проходят отдельной строкой по счёту):"
                            for i in range(vector_count):
                                the_new_paragraph_text += '\t\n\t- ' + f"{ordinal_scale[i]} водосмесительного узла {vector_type} {SYSTEM_NAME + 'р'} {vector_names[i]}"
                        else:
                            the_new_paragraph_text = f"{res_main}{count}.\tПредусмотрено подключение водосмесительного узла {vector_type} {SYSTEM_NAME + 'р'} {vector_names[0]} (проходит отдельной строкой по счёту)."  # Общий формат сообщения: "Предусмотрено подключение водосменительного узла нагревателя/охладителя (название_системы) название_вектора (проходит отдельной строкой по счёту)"
                        pdmo(the_new_paragraph_text)
                        previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, the_new_paragraph_text, new_blank_document)  # Ещё раз добавляем получившееся
                        count += 1
            # ============================== КОНЕЦ ПРИЛОЖЕНИЯ 1 К ГЛАВЕ XXIII ==============================
            return count, previous_paragraph
        
        def working_with_venti(code:str, count:int, previous_paragraph):
            """Для того, чтобы задать строчки про вентиляторов, нужно учесть ну очень многое

            Args:
                code (str): код для словаря результатов
                count (int): номер абзаца
                previous_paragraph (_type_): предыдущий абзац в виде объекта-параграфа

            Returns:
                _type_: count, previous_paragraph - обновлённые и изменённые счётчик и параграф
            """
            # ============================== ПРИЛОЖЕНИЕ 2 К ГЛАВЕ XXIII ==============================
            ventype = 'приточного' if code == '1.12' else 'вытяжного' if code == '1.13' else 'какого хрена оно тут вообще оказалось?!'  # Чтобы дважды не повторять одно и то же, нужно прямо здесь определить, к какому типу будет относиться вентилятор. Почему я вообще написал последнее условие? На всякий случай. В тексте программы такого никогда быть не должно, но всегда может что-то пойти не так
            endings_of_the_words = ['ей', 'ых', 'ей', 'ют'] if 'AD' in new_content[code] else ['я', 'ого', 'я', 'ет']  # Русский язык всё ещё сложный. Логика в том, что если двигателей несколько, то у нас будет несколько двигателЕЙ, и каждый запускается при помощи частотнЫХ преобразователЕЙ, которые устанавливаЮТся куда надо. а если один, то... Ну вы поняли. Русский язык сложный
            pdmo(new_content[code], ventype, venti_venti_amount)
            if new_content[code] != '0':  # Но все эти рассуждения не будут иметь ни малейшего смысла, если вентилятора вообще нет
                for i in range(venti_venti_amount):
                    venti_number = f" В{i + 1}{ventype[0]} " if venti_venti_amount > 1 else ' '
                    pdmo(venti_number, illumination_theory)
                    pass
                    if file_number == 2:  # Попробую объединить это в одно целое. Посмотрим, что из этого выйдет. Итак, для второго бланка у нас вот что должно быть
                    
                        if f"{CODES_WITH_CODES[code]['Резервирование']['наличие резервного вентилятора']} + " in new_content[code]:  # Я очень долго думал над тем, как бы получше прописать условия проверки, потому что у нас может быть четыре варианта развитяи событий: есть резервный вентилятора и есть частотник, есть одно из двух, есть освещение, нет ничего из этого. И для каждого случая будет своё, особое поведение, причём освещение не зависит напрямую от частотника (то есть, никак не зависит). Подумал-подумал, и понял, что важнее всего - это решить, есть ли резервный вентилятор, так как от этого факта зависит большее количество вещей
                            if CODES_WITH_CODES[code]["Тип управления двигателем"]["частотный преобразователь"]["вне шкафа"] in new_content[code] and CODES_WITH_CODES[code]['Параметры двигателя']['Питание']['однофазное питание'][-2:] not in new_content[code]:  # А уже потом смотреть, есть ли частотник. Общий формат сообщения: "Пуски двигателЯ/ЕЙ основного/резервного приточного/вытяжного вентилятора (порядковый_номер_вентилятора) предусмотрен при помощи частнОГО/ЫХ преобразователЯ/ЕЙ (устанавливаЕТ/ЮТся вне шкафа управления" Вот примерно из-за того, что отличается лишь одно слово "основного" и "резервного" я долго думал. а как его вообще добавить? Я не придумал ничего лучше, чем тупо задублировать. Я надеюсь, что удастся это как-то оптимизировать
                                previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, f"{res_main}{count}.\tПуск двигател{endings_of_the_words[0]} основного {ventype} вентилятора{venti_number}предусмотрен при помощи частотн{endings_of_the_words[1]} преобразовател{endings_of_the_words[2]} (устанавлива{endings_of_the_words[3]}ся вне шкафа управления).", new_blank_document)
                                count += 1

                                previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, f"{res_main}{count}.\tПуск двигател{endings_of_the_words[0]} резервного {ventype} вентилятора{venti_number}предусмотрен при помощи частотн{endings_of_the_words[1]} преобразовател{endings_of_the_words[2]} (устанавлива{endings_of_the_words[3]}ся вне шкафа управления).", new_blank_document)
                                count += 1

                            if any(illumination_theory[code]):  # С освещением похожая ерунда - отличие в одно слово, а так-то шаблон одинаков: "Предусмотрено электропитание освещения секции основного/резервного вентилятора (ещё тут текст)". И вот как это прописать?
                                previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, f"{res_main}{count}.\tПредусмотрено электропитание освещения секции основного {ventype} вентилятора{venti_number}(~230В, лампа накаливания 10Вт).", new_blank_document)
                                count += 1

                                previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, f"{res_main}{count}.\tПредусмотрено электропитание освещения секции резервного  {ventype} вентилятора{venti_number}(~230В, лампа накаливания 10Вт).", new_blank_document)
                                count += 1
                            previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, f"{res_main}{count}.\tПредусмотрено автоматическое включение резервного {ventype} вентилятора{venti_number}при аварии основного.", new_blank_document)  # А вот тут всё просто - это есть только если есть резервный вентилятор.
                            count += 1
                            pass
                        else:  # И ведь тексты в случае отсутствия резервных вентиляторов отличаются лишь тем, что нет упоминания про основной или резервный вентилятор, только и всего! Но это всё равно надо дважды прописать ещё раз...
                            if CODES_WITH_CODES[code]["Тип управления двигателем"]["частотный преобразователь"]["вне шкафа"] in new_content[code] and CODES_WITH_CODES[code]['Параметры двигателя']['Питание']['однофазное питание'][-2:] not in new_content[code]:
                                previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, f"{res_main}{count}.\tПуск двигател{endings_of_the_words[0]} {ventype} вентилятора{venti_number}предусмотрен при помощи частотн{endings_of_the_words[1]} преобразовател{endings_of_the_words[2]} (устанавлива{endings_of_the_words[3]}ся вне шкафа управления).", new_blank_document)
                                count += 1

                            if any(illumination_theory[code]):
                                previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, f"{res_main}{count}.\tПредусмотрено электропитание освещения секции {ventype} вентилятора{venti_number}(~230В, лампа накаливания 10Вт).", new_blank_document)
                                count += 1
                                     
                        
                        if CODES_WITH_CODES[code]['Резервирование']['наличие резервного двигателя'] in new_content[code]:  # А запись про резервный двигатель не зависит от того, резервный ли это вентилятор или нет. Как минимум, я об этом ничего не знаю
                            previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, f"{res_main}{count}.\tПредусмотрено автоматическое включение резервного двигателя {ventype} вентилятора{venti_number}при аварии основного.", new_blank_document)
                            count += 1
                    else:  # Для первого всё проще
                        if any(illumination_theory[code]):  # Всё ещё не могу придумать, как это оптимизировать и упростить, хотя мы тут делаем все те же проверки!
                            previous_paragraph = de.add_paragraph_after_paragraph(
                                previous_paragraph,
                                f"{res_main}{count}.\tПредусмотрено электропитание освещения секции{' основного ' if 'AV + ' in new_content[code] else ' '}{ventype} вентилятора{venti_number}{SYSTEM_NAME + ' ' if THE_BACKUP_VENTI_UNIT else ''}(~230В, лампа накаливания 10Вт).",  # Общий тип сообщения: "Предусмотрено электропитание освещения секции (основного, если есть резервный) приточного/вытяжного вентилятора (название_установки, если у нас резервная установка)"
                                new_blank_document)
                            count += 1

                            if THE_BACKUP_VENTI_UNIT:
                                previous_paragraph = de.add_paragraph_after_paragraph(previous_paragraph, f"{res_main}{count}.\tПредусмотрено электропитание освещения секции {ventype} вентилятора{venti_number}{SYSTEM_NAME + 'р'} (~230В, лампа накаливания 10Вт).", new_blank_document)  # Общий тии сообщения: "Предусмотрено электро питания освещения секции приточного/вытяжного вентилятора название_резервной_установки"
                                count += 1

            # ============================== КОНЕЦ ПРИЛОЖЕНИЯ 2 К ГЛАВЕ XXIII ==============================
            return count, previous_paragraph
        
        def doubled_paragraphs(count, previous_paragraph):
            """В двух бланках есть одинаковые абзацы, и чтобы дважды не писать их, все эти повторяющиеся абзацы будут теперь находиться в этом месте

            Args:
                count (int): номер абзаца
                previous_paragraph (_type_): предыдущий абзац в виде объекта-параграфа

            Returns:
                _type_: count, previous_paragraph - обновлённые и изменённые счётчик и параграф
            """
            count, previous_paragraph = adding_paragraph_with_condition(
                honeycomb_index,  # А тут этот параграф появится лишь когда вообще есть сотовый увлажнитель, и его последнее число не равно единице (что бы это ни значило)
                f"{res_main}{count}.\tПредусмотрено подключение в ШСАУ поплавкового датчика уровня ПДУ (Н.О. сухой контракт, нагрузка на контакт до 0,5 А при 180 В DC, 10 Вт) и электромагнитного вентиля (напряжение питания 1х230В). При замыкании контакта ПДУ, электромагнитный вентиль открывается, при размыкании контакта ПДУ, вентиль закрывается.", count, previous_paragraph)

            count, previous_paragraph = adding_paragraph_with_condition(
                air_preparation_unit and AMOUNT['1.7'] > 1,  # Итак, если у нас два электронагревателя, и первый из них находится в блоке подготовки воздуха, то нужен этот абзац
                f"{res_main}{count}.\tПредусмотрена возможность выбора работы первого нагревателя: «Включение совместно с открытием клапанов», «Включение совместно с вентилятором» (заводская настройка).", count, previous_paragraph)

            count, previous_paragraph = adding_paragraph_with_condition(
                recycling_split,  # Тут нужно проверить, если у нас два клапана, из которых один рециркуляционный, а другой - не особо
                f"{res_main}{count}.\tПредусмотрен выбор алгоритма работы камеры смешения в меню контроллера: «Температура в камере смешения контролируется автоматически путем регулирования степени открытия рециркуляционного и воздухозаборного клапанов по датчику, установленному в камере смешения»; «Степень открытия воздухозаборного и рециркуляционного клапанов задается вручную для каждого сезонного режима, датчик в камере смешения необходим только для наблюдения за показаниями».", count, previous_paragraph)

            count, previous_paragraph = adding_paragraph_with_condition(
                CODES_WITH_CODES["1.10"]["ЖТУ"]["Наличие"]["присутствует"] in new_content['1.10'],  # Всё просто - есть ЖТУ, есть этот абзац
                f"{res_main}{count}.\tПредусмотрено управление водосмесительным узлом ЖТУ по бланк-заказу {JTU_blank}.", count, previous_paragraph)
            
            # the_previous_paragraph = de.add_paragraph_after_paragraph(the_previous_paragraph, f"{res_main}{the_count}.\tНумерация клемм в шкафу предусмотрена согласно схеме внешних соединений.", new_blank_document)  # Относительно стандартная формулировка, но от которой хотят уйти. Так что, возможно, она и вовсе будет однажды удалена
            # the_count += 1
            return count, previous_paragraph

        # ====================================================================================================================================================================================
        # ============================== ГЛАВА XXIII ==============================
        global VECTOR_NAME, switching_typical_circuit_design, honeycomb_index, air_preparation_unit, THE_BACKUP_STREAM, THE_BACKUP_VENTI_UNIT, glycol_blank, recycling_split, venti_venti_amount, INNER_DELIMITER, all_drive_units, SHKVAL, FIREVENT  # Как видно, часть этих переменных объявлялась и создавалась изначально исключительно ради того, чтобы всплыть тут, а некоторые кочуют по всем функциям туда-сюда как флаги
        new_blank_document = new_blank_document_1 if file_number == 1 else new_blank_document_2  # Всё максимально прозаично, потому что мне надоело всякий раз вспоминать, когда какой нужен документ. Пусть это за меня делает программа, в самом деле

        for paragraph in paragraphs:
            if paragraph.text:  # Пустые абзацы нас не волнуют
                # pdmo(paragraph.text)
                res_main = re.findall(r'^([3456]\.)\s', paragraph.text, re.IGNORECASE)  # Раньше ещё была переменная рес_унд_майн (что расшифровывалось как "результаты под главным"), но она канула в лету за ненадобностью
                if res_main:  # Итак, если это всё-таки параграф-заголовок, то начинается веселье
                    res_main = res_main[0]  # Стандартная процедура, когда мы понижаем уровень вложенности результата файндолл
                    the_count, the_previous_paragraph = 1, paragraph  # Эти переменные служат счётчиками и сигналами. Процедуре добавления нового параграфа надо передать предыдущий параграф, чтобы после него что-то добавить. Проблема с счётчиком в том, что я так и не понял, как сделать его глобальным, потому у меня все функции его возвращают, а мне это не кажется элегантным
                    if res_main == '3.' and (file_number == 2 and not SHKVAL):  # После третьего пункта менять надо только во втором файле (и только если это не бланк шквалов). Почему не надо в первом, я не знаю, но могу предположить, что это связано с тем, что эти доптребования на заводе никто не читает                                                
                        # Сначала пусть идут две стандартные и общие формулировки, которые будут всегда. Почему я их не загнал в функцию добавления параграфа по условию? В этом нет смысла - они будут всегда, а выигрыш по строчкам кода и читаемости, как по мне, того не стоит

                        the_previous_paragraph = de.add_paragraph_after_paragraph(the_previous_paragraph, f"{res_main}{the_count}.\tПредусмотрены нормально открытые сухие контакты «Работа», «Авария» (для выдачи сигналов в диспетчерский пункт).", new_blank_document)
                        the_count += 1  # Можно задать вопрос, почему этого счётчика нет внутри функции добавления параграфа? Всё просто - я хотел сделать функцию добавления параграфа максимально общей, чтобы её можно было использовать в любой другой непонятной ситуации, а не только в этом случае
                        
                        the_previous_paragraph = de.add_paragraph_after_paragraph(the_previous_paragraph, f'{res_main}{the_count}.\tСхемотехникой ШСАУ предусмотрен самозапуск после кратковременного пропадания питания.', new_blank_document)
                        the_count += 1

                        # Дальше уже начинается вариативная часть. Отсюда и далее будет встречаться функция adding_paragraph_with_condition, которая работает по принципу: "Если выполняется переданное условие, добавить переданный же текст", всё прозаично
                        the_count, the_previous_paragraph = vector_changing(the_count, the_previous_paragraph)  # О том, какая возня с векторами, будет сказано в самой функции.

                        glycolik = new_content['1.5'].split(INNER_DELIMITER)  # Возня с векторами продолжается. Итак, как мы помним, если у нас гликоль, то у нас не формируется никакого вектора, а он задаётся где-то за его пределами. Можно спросить, а не будет ли в предыдущей строке что-то создаваться? Не будет - я же проверяю наличие или отсутствие записи о Векторе. Нет вектора - нет записи. Поэтому вполне легитимно уже здесь смотреть, будет ли упоминание чего-то гликольного. Собственно, если просто гликоль меньше 40%, он будет в векторе, а если больше...
                        for i in range(len(glycolik)):  # То нужно сначала проверить все записи...
                            pdmo(new_content['1.5'], glycolik, glycolik[i])
                            if glycolik[i] == 'Внести данные из бланка вручную':  # ...и если будет однозначная запись, указывающая на то, что должен быть особый вектор для гликоля больше 40%...
                                the_previous_paragraph = de.add_paragraph_after_paragraph(
                                    the_previous_paragraph, 
                                    f"{res_main}{the_count}.\tПредусмотрено управление водосмесительным узлом ТО{i + 1} по бланк-заказу {glycol_blank[i]}",  # ...то добавить особый абзац с указанием и порядкового номера теплообменника, и с указанием, что более важно, того номера бланка, на который надо сослаться. А список гликолей так работает, что там у нас будет то же количество значений, что и всего найденных теплообменников. Но они будут пустыми, если будет вектор. Логично же
                                    new_blank_document)
                                the_count += 1  # Почему мы тут не использовали нашу функцию добавления парагарафа по условию? Потому что она СРАЗУ пыталась сформировать абзац, игнорируя тот факт, что он не создастся, если не выполнено условие. Поэтому иногда я буду использовать функцию, а иногда - нет
                        
                        the_count, the_previous_paragraph = working_with_venti('1.12', the_count, the_previous_paragraph)  # Я вам солгал - работа с обозначением вентиляторов ещё большая задница, чем с векторами, поэтому прошу проследовать в ту функцию, мы там надолго застрянем

                        the_count, the_previous_paragraph = working_with_venti('1.13', the_count, the_previous_paragraph)  # Я вам солгал - работа с обозначением вентиляторов ещё большая задница, чем с векторами, поэтому прошу проследовать в ту функцию, мы там надолго застрянем

                        the_count, the_previous_paragraph = adding_paragraph_with_condition(  # Да, только сейчас появилась эта функция, которую я с таким апломбом ранее объявлял и рекламировал
                            venti_venti_amount > 1,
                            f"{res_main}{the_count}.\tПредусмотрена совместная работа вентиляторов установки {SYSTEM_NAME}, при аварии одного вентилятора второй вентилятор отключается", the_count, the_previous_paragraph)
                        
                        if any(CODES_WITH_CODES[code]['Резервирование']['наличие резервного вентилятора'] in new_content[code] for code in ('1.12', '1.13')):  # Почему это не было внесено в функци работы с векторами? Потому что об этом надо упомянуть лишь один раз, потому что тут важнее тот факт, что вообще есть что-то резервное вентиляторное, а его тип нас ни разу не волнует
                            if any(f"{CODES_WITH_CODES[code]['Резервирование']['наличие резервного вентилятора']} + " in new_content[code] for code in ('1.12', '1.13')):
                                switching_typical_circuit_design = re.findall(r'(\(.+\))', switching_typical_circuit_design[0][1], re.IGNORECASE)[0] if switching_typical_circuit_design else ''
                                the_previous_paragraph = de.add_paragraph_after_paragraph(the_previous_paragraph,
                                    f"{res_main}{the_count}.\tПредусмотрено управление отсечными заслонками до/после основного/резервного вентиляторов ({switching_typical_circuit_design}).",  # По идее, этот параметр всегда должен быть, если есть резерв, но на случай, если что-то пошло не так, я всегда делаю заглушку.
                                    new_blank_document)
                                the_count += 1  # Почему мы тут не использовали нашу функцию добавления парагарафа по условию? Потому что нельзя херачить регулярки внутри ф-строк
                            else:
                                the_count, the_previous_paragraph = adding_paragraph_with_condition(
                                    IS_CHANAL if IS_BLANK else False,
                                    f"{res_main}{the_count}.\tУправление отсечными заслонками до/после основного/резервного вентиляторов не предусмотрено.",
                                    the_count, the_previous_paragraph)                                
                                pass

                        the_count, the_previous_paragraph = adding_paragraph_with_condition(
                            f"{CODES_WITH_CODES['1.14']['Тип']['датчик температуры']}{CODES_WITH_CODES['1.14']['Назначение']['канальный']}" in new_content['1.14'],  # Тут всё просто - если есть этот датчик, то нужно ещё проверить, в каком он будет работать режиме
                            f"{res_main}{the_count}.\t{'Предусмотрено три режима работы приточной установки «Зима»/«Лето»/«Переходный». Переключение сезонных режимов осуществляется вручную в меню контроллера или автоматически по датчику температуры наружного воздуха. Выбор способа переключения осуществляется в меню контроллера.' if CODES_WITH_CODES['1.7']['Управление']['работа в режиме «Переходный»'] in new_content['1.7'] else 'Предусмотрено два режима работы установки «Зима/Лето». Выбор режима осуществляется вручную (в меню контроллера) или автоматически (по датчику температуры наружного воздуха).'}", the_count, the_previous_paragraph)

                        the_count, the_previous_paragraph = adding_paragraph_with_condition(
                            CODES_WITH_CODES["1.10"]["ТР"]["Наличие"]["присутствует"] in new_content['1.10'],  # Тут очевидно - нужно проверить, есть ли роторный теплоутилизатор
                            f"{res_main}{the_count}.\tПуск двигателя роторного теплоутилизатора предусмотрен при помощи частотного преобразователя (устанавливается в шкафу управления).", the_count, the_previous_paragraph)

                        for i in range(len(illumination_theory['1.4'])):
                            filter_illumi = illumination_theory['1.4'][i]
                            pdmo(filter_illumi)
                            the_count, the_previous_paragraph = adding_paragraph_with_condition(
                                filter_illumi,  # Освещение внутри вентиляторов мы уже расписали. Теперь надо расписать про фильтры. Нужно просто перечислить все фильтры (просто по порядку), так что...
                                f"{res_main}{the_count}.\tПредусмотрено электропитание освещения секции фильтра {'' if len(illumination_theory['1.4']) == 1 else 'Ф' + str(i + 1)} (~230В, лампа накаливания 10Вт).",  # Общий формат сообщение: "Предусмотрено электопитание освещения (секции фильтра) || (секций фильтров Ф1, Ф2, ..., Ф№)"
                                the_count, the_previous_paragraph)
                        
                        the_count, the_previous_paragraph = adding_paragraph_with_condition(
                            THE_BACKUP_VENTI_UNIT,  # Ну а если у нас есть резервная установка, то нужно об этом просто отдельно упомянуть
                            f"{res_main}{the_count}.\tУстановка {SYSTEM_NAME} является основной/резервной к установке {SYSTEM_NAME}р. Одна из установок работает, вторая находится в резерве. Одновременная работа двух установок невозможна. При аварии основной установки автоматически включается резервная установка. Предусмотрена возможность ручного назначения основной установки.", the_count, the_previous_paragraph)

                        the_count, the_previous_paragraph = adding_paragraph_with_condition(
                            new_content['1.2'] == CODES_WITH_CODES["1.2"]["питание 1 фаза с нейтралью (1 P/N/PE)"],  # Как я понимаю, тут нужна отдельная строчка на случай, если у нас однофазный ввод. Я это пока отслеживаю по этому параметру. Надеюсь, 
                            f"{res_main}{the_count}.\tПредусмотрено электропитание ШСАУ от однофазного ввода 1х230В, N,РЕ.", the_count, the_previous_paragraph)
                        
                        the_count, the_previous_paragraph = doubled_paragraphs(the_count, the_previous_paragraph)

                        if new_content['1.15'] != CODES_WITH_CODES["1.15"]["отсутствует"]:  # Как видите, неожиданно возникла проблема с этими шинами или как это называется? Если её нет, то и абзацев нет. А если есть...
                            communication_line, the_protocol = re.findall(r'шина (.+?) \((.+?)\)', next(key for key in CODES_WITH_CODES["1.15"].keys() if CODES_WITH_CODES["1.15"][key] == new_content['1.15']), re.IGNORECASE)[0]  # Обожаю мудрёные строчки! Тут нам нужно заполучить то, какой ключ используется для обозначения, потому что там содержится название протокола (в скобках) и линия связи (до скобок). Собственно, мы создаём генератор, где будет только один элемент, "сдвигаем" его некстом - получаем строчку, генератор исчерпан. Потом эту строчку разбиваем на две части посредством регулярного выражения и "распаковываем" в две переменные
                            # pdmo(communication_line, the_protocol)
                            the_previous_paragraph = de.add_paragraph_after_paragraph(the_previous_paragraph, f"{res_main}{the_count}.\tУправление установкой осуществляется по месту или с АСУ ТП объекта по протоколу {the_protocol} (линия связи {communication_line}). Выбор режима управления осуществляется с LCD дисплея контроллера.", new_blank_document)  # Добавляем обозначения
                            the_count += 1

                            the_count, the_previous_paragraph = adding_paragraph_with_condition(
                                new_content['1.15'] == CODES_WITH_CODES["1.15"]["шина Ethernet (Modbus ТСР/Р)"],  # Для этой специфической шини нужно такое вот указание. Без бэ
                                f"{res_main}{the_count}.\tПредусмотреть в шкафу установку МКОН преобразователя протокола ModBus фирмы ОВЕН (или аналог).", the_count, the_previous_paragraph)
                        else:
                            the_previous_paragraph = de.add_paragraph_after_paragraph(the_previous_paragraph, f"{res_main}{the_count}.\tПредусмотрено управление установкой при помощи 3-х позиционного переключателя «Вкл/Выкл/ДУ». В режиме ДУ предусмотрено подключение пульта дистанционного управления ПДУ или запуск установки при замыкании внешнего нормально открытого сухого контакта.", new_blank_document)  # Добавляем обозначения
                            the_count += 1

                    if res_main == '4.':  # Четвёртый и пятый пункты есть в первом и бланке для шквала, поэтому потребуется дополнительная проверка
                        if file_number == 1:  # В первом бланке записывается то же самое, что и в предыдущий раз про вектора. Ровно то же самое
                            the_count, the_previous_paragraph = vector_changing(the_count, the_previous_paragraph)
                        else:  # Во втором бланке нет четвёртого пункта, поэтому если не первый бланк, то это безальтернативно бланк шквалов
                            for SHKVAL_device in SHKVAL_devices:  # И в этот бланк надо вписать все те собранные нами устройства
                                the_previous_paragraph = de.add_paragraph_after_paragraph(the_previous_paragraph, f"{res_main}{the_count}.\t{SHKVAL_device}", new_blank_document)
                                the_count += 1
                                pass

                    if res_main == '5.':  # Этот пункт есть только во втором бланке, причём в Шквалах, вроде бы, оно не нужно, но никто не жаловался, поэтому пока пусть будет
                        the_count, the_previous_paragraph = working_with_venti('1.12', the_count, the_previous_paragraph)  # Надеюсь, оно будет работать...

                        the_count, the_previous_paragraph = working_with_venti('1.13', the_count, the_previous_paragraph)  # Вроде заработало, и хвала богам!

                        for i in range(len(illumination_theory['1.4'])):
                            filter_illumi = illumination_theory['1.4'][i]
                            pdmo(filter_illumi)
                            the_count, the_previous_paragraph = adding_paragraph_with_condition(
                                filter_illumi,  # аналогично предыдущему
                                f"{res_main}{the_count}.\tПредусмотрено электропитание освещения секции фильтра {'' if len(illumination_theory['1.4']) == 1 else 'Ф' + str(i + 1)} (~230В, лампа накаливания 10Вт).",  # Общий формат сообщение: "Предусмотрено электопитание освещения (секции фильтра) || (секций фильтров Ф1, Ф2, ..., Ф№)"
                                the_count, the_previous_paragraph)
                        
                        the_count, the_previous_paragraph = doubled_paragraphs(the_count, the_previous_paragraph)

                        if SHKVAL and new_content['1.7'] != '0':  # Пока остановились на том, что зона МНГ нужна всегда при шквалах и наличии электрокалориферах
                            the_previous_paragraph = de.add_paragraph_after_paragraph(the_previous_paragraph, f"{res_main}{the_count}.\tПредусмотрено включение системы при поступлении сигнала пожар и при закрытой двери в зону МГН (контроль по путевому выключателю - при закрытой двери контакт замкнут)", new_blank_document)
                            the_count += 1

                            the_previous_paragraph = de.add_paragraph_after_paragraph(the_previous_paragraph, f"{res_main}{the_count}.\tПредусмотрена регулируемая задержка по времени на запуск противодымных вентиляторов (настройка в меню контролера).", new_blank_document)
                            the_count += 1
                            pass

                    if res_main == '6.':  # Шестой пункт появляется только в Шквалах, и с ним какая-то конская залупа, потому что сюда надо вписать про СТАМы, но они нужны только если у нас ДУ-система, при этом Регина толком не смогла мне объяснять, когда они нужны. Пока что я это так понимаю - если есть указание про СТАМ, херачить СТАМ. Нет - и поебать вообще
                        stam = re.findall(r'(Монтажный стакан .+)[\.;\s]$', ALL_MAIN_INFO[-1][1], re.IGNORECASE)
                        pdmo(stam)
                        if stam:
                            the_count, the_previous_paragraph = adding_paragraph_with_condition(
                                SHKVAL_VD,  
                                f"{res_main}{the_count}.\t{stam[0]}",
                                the_count, the_previous_paragraph)
                        pass

        # И только теперь мы имеем возможность закончить работу с бланками и выйти отсюда
        # ============================== КОНЕЦ ГЛАВЫ XXIII ==============================
        pass
    
    def ShSAU_finder() -> str:
        """В этой функции идёт подбор шкафа ВЕРСА-100, ВЕРСА-200 или ВЕРСА-300. Общий принцип: ВЕРСА-100 используется только в тех случаях, когда есть только вентилятор, клапан и фильтр, причём их не больше одного. Их может не быть, но и не должно быть ничего другого, помимо них. ВЕРСА-200 и 300 может использоваться в большем количестве случаев, но об ограниченях на неё поговорим потом. Важно вот что - если у нас несколько систем в одном бланке, то для них будут одинаковые шкафы, так что нужно эту процедуру сделать только один раз, чтобы не множить сущности почём зря. И да, функция на вход ничего не берёт - нет нужды

        Returns:
            str: ShSAU_name - индекс шкафа
        """

        def the_engine_index(key:str, the_res:tuple) -> str:
            """Вычисление индекса двигателя - независимо от того, для чего двигатель, логика всегда одна и та же, как бы это ни звучало странно

            Args:
                key (str): пункт таблицы, в которой надо искать ес (практически не нужен). Примечательно, что в самой программе переменная нигде не используется, а задействуется лишь когда строку из таблицы передают в eval
                the_res (tuple): электропитание шкафа и ток, но объединённые вместе, потому что нет смысла их разделять до функции, если это можно (и нужно) делать тут!

            Returns:
                str: engine_index - итоговый индекс
            """
            Cabinet_power_supply = int(the_res[1])  # Электропитание шкафа. Можно заметить, что сама переменная и в самом деле нигде не используется... она появляется только в тексте, который импортируется из таблицы и передаётся в функцию евал.
            Fan_motor_current_A = the_res[0].replace(',', '.')  # Ток электродвигателя вентилятора. Да, он тут нужен, а в основной функции - нет.
            CELL_NEW_CONTENT  # Это просто строчка, которая говорит, что "да, этот словарь существует". Мы, по сути, объявляем в этой функции эту переменную, чтобы евал её мог найти
            for cabinet_motor_index in CABINET_MOTOR_INDEX_DATA:  # Логика в том, что в той таблице у нас есть два условия, и в зависимости от условий выбирается нужная строчка. Что за условия, можно посмотреть в каталогах
                pdmo(cabinet_motor_index)
                if eval(cabinet_motor_index[1]) and eval(cabinet_motor_index[2].replace('A', Fan_motor_current_A)):  # Данные условия представляют собой логические выражения, куда просто подставляются переменные, которые ещё и при этом нигде и никак не используются, что особенно потешно
                    engine_index = cabinet_motor_index[5]  # Забираем нужную первую часть
                    engine_index += f"{'0' * (5 - len(str(cabinet_motor_index[0])))}{cabinet_motor_index[0]}"  # Формат индекса: А3Н(Р) и пять цифр, где часть уходит на индекс, а слева пишут нули, чтобы было пять цифр. Поэтому и надо плучить сколько-то копий нулей, чтобы был индлекс нужной длины
                    pdmo(engine_index)
                    return engine_index  # Ничто не мешает просто взять и выйти отсюда, и брейк не нужен
            return ''  # Мы сюда попадём только если не нашли двигатель, а это на практике осуществляется постоянно 
        # ============================== ПРИЛОЖЕНИЕ К ГЛАВЕ XX ==============================

        if THE_BACKUP_VENTI:
            return '-'

        # Пока что надо задать ряд переменных, которые будут использоваться и в ВЕРСА-100, и в ВЕРСА-200
        pdmo(CELL_NEW_CONTENT, AMOUNT, CIRCUIT_DESIGN_LONG)
        ShSAU_System_operation_during_power_interruption = CELL_NEW_CONTENT['1.1']  # Работа системиы при прерывании питания. Просто берётся это значение
        ShSAU_supply_venti = re.findall(r'\[(.+?)\](\d)', CELL_NEW_CONTENT['1.12'], re.IGNORECASE)[0] if CELL_NEW_CONTENT['1.12'] != '0' else ('100', 0)  # Итак, в чём загвоздка? Для ВЕРСА-300 нам нужно два индекса для приточного и вытяжного вентилятора. Хорошо, мы это сделаем - найдём их. а потом по характеристикам движка найдём индексы. Но взникает две проблемы: в этом месте, пока мы ещё не определили, нужен ли нам шкаф 100, 200 или 300, мы не знаем, какие у нас есть вентиляторы и, во-вторых, какое нам использовать электропитание. Поэтому мы сначала находим параметры обоих вентиляторов. Итоговое значение - заглушки, по которым поиск двигателей однозначно провалится
        ShSAU_exhaus_venti = re.findall(r'\[(.+?)\](\d)', CELL_NEW_CONTENT['1.13'], re.IGNORECASE)[0] if CELL_NEW_CONTENT['1.13'] != '0' else ('100', 0)
        
        pdmo(ShSAU_supply_venti, ShSAU_exhaus_venti)
        ShSAU_Cabinet_power_supply = max(int(ShSAU_supply_venti[1]), int(ShSAU_exhaus_venti[1]))  # Электропитание шкафа, ещё потребуется дальше по тексту. Логика в том, что если у нас каким-то фантастическим образом на двух разных вентиляторах окажется два разных электропитания, то нужно нам будет максимальное (я уверен, что подобный вариант исключительно умозрительный, но я хочу вообще все варианты предусмотреть)
        pdmo(ShSAU_Cabinet_power_supply)
        ShSAU_Additional_equipment = 'Д1' #if else  # Дополнительная комплектация, всегда по умолчанию Д1 (хотя раньше говорили про Д2, но это им виднее, окей)
        ShSAU_Cabinet_body_material = 'М' # Материал корпуса шкафа, всегда Металл

        ShSAU_first_engine_index_supply = the_engine_index("1.12", ShSAU_supply_venti)  # Находим индексы двигателей вентилятора
        ShSAU_first_engine_index_exhaus = the_engine_index("1.13", ShSAU_exhaus_venti)  # Находим индексы двигателей вентилятора
        pdmo(ShSAU_first_engine_index_supply, ShSAU_first_engine_index_exhaus)

        ShSAU_first_engine_index = ShSAU_first_engine_index_supply if ShSAU_first_engine_index_supply > ShSAU_first_engine_index_exhaus else ShSAU_first_engine_index_exhaus  # Немного шизофрении. У нас эти два значения могут быть либо оба строками, либо одно из них будет строкой, а второе - ''. Во втором случае всё понятно - что угодно больше, чем ничего, а в первом же что за хрень творится? Всё просто - так как двигатели на вентиляторах очень похожи, то происходит (держитесь за стулья) лексиографическое сравнение строк, и, насколько я предполагаю, мы будем брать самый "большой" индекс, потому что я рождён в этом мире, потому что я свободен и продолжу двигаться вперёд, пока все комплекты автоматики не будут истреблены
        pdmo(ShSAU_first_engine_index)    

        if AMOUNT['1.3'] <= 1 and AMOUNT['1.4'] <= 1 and AMOUNT['1.12'] + AMOUNT['1.13'] <= 1 and sum(AMOUNT.values()) <= 3:  # О чём я и говорил - если у нас только клапан, фильтр, вентилятор и их не больше единицы каждого вида, то ВЕРСА-100
            pdmo(CELL_NEW_CONTENT, AMOUNT)  # Просто справочная информация
            pdmo('Тут нужна ВЕРСА 100!')  # Просто справочная информация
            VERSA_100_exist = False  # Нам нужно ещё при этом убедиться, что даже в таком случае будет ВЕРСА

            ShSAU_Fan_start_type_100 = 60 if any(CODES_WITH_CODES[code]["Тип управления двигателем"]["Управление ЕС-двигателем"]["Задатчик оборотов - внешний (либо отсутствует), к ШСАУ не подключается (подключение на клеммы двигателя)"] in CELL_NEW_CONTENT[code] for code in ('1.12', '1.13')) else 30 #if ("-h" in CELL_NEW_CONTENT["1.12"] or "-h" in CELL_NEW_CONTENT["1.13"]) else 0  # Тип пуска вентилятора. Вообще данный пункт в формате "ФХХХ", где ХХХ трёхзначное число. Однако из-за того, что последние две цифры одинаковы при разных условиях, и при этом отличаются с шагом в 30 из-за типа двигателя, то сначала нужно задать этот шаг. Почти всегда будет равен 30, так как ес-двигатель не рассматривается пока что
            pdmo(ShSAU_Fan_start_type_100)
            ShSAU_Fan_operation_differential_pressure_switch = AMOUNT['1.12'] + AMOUNT['1.13'] > 0 #if else  # Реле перепада давления работы вентилятора, есть вентилятор - есть, нет - нет.
            ShSAU_Air_valve = CELL_NEW_CONTENT['1.3'] != '0'  # Клапан воздушный, аналогично
            ShSAU_El_valve_heating = CODES_WITH_CODES["1.3"]["Обогрев клапана"]["обогрев клапана"][:2] in CELL_NEW_CONTENT['1.3']  # Электрический обогрев клапана, всё понятно
            ShSAU_Filter_differential_pressure_switch = CELL_NEW_CONTENT['1.4'] != '0'  # Реле перепада давления на фильтре, аналогично
            ShSAU_Remote_control_signals = True #if else  # Сигналы дистанционого управления, они есть всегда
            ShSAU_100_conditions = [ShSAU_Fan_operation_differential_pressure_switch, ShSAU_Air_valve, ShSAU_El_valve_heating, ShSAU_Filter_differential_pressure_switch, ShSAU_Remote_control_signals]  # Логика будет в следующем - у нас есть ряд булевых перемен, а в таблице есть набор данных из таких же булевых переменн. И нам нужно полное совпадние строк.
            pdmo(ShSAU_100_conditions)
            for function_diagram_number_data in FUNCTION_DIAGRAM_NUMBER_DATA_100:
                pdmo(function_diagram_number_data)
                if function_diagram_number_data[1:] == ShSAU_100_conditions:  # О чём и речь - если совпадут два множества, где все перменные - тру или фолс, то всё замечательно
                    # pdmo(function_diagram_number_data[0])
                    ShSAU_Fan_start_type_100 += function_diagram_number_data[0] + 100  # Выбираем нужное число, добавляем к нему сто и нужный шаг
                    VERSA_100_exist = True  # И говорим, что ВЕРСА существует... Но на этом ещё не всё
                    break
            VERSA_100_exist = False if not ShSAU_Fan_operation_differential_pressure_switch else VERSA_100_exist  # Как мне сказали автоматчики, ВЕРСы всё-таки не ставят, если нет датчика-реле перепада. Почему тогда просто не удалить нужные строки из таблицы и, соответственно, весь тот столбец и переменную? Я решил не рисковать и проверять все параметры
            pdmo(VERSA_100_exist)
            if VERSA_100_exist:  # И раз уж после всего этого у нас всё-таки выяснилось, что ВЕРСА существует, то...
                ShSAU_Fan_start_type_100 = f'Ф{ShSAU_Fan_start_type_100}'  # Задаём по-человечески формат

                ShSAU_Cabinet_power_supply = 0 if ShSAU_Cabinet_power_supply == 3 else 1  # Изменяем эту переменную, так как она должна выглядеть именно так
                ShSAU_VERSA_name = f"ШСАУ ВЕРСА 1{ShSAU_System_operation_during_power_interruption}{ShSAU_Cabinet_power_supply}-{ShSAU_Fan_start_type_100}-{ShSAU_first_engine_index}-{ShSAU_Additional_equipment}-{ShSAU_Cabinet_body_material}"  # Объединяем в единое обозначение
                pdmo(ShSAU_VERSA_name)
                return ShSAU_VERSA_name

                # Извлечение цены - эта хуйня работает, но не желает отдавать мне обратно результат!!! Я это закомментирую, чтобы программа не тратила на этот кусок кода время и силы
                # wb_VERSA = load_workbook(VERSA_calc_xlsx, data_only=False)  # Потому что открытие файла через этот модель - очень долгий процесс
                # ws_VERSA = wb_VERSA.active
                # ws_VERSA.cell(12, 4).value, ws_VERSA.cell(12, 5).value, ws_VERSA.cell(12, 7).value, ws_VERSA.cell(12, 9).value, ws_VERSA.cell(12, 11).value, ws_VERSA.cell(12, 13).value = ShSAU_System_operation_during_power_interruption, ShSAU_Cabinet_power_supply, ShSAU_Fan_start_type_100, ShSAU_first_engine_index,  ShSAU_Additional_equipment, ShSAU_Cabinet_body_material  # Логика тут следующая - тот экселевский файл находит значения по введёным от руки значениям, так что мы просто меняем содержимое тех ячеек, и экселевский файл в самом деле находит нужную цену! Но он просто не желает эту цену возвращать! Просто не хочет, и всё тут!!!
                # wb_VERSA.save(VERSA_calc_xlsx)
                # string_for_pivot[columns[6]] =   # Если вам удастся решить эту проблему, я буду очень рад
                
            else:  # Если нельзя применить ВЕСРА-100, то остаётся лишь развести руками. Нет, тут тогда не может быть варианта, чтобы был шкаф ВЕРСА-200, мы изначально же задали условие, что либо 100, либо 200 или 300. И раз тут даже не 100, то вообще ничего.
                pdmo('Подобный шкаф не применяется!')
                pdmo(ShSAU_100_conditions)
                pdmo(FILENAME, CELL_NEW_CONTENT)
                return '-'
        else:  # Итак, во всех остальных случаях пытаемся применить теперь либо 200, либо 300. Но тут есть один важный нюанс, а именно то, что тут тоже всех указанных видов оборудования должно быть не больше одного
            VERSA_200_exist, VERSA_300_exist = False, False

            ShSAU_KR_Recirculation_valve = CODES_WITH_CODES["1.3"]["Типы клапанов"]["рециркуляционный клапан"][:2] in CELL_NEW_CONTENT['1.3']  # КР Клапан рециркуляции (по воздуху). Достаточно и того, чтобы он был. Нужен и в 200, и в 300
            ShSAU_TO_Heat_excnahger = re.findall(r'\[(.+?)\](\d)', CELL_NEW_CONTENT['1.5'], re.IGNORECASE)  # ТО Жидкостный нагрев. Как видно, не является булевой переменной. Это связано с тем, что нам нужно потом проверять и то, нашлось ли что-нибудь, чтобы не множить переменные. А ещё нужно будет проверить, чтобы тут было не больше одного... Нужен и в 200, и в 300
            ShSAU_EK_Electric_heater = CELL_NEW_CONTENT['1.7'] != '0' and AMOUNT['1.7'] == 1  # ЭК Электрокалорифер (электронагреватель). Должно быть не больше одного. Нужен и в 200, и в 300
            if ShSAU_TO_Heat_excnahger:  # Для Вектора определяем индекс движка внутри. Логика такая же, как и с движком вентилятора, тем более что нахождение индекса мы уже сделали ранее (и та булевая переменная больше не существует, полагаю)
                pdmo(ShSAU_TO_Heat_excnahger)
                ShSAU_TO = ShSAU_TO_Heat_excnahger[0]  # Электропитание насоса ТО
                pdmo(ShSAU_TO)
                ShSAU_second_engine_index = the_engine_index("1.5", ShSAU_TO)
                pdmo(ShSAU_second_engine_index)
            else:
                if ShSAU_EK_Electric_heater:  # Так как по условию эти два параметра в 200 и 300 взаимоисключаемы
                    pdmo(CELL_NEW_CONTENT['1.7'])
                    EK_steps = re.findall(r'\[(.+?)\]', CELL_NEW_CONTENT['1.7'], re.IGNORECASE)[0].replace(',', '.')
                    EK_sum = eval(EK_steps)  # Комните, как у нас всё расписано как сумма? Абсолютно ничего не мешает просто это взять и просуммировать! Элегантно!
                    EK_steps = len(EK_steps.split('+'))
                    pdmo(EK_steps, EK_sum)
                    pass
                    
                    if EK_steps == 1:
                        if EK_sum <= 3:  # Всё очевидно - в зависимости от суммы подбираем нужное обозначение. Если не подходит - пустота, потому что в таком случае мы не можем сделать движок
                            ShSAU_second_engine_index = '21Э0030А'
                        elif EK_sum <= 15:
                            ShSAU_second_engine_index = '01Э0150А'
                        else:
                            ShSAU_second_engine_index = ''
                    elif EK_steps == 2:
                        if EK_sum <= 30:
                            ShSAU_second_engine_index = '02Э0300А'
                        else:
                            ShSAU_second_engine_index = ''
                    elif EK_steps == 3:
                        if EK_sum <= 45:
                            ShSAU_second_engine_index = '03Э0450А'
                        else:
                            ShSAU_second_engine_index = ''
                    elif EK_steps <= 6:
                        if EK_sum <= 90:
                            ShSAU_second_engine_index = '06Э0900А'
                        else:
                            ShSAU_second_engine_index = ''
                    else:
                        ShSAU_second_engine_index = ''
                    pdmo(ShSAU_second_engine_index)
                    pass
            ShSAU_XO_Liquid_cooling = CELL_NEW_CONTENT['1.8'] != '0' and AMOUNT['1.8'] == 1  # Жидкостное охлаждение ХО. Должно быть не больше одного. Нужен и в 200, и в 300. Для него было задумано некое условие, которое в итоге написано не было
            ShSAU_FO_Freon_cooler = CELL_NEW_CONTENT['1.9'] != '0' and AMOUNT['1.9'] == 1  # Фреоновый охладитель ФО. Должно быть не больше одного. Нужен и в 200, и в 300
            ShSAU_SU_FU_Honeycomb_Nozzle_humidifier = ('FU' in CELL_NEW_CONTENT['1.11'] or 'SU' in CELL_NEW_CONTENT['1.11']) and AMOUNT['1.11'] == 1  # Сотовый (форсуночный) увлажнитель СУ (ФУ). Должно быть не больше одного. Нужен и в 200, и в 300
            if ShSAU_SU_FU_Honeycomb_Nozzle_humidifier:  # В случае с сотовым или форсуночным мы тоже должны подобрать двигатель, как бы странно это ни звучало.
                pdmo(CELL_NEW_CONTENT['1.11'], FILENAME)
                ShSAU_SU_FU = re.findall(r'\[(.+?)\](\d)', CELL_NEW_CONTENT['1.11'], re.IGNORECASE)[0]
                ShSAU_third_engine_index = the_engine_index("1.11", ShSAU_SU_FU)
                pdmo(ShSAU_third_engine_index)
            else:  # На нет пишем много иксов
                ShSAU_third_engine_index = 'ХХХХХХХХ'
            ShSAU_PU_Steam_humidifier = 'PU' in CELL_NEW_CONTENT['1.11'] and AMOUNT['1.11'] == 1  # Паровой увлажнитель ПУ. Должно быть не больше одного. Нужен и в 200, и в 300

            ShSAU_Fv_filter_exhaust = CODES_WITH_CODES["1.4"]["на вытяжке"] in CELL_NEW_CONTENT['1.4']  # Фильтр на выходе. Нужен только для 300
            ShSAU_TP_Plate_heat_exchanger = CODES_WITH_CODES["1.10"]["ТП"]["Наличие перекрёстноточного теплоутилизатора"]["без привода обводного клапана"][:2] in CELL_NEW_CONTENT['1.10']  # Пластинчатый теплоутилизатор. Нужен только для 300
            ShSAU_TR_Rotary_heat_exchanger = CODES_WITH_CODES["1.10"]["ТР"]["Частотный преобразователь"]["внутри шкафа"][:2] in CELL_NEW_CONTENT['1.10']  # Роторный теплоутилизатор. Нужен только для 300
            ShSAU_JTU_Liquid_heat_exchanger = CODES_WITH_CODES["1.10"]["ЖТУ"]["Наличие"]["присутствует"] in CELL_NEW_CONTENT['1.10']  # Жидкостный теплоутилизатор. Нужен только для 300
            if ShSAU_TR_Rotary_heat_exchanger:
                ShSAU_fourth_engine_index = 'А3Н00040'
            elif ShSAU_JTU_Liquid_heat_exchanger:  # Вообще тут ещё должно быть условие про ЖТУ, однако загвоздка в том, что мы никак не извлекаем параметры ЖТУ, по которым можно было бы поулчить значение (которое, кстати, делалось бы ровно по той же таблице, что и все предыдущие), так что остаётся лишь и в случае с ЖТУ писать иксы
                ShSAU_fourth_engine_index = 'ЖТУХХХХХ'
            else:
                ShSAU_fourth_engine_index = 'ХХХХХХХХ'
            ShSAU_K_supply_valve = '' in CELL_NEW_CONTENT['1.3']  # Наличие клапана на входе. Нужен только для 300
            ShSAU_Kv_exhaust_valve = '' in CELL_NEW_CONTENT['1.3']  # наличие вытяжного клапана. Нужен только для 300
            ShSAU_venti_supply = bool(ShSAU_first_engine_index_supply)  # Наличие приточного вентилятора. Нужен только для 300
            ShSAU_venti_exhaus = bool(ShSAU_first_engine_index_exhaus)  # Наличие вытяжного вентилятора. Нужен только для 300

            ShSAU_Fan_start_type_200 = 5 if ShSAU_Cabinet_power_supply == 3 and any(CODES_WITH_CODES[code]["Тип управления двигателем"]["частотный преобразователь"]["в шкафу"] in CELL_NEW_CONTENT[code] or CODES_WITH_CODES[code]["Тип управления двигателем"]["частотный преобразователь"]["вне шкафа"] in CELL_NEW_CONTENT[code] for code in ('1.12', '1.13')) else 0  # Похожая схема, как и в прошлый раз
            ShSAU_Fan_start_type_300 = ShSAU_Fan_start_type_200

            ShSAU_200_conditions = [ShSAU_KR_Recirculation_valve, bool(ShSAU_TO_Heat_excnahger and len(ShSAU_TO_Heat_excnahger) == 1), ShSAU_EK_Electric_heater, ShSAU_XO_Liquid_cooling, ShSAU_FO_Freon_cooler, ShSAU_SU_FU_Honeycomb_Nozzle_humidifier, ShSAU_PU_Steam_humidifier]
            ShSAU_300_conditions = ShSAU_200_conditions + [ShSAU_Fv_filter_exhaust, ShSAU_TP_Plate_heat_exchanger, ShSAU_TR_Rotary_heat_exchanger, ShSAU_JTU_Liquid_heat_exchanger, ShSAU_K_supply_valve, ShSAU_Kv_exhaust_valve, ShSAU_venti_supply, ShSAU_venti_exhaus]
            pdmo(ShSAU_200_conditions, ShSAU_300_conditions)
            for function_diagram_number_data in FUNCTION_DIAGRAM_NUMBER_DATA_200:
                # pdmo(function_diagram_number_data)
                if function_diagram_number_data[1:] == ShSAU_200_conditions:
                    ShSAU_Fan_start_type_200 = f"Ф{function_diagram_number_data[0] + ShSAU_Fan_start_type_200}"  # Как и в прошлый раз формируем позицию, находим истинное значение, плюсуем шаг и ставим в начале букву
                    pdmo(ShSAU_Fan_start_type_200)
                    VERSA_200_exist = True
                    break

            for function_diagram_number_data in FUNCTION_DIAGRAM_NUMBER_DATA_300:
                # pdmo(function_diagram_number_data)
                if function_diagram_number_data[1:] == ShSAU_300_conditions:
                    ShSAU_Fan_start_type_300 = f"Ф{function_diagram_number_data[0] + ShSAU_Fan_start_type_300}"  # Как и в прошлый раз формируем позицию, находим истинное значение, плюсуем шаг и ставим в начале букву
                    pdmo(ShSAU_Fan_start_type_300)
                    VERSA_300_exist = True
                    break
            
            ShSAU_Cabinet_power_supply = 0 if ShSAU_Cabinet_power_supply == 3 else 1  # Аналогичная предыдущему случаю строчка
            pdmo(VERSA_200_exist, VERSA_300_exist)  # Нас волнует только то, что нашлось в таблице. Можно посмотреть по таблице, что там довольно... своеобразные условия, а именно то, что нигде не используется одновременно больше одного дополнительного параметра. То есть, если у нас есть один электрокалорифер, один жидкостный охладитель, один фреоновый охладитель, один паровой увлажнитель, то это не катит, потому что они не могут быть вместе.
            if VERSA_300_exist:  # Как я понимаю, 300 является более общей версией для 200, так что сначала буду проверять, есть ли 300, а если не подобралась 300, то тогда 200
                if ShSAU_second_engine_index:  # А теперь в чём логика? В случае с ТО второй двигатель найдётся всегда. Однако если у нас слишком большая сумма, то вектор не делается вообще. Поэтому мы и писали там пустое выражение, чтобы потом проверить его истинность
                    ShSAU_VERSA_name = f"ШСАУ ВЕРСА 3{ShSAU_System_operation_during_power_interruption}{ShSAU_Cabinet_power_supply}-{ShSAU_Fan_start_type_300}-{ShSAU_first_engine_index_supply}-{ShSAU_first_engine_index_exhaus}-{ShSAU_second_engine_index}-{ShSAU_third_engine_index}-{ShSAU_fourth_engine_index}-{ShSAU_Additional_equipment}-{ShSAU_Cabinet_body_material}"  # Соединяем
                    if AMOUNT['1.4'] > 1:  # Если у нас много фильтров, то нужно об этом упомянуть
                        ShSAU_VERSA_name += f" (количество фильтров больше одного)"
                    if ShSAU_EK_Electric_heater:  # А если у нас ещё и электронагреватель, то для него нужен ещё один шкаф, который максимально стандартный, хвала богам
                        ShSAU_VERSA_name += f", ШСАУ ВЕРСА 410-Ф001-{ShSAU_second_engine_index}-Д0-М"
                    pdmo(ShSAU_VERSA_name, FILENAME)
                    return ShSAU_VERSA_name

            elif VERSA_200_exist:
                if ShSAU_second_engine_index:  # А теперь в чём логика? В случае с ТО второй двигатель найдётся всегда. Однако если у нас слишком большая сумма, то вектор не делается вообще. Поэтому мы и писали там пустое выражение, чтобы потом проверить его истинность                
                    ShSAU_VERSA_name = f"ШСАУ ВЕРСА 2{ShSAU_System_operation_during_power_interruption}{ShSAU_Cabinet_power_supply}-{ShSAU_Fan_start_type_200}-{ShSAU_first_engine_index}-{ShSAU_second_engine_index}-{ShSAU_third_engine_index}-{ShSAU_Additional_equipment}-{ShSAU_Cabinet_body_material}"  # Соединяем
                    if AMOUNT['1.4'] > 1:  # Если у нас много фильтров, то нужно об этом упомянуть
                        ShSAU_VERSA_name += f" (количество фильтров больше одного)"
                    if ShSAU_EK_Electric_heater:  # А если у нас ещё и электронагреватель, то для него нужен ещё один шкаф, который максимально стандартный, хвала богам
                        ShSAU_VERSA_name += f", ШСАУ ВЕРСА 410-Ф001-{ShSAU_second_engine_index}-Д0-М"
                    pdmo(ShSAU_VERSA_name, FILENAME)
                    return ShSAU_VERSA_name

            else:  # Просто пишем, что нихрена не нашлось и радуемся жизни
                pdmo('Для подобных характеристик 200 и 300 не применяются!')  # Просто пишем, что нихрена не нашлось и радуемся жизни
                pdmo(ShSAU_200_conditions, ShSAU_300_conditions)  # Просто пишем, что нихрена не нашлось и радуемся жизни
                pdmo(FILENAME, CELL_NEW_CONTENT, CIRCUIT_DESIGN_LONG)  # Просто пишем, что нихрена не нашлось и радуемся жизни
                return '-'
        # ============================== КОНЕЦ ПРИЛОЖЕНИЯ К ГЛАВЕ XX ==============================
        pass

    def SHKVAL_maker() -> tuple[bool, bool, bool, bool]:
        """Задание Шквалов. Шквалы - это штука, требующая особенного подхода, особенного бланка и всего особенного. Шквал - это такой шкаф, но который используется в ДУ, ВД, ПД и ДП системах (это разное там дымоудаление)

        Returns:
            tuple[bool, bool, bool, bool]: shkval, firevent, shkval_vpd, shkval_vd
        """

        shkval_vpd, shkval_vd  = (any(s in system_name.lower() for system_name in all_system_names for s in sss) for sss in (('пд', 'дп', 'кду'), ('ду', 'дв', 'вд')))  # А тепрь начинается повесть о Шквалах. Однако нужно разделять ДУ-системы (ДымоУдаление) и ПД (поддерживающие???) системы. Поэтому у меня такой вот странный кортеж, создающий две булевые переменные
        shkval = shkval_vpd | shkval_vd  # Тут банальное логическое сложение. И если две предыдушие переменные будут не всегда нужны, эта будет критически важной
        firevent = shkval  # В почти всех Шквалах используется контроллер Файрвент... Ключевое слово - "почти всех". Поэтому в паре случаев придётся изменить эту переменную
        return shkval, firevent, shkval_vpd, shkval_vd

    def SHKVAL_finder() -> str:
        """Место, где создаётся обозначение ШКВАЛа. Само обозначение очень мудрёное, но код, который тут используется, донельзя простой, ничего сверхъестественного нет

        Returns:
            str: полное обозначение Шквала
        """

        global SHKVAL_name, venti_index, venti_engine_Ny, INNER_DELIMITER
        # pdmo(FILENAME, CELL_NEW_CONTENT)
        SHKVAL_name['f1'] = 'О1' if CELL_NEW_CONTENT['1.2'] == CODES_WITH_CODES['1.2']['питание 1 фаза с нейтралью (1 P/N/PE)'] else 'Ф'  # По не совсем понятной мне причине я решил использовать словари. Полагаю, логика в том, чтобы не плодить переменные сверх необходимого. Допускаю. Вообще про обозначение Шквалов сказано в бумажке и ещё где-то, но всё равно тут продублирую пояснения. Если у нас однофазное, пишем О1. иначе - Ф. Прожмём Ф по моим нервам
        if AMOUNT['1.12'] + AMOUNT['1.13'] > 1:  # Дальше начинается абстрактное. Обозначение Шквалов допускает множество номеров пожарной зоны. Их количество, как я понимаю, зависит от количества вентиляторов. И если их больше одного, надо вывести проверку. Но я ещё ни разу не видел сисемы для Шквала, где бы она потребовалась.
            # sg.popup('Сложная система, рекомендуется ручной ввод обозначения ШКВАЛа')
            return ''
        else:  # В остальных случаях же заполняем переменную с именем Шквала
            SHKVAL_name['f2'] = 'I'  # По умолчанию это считается первой зоной
            SHKVAL_name['f3']['f31'] = 'ВПД' if SHKVAL_VPD else 'ВД' if SHKVAL_VD else 'ВДУВ'  # Ровно для этого момента и нужны были те две переменные про системы Шквала
            # pdmo(venti_index)
            SHKVAL_name['f3']['f32'] = f"{int(venti_engine_Ny * 100):0>5}"  # Тут нужен индекс мощности вентилятора. Формально он есть в обозначении двигателя, но мне так лень его вычленять, поэтому я до чего додумался? Я просто умножаю мощность движка на сто и дописываю нули до пятизначного числа. Это я гений, согласитесь!
            SHKVAL_name['f3']['f33'] = 'Ч' if any(CODES_WITH_CODES[code]["Тип управления двигателем"]["частотный преобразователь"]["в шкафу"] in CELL_NEW_CONTENT[code] or CODES_WITH_CODES[code]["Тип управления двигателем"]["частотный преобразователь"]["вне шкафа"] in CELL_NEW_CONTENT[code] for code in ('1.12', '1.13')) else 'П'  # Знакомый код - есть частотник или нет

            klap_klap = []  # А теперь начинается мудачество. Итак, у нас может быть один клапан, ноль клапанов или дофига клапанов. Чтобы предусмотреть последний вариант, я и создаю этот список, куда занесу все получившиеся значения
            for klap in CELL_NEW_CONTENT['1.3'].split(INNER_DELIMITER):  # Как му помним, у нас в обозначении уже есть вся информация, и все нужные нам клапаны, так что просто сплитаем и начинаем разбираться
                pdmo(klap)
                if klap != '0':  # Проверка на случай, если у нас всё-таки вообще нет клапанов               
                    SHKVAL_name['f3']['f34'] = 'КЗ'  # Стандартные формулировки
                    SHKVAL_name['f3']['f35'] = 1  # Стандартные формулировки
                    SHKVAL_name['f3']['f36'] = 'Р' if klap[0] == '1' else 'М'  # Напряжение, тут не хочу комментировать, всё ясно и так
                    SHKVAL_name['f3']['f37'] = 'К(' + re.findall(r'W\[(.+?)\]', klap, re.IGNORECASE)[0] + ')' if 'W[' in klap else 'Х'  # На случай, если у нас всё-таки есть обогрев клапана
                    klap_klap.append(f"{SHKVAL_name['f3']['f34']}{SHKVAL_name['f3']['f35']}-{SHKVAL_name['f3']['f36']}-{SHKVAL_name['f3']['f37']}")  # Соединяем и добавляем в общий перечень клапанов
            klap_klap = '-' + '+'.join(klap_klap) if klap_klap else ''  # Если нет ничего,то и не пишем ничего (брух)
            pdmo(klap_klap)
            pass

            if AMOUNT['1.7']:  # Ну а если у нас есть электронагреватель, то нужно это прописать
                SHKVAL_name['f3']['f38'] = 'Э'
                SHKVAL_name['f3']['f39'] = __import__('math').ceil(sum(map(float, (x for x in re.findall(r'\[(.+?)\]', CELL_NEW_CONTENT['1.7'], re.IGNORECASE)[0].replace(',', '.').split('+')))) * 10)  # Всё-таки потребовалось сложить всё и сразу в обозначении! Получилась такая мудрёная формула. Причём ещё нужно умножить зачем-то на десять и округлить в верхнюю сторону. Мне несложно
            else:
                SHKVAL_name['f3']['f38'] = ''
                SHKVAL_name['f3']['f39'] = ''

            pdmo(all_system_names, SHKVAL_VPD, SHKVAL_VD, SHKVAL_name, klap_klap)
            pass
            return f"ШКВАЛ-Д-{SHKVAL_name['f1']}-{SHKVAL_name['f2']}({SHKVAL_name['f3']['f31']}{SHKVAL_name['f3']['f32']}{SHKVAL_name['f3']['f33']}{klap_klap}{'-' + SHKVAL_name['f3']['f38'] if SHKVAL_name['f3']['f38'] else ''}{SHKVAL_name['f3']['f39']})"
        pass

    # ====================================================================================================================================================================================
    # ============================== ГЛАВА III ==============================
    # Теперь, наконец, можно поговорить о том, как работает сама программа. В общих чертах я это рассказал в шапке, и на словах звучит очень легко, но поверьте, это настолько нелегко, что этот текст находится примерно на 2200-2300 строчке!
    global progress_bar_1, CODES_FOR_BLANK, CODES_FOR_BLANK_WITH_CODES, VECTOR_NAME, RESULT_FOLDER, PIVOT_INDEX, FUNCTION_DIAGRAM_NUMBER_DATA_100, FUNCTION_DIAGRAM_NUMBER_DATA_200, tvn_15, tvk_15, we_came_from_venti, switching_typical_circuit_design, honeycomb_index, FAST_MODE, venti_index, SYSTEM_NAME, illumination_theory, DF_RESULT, air_preparation_unit, THE_BACKUP_STREAM, glycol_blank, recycling_split, JTU_blank, tvn_15_list, KA_NUMBER_NUMBER, SHKVAL_devices, SHKVAL_name, SHKVAL, FIREVENT, final_docx_file_1, final_docx_file_2, THE_BACKUP_VENTI_UNIT, THE_BACKUP_VENTI, venti_venti_amount  # Одной из моих главных проблем в Питоне является проблема определения границы видимости переменной. Как мне подсказывает интуиция и общая логика поведения Питона, все внутренние функции должны видеть переменные, объявленные выше, однако на деле оно не всегда работает, из-за чего я, в мерах предосторожности, глобализирую абсолютно всё, что может понадобиться в том или ином виде. Разбирать конкретно каждую переменну я здесь не буду, просто нужно внимательно следить за разделом глобальных переменных

    if sum((flask_version, streamlit_version, window_version)) > 1:
        raise ValueError("Сука, ты нахуя в загловке прописал запуск через все три версии? В этом и суть переменных, что они, блядь, взаимоисключаемые! Пошёл нахуй и измени свою прогу, говна кусок")
    
    if debug_mode_on:
        if not pdmo.debug_mode_on:
            pdmo.debug_mode_tumbler()

    # ========== НАЧАЛО РАЗДЕЛА ОБЪЯВЛЕНИЯ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ ==========
    # Хоть я этот раздел так пафосно и назвал, однако здесь представлена лишь малая часть тех глобальных переменных, что была объявлена строчкой выше. Здесь лишь те переменные, которые требуют обнуления на каждом новом файле
    VECTOR_NAME = {  # В этот словарь записываются все Вектора, которые нужны в комплекте. Связано это с тем, что нагревателей может быть несколько, охладителей может быть несколько, нужно указать КАЖДЫЙ нагреватель и охладитель, и при этом их нужно будет указывать в разных местах, и поэтому надо отличать, что есть нагреватель, а что - охладитель
        'нагревателя' : [],  # Родительный падеж названия ключа связан с тем, что я название ключа использую как переменную дальше по повествованию. Но об этом позже, когда дойдёт речь
        'охладителя' : []  # Родительный падеж названия ключа связан с тем, что я название ключа использую как переменную дальше по повествованию. Но об этом позже, когда дойдёт речь
    }
    honeycomb_index = False  # Местонахождения сотового увлажнителя в бланке
    illumination_theory = {  # Очень важно отслеживать наличие или отсутствие освещения в блоке Веросы. Данное разделение возникло из-за того, что для каждого случая нужно отдельно прописать дополнительные требования
        "1.4" : [],  # Освещение бывает в фильтрах
        "1.12" : [],  # Освещение бывает в приточных вентиляторах
        "1.13" : []  # Освещение бывает в вытяжных вентиляторах
    }
    air_preparation_unit = False  # "Блок подготовки воздуха" - есть такие установки ВЕРОСА, в которых электронагреватель выполняет роль блока предварительного нагрева воздуха. В зависимости от этого меняются некоторые параметры

    tvn_15, tvk_15 = '', ''  # полная расшифровка - "температура начальная/конечная, раздел 1.5" - означает начальную и конечную температуру работы электронагревателей жидкостных (ВЕКТОР). Данные параметры нужны для кое-чего
    tvn_15_list = []  # Если жидкостных электронагревателей несколько, то нужно сохранить все информации по ним
    we_came_from_venti = False  # "Мы пришли от вентиляторов". Важное примечание - очень часто в тексте переменные, имеющие отношения к вентиляторам, содержат в себе часть "venti". Корректней было бы использовать слово "fan", однако сокращение "венти" прижилось. Данная переменная нужна на случай, если в установке есть резервный поток. О резервном потоке будет сказано много, но потом
    switching_typical_circuit_design = ''  # Данная перемена тоже играет свою роль при наличии резервного потока - отвечает за обозначение клапанов в блоках перехода на резервный вентилятор. Раскрытие подробностей будет потом

    THE_BACKUP_STREAM = False  # Речь в этой переменной идёт как раз о наличии резервного потока - либо он есть, либо его нет
    THE_BACKUP_VENTI = False
    glycol_blank = []  # Эта переменная будет заполнять номер бланка-заказа на случай, если гликоля больше 40%, а если нет, то заполнит пустоту
    recycling_split = []  # Эта переменная будет заполнена, если у нас будет подозрение на рециркуляционный клапан
    JTU_blank = ''  # Эта переменная будет заполнена, если у нас будет жидкостный теплоутилизатор (ЖТУ)
    SHKVAL_devices = []  # Список устройств, которые будут нужны для бланка Шквалов. О Шквалах будет подробно сказано отдельно
    SHKVAL_name = {  # Словарь для обозначения Шквала
        'f1' : '',
        'f2' : '',
        'f3' : {f'f3{i}' : '' for i in range(1, 10)},  # Третий пункт содержит в себе десять подпунктов, и для упрощения я их генерирую
        'f4' : ''
    }
    
    ALL_UNUSUAL_FILES = dict()  # Долгое время для меня проблемой было передать из первого файла во второй значения исключений, возникавших по ходу дела. Одно время эта переменная и в самом деле использовалась для необычных файлов, однако теперь её значение изменилось - теперь я тут храню вообще все сделанные файлы, которые передаю в соседний файл, если у нас стримлитовская версия. В оконной версии (которая теперь, кажется, не особо поддерживается) не задействуется
    for_unusial_files = {  # Я условно выделял три особых места, где требовалось вмешательство пользователя: указать бланки для гликолей, указать наличие или отсутствие особого электронагревателя и указать ЖТУ-бланк. Структура каждого из этих пунктов словаря проста: сначала идёт флаг, отвечающий за сам факт наличия особенности, а дальше идёт значение.
        "glycol_blank" : [False, []],
        "electric_heater" : [False, False],
        "JTU_blank" : [False, ""]
    }

    all_current_pivot_strings = pd.DataFrame(columns=PIVOT_TABLE_COLUMNS)

    # ========== КОНЕЦ РАЗДЕЛА ОБЪЯВЛЕНИЯ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ ==========

    # print(args)

    IS_BLANK = bool(FILENAME)
    if not IS_BLANK:
        # print('Итак, оно начинается')
        doc, develop, conditions, KA_NUMBER_NUMBER, filial = args[0]
        use_chachacha, kip_shsau, illumi, CONTROLLER = conditions
        CELL_NEW_CONTENT, AUTOMATION_DEVICES, CIRCUIT_DESIGN_LONG, CIRCUIT_DESIGN_SHORT, AMOUNT = args[1]
        VECTOR_NAME, illumination_theory, honeycomb_index, air_preparation_unit, recycling_split = args[2]
        OBJECT_NAME, SYSTEM_NAME, ORGANIZAION_NAME, MANAGER_NAME = args[3]

        all_system_names = vm.find_all_systems(SYSTEM_NAME)
        system_count = len(all_system_names)
        SHKVAL, FIREVENT, SHKVAL_VPD, SHKVAL_VD = SHKVAL_maker()

        THE_BACKUP_VENTI_UNIT, THE_BACKUP_VENTI = False, False
        venti_venti_amount = AMOUNT['1.12']

    else:
        if streamlit_version:
            doc, develop, conditions, KA_NUMBER_NUMBER, filial = args[0]
            use_chachacha, kip_shsau, illumi, CONTROLLER = conditions
            FAST_MODE = True
            KA_NUMBER_NUMBER = int(KA_NUMBER_NUMBER) if KA_NUMBER_NUMBER else 231967485  # Заглушка
            pass
        elif flask_version:
            FAST_MODE = True
            pass
        else:

            try:  # Я ушёл от идеи передавать просто название файла, так как надёжнее передавать док-объект - связано это с тем, что модуль вин32 не работает с Фласком, а в Стримлите создаётся файлоподобный объект, который отлично так переделывается в док-объект
                doc = Document(FILENAME)
            except (PackageNotFoundError, ValueError, BadZipFile) as err:  # Самые частые ошибки при создании файла - они очень характерные и встречаются достаточно редко, чтобы знать о них и предупреждать пользователя
                message = "Сохраните файл в docx-формате и попробуйте ещё раз!"
                if flask_version:  # На будущее я решил выплёвывать список адресов созданных бланков. Не придумал пока, как это реализовать, но пусть будет
                    return [('', '')]
                else:
                    pass
                    # sg.popup(f"{err}\n{message}")  # Я всё-таки приучу людей сохранять в докс-формате!
                return None

            print(f'НАЧИНАЕТСЯ ОБРАБОТКА БЛАНКА {FILENAME}')  # Я очень осторожно использую функцию принта, потому что это то, что будут видеть пользователи программы, а пользователи программы мало того, что толком не смотрят в то окошко, так ещё и не понимают, что там написано. Справедливости ради, я сам не понимаю, что там бывает написано, но ради того, чтобы восстановить в памяти происходящее я это и пишу. Однако мне важно давать хоть какую-то веховоую информацию, которая будет давать реперные точки работы программы
            if window_version:  # Итак, теперь у меня есть отдельная переменная, которая обозначает, в оконной ли мы форме или нет. Меня не должно волновать, откуда и как была запущена оконная форма, главное - что оно вообще запущено в оконной форме и, следовательно, переменная "прогресс_бар_1" теоретически существует. Остальное - лирика
                window, values = args

                progress_bar_1 = window['progressbar_1']  # Удобства ради создаём отдельные переменные для полосок загрузки
                develop = values['-DEVELOP-']  # В теле основной функции это будет задано иным способном, но в тестовых бланках я вставляю своё имя как заглушку, а у Руслана - его имя, которое тоже пока что заглушка.
                kip_shsau = values['kip_shsau']  # Как будет сказано в оконной форме, меня попросили добавить флажок, который определяет, будет ли добавляться всякое в таблицу приборов автоматики. Сказано - сделано
                illumi = values['illumi']   # А тут меня попросили про освещение. Не совсем понимаю, что конкретно им надо было, но я сделяль
                count_1, maxim_1 = 0, 6  # Немного поговорим о том, как именно работает один элемент из модуля ПУСимплГУИ, а именно прогресс_бар (далее - полоска загрузки). Полоске загрузки передаётся два параметра - текущий показатель и максимум, и в зависимости от него модуль отрисовывает красивую полосочку. В самой программе используется две полоски загрузки - одна для отслеживания прогресса обработки текущего бланка, а другая - для общего прогресса обработки всех бланков, т.е. сколько бланков уже сделано, а сколько ещё осталось
                progress_bar_1.update(current_count=count_1, max=maxim_1)  # Здесь задаются параметры первой полоски загрузки - текущий счётчик и максимум. Максимум, увы, нужно определять вручную, потому что то, сколько будет логических этапов обработки бланков, ведаю только я. Сейчас я выделяю восемь логических частей, так что, полагаю, столько глав тут и будет минимум.
                filial = values['-filial-']
                CONTROLLER = 'ОВЕН ПР200' if values['oven'] else 'Zentec M245' if values['zentec'] else 'нет'
            else:
                develop = 'Овчинников Александр'
                kip_shsau = True
                illumi = True
                filial = 'ОПР'
                CONTROLLER = 'ОВЕН ПР200'
            if ruslan_collab_folder:  # Итак, Руслан затеял коллаборацию - его программа теперь считает комплекты автоматики внутри самой же себя, так что для этого он импортирует мою программу и забирает оттуда только эту функцию. Подвох в том, что моя программа не совсем была к такому приспособлена, из-за чего мне пришлось несколько переписать программу. Логика в том, что Руслан закидывает бланки в свою папку, название которой он передаёт своей программе, и по этой переменной отслеживается, это программа Руслана или нет. Если она есть, то...
                RESULT_FOLDER = ruslan_collab_folder  # Папке переназначается имя, данное Русом
                develop = 'Новиков Руслан'

        
        if debug_mode_on:
            pdmo.debug_mode_tumbler()
        main_blank = vm.Blank(doc)  # неиронично самое важное, самое опасное и самое интересное место программы - то самое обращение к классу Бланков из моего модуля. Если эта строчка сработала, не вылетела с ошибкой, то могу лишь поздравить. А если оно тут вылетело... Тогда придётся лезть в мой модуль и начинать очень серьёзно его переделывать. Потому что если мы вылетели с ошибкой до этого - это проблема файла. А если вылетели тут - вероятно, что беда в моём модуле
        if debug_mode_on:
            pdmo.debug_mode_tumbler()
        main_info = main_blank.main_information  # Основной текст о классе Бланка будет в самом моём модуле, здесь же важно следующее: вся информация исторически и логически дробится на две части - главная и вся доступная. В главной информации из бланка у нас словарь, в котором ключи означают некую общую информацию об установке.
        ALL_MAIN_INFO = main_blank.ALL_MAIN_INFO  # Долгое время не было привязки между заголовком блока/моноблока и его содержимым. Но в последней версии моего модуля эта историческая несправедливость исправлена, поэтому то, как я соединяю значения, происходит в модуле, а тут просто получается двухстолбчатая табличка, где первое значение - название, а второе - содержимое. Почему не словарь, где ключ - название блока/моноблока, а содержимое - содержимое? Иногда мне требуется обращение к самому первому элементу самой первой строки - обычно там находится индекс вентилятора, если у нас не Вероса и не канальное оборудование
        pdmo(main_info)  # Выводим всю информацию, чтобы её отследить и понять, что вообще перенеслось, а что - нет
        for ami in ALL_MAIN_INFO:
            pdmo(*ami)  # Выводим всю информацию, чтобы её отследить и понять, что вообще перенеслось, а что - нет
        pass

        OBJECT_NAME = main_info['Объект']
        ORGANIZAION_NAME = main_info['Организация']
        MANAGER_NAME = main_info['Менеджер']
        pdmo(OBJECT_NAME, ORGANIZAION_NAME, MANAGER_NAME)

        IS_VEROSA, IS_OBPROM, IS_CHANAL, IS_INDUST, IS_INTEPU, IS_OTHERS = main_blank.blank_type.values()
        pdmo(IS_VEROSA, IS_OBPROM, IS_CHANAL, IS_INDUST, IS_INTEPU, IS_OTHERS)
        
        if IS_OTHERS:  # Просто предосторожность на случай, если был закинут файл нужного расширения, но не являющийся бланком, для которого готовы правила. Надеюсь, что однажды этот пункт расширится по максимуму
            message = 'Введённый бланк не является ни бланком ВЕРОСА, ни канального оборудования, ни общепромышленных вентиляторов! Программа не сможет его обработать!'
            if flask_version:
                return [('', '')]
            elif streamlit_version:
                ALL_UNUSUAL_FILES[Exception(message)] = [None, for_unusial_files]
                ALL_UNUSUAL_FILES[Exception(message)] = [None, for_unusial_files]
                return ALL_UNUSUAL_FILES, all_current_pivot_strings.drop('№', axis=1)
            else:
                if not FAST_MODE:
                    pass
                    # sg.popup(message) if not FAST_MODE else ...
                return None

        SYSTEM_NAME = main_info['Название']  # Если бы с системами всё было просто... Ох как с ними непросто!
        if SYSTEM_NAME == '-':  # Во-первых, название системы может быть тупо не написано! Обычно это в бланках канального или общепрома. Тут решение простое - система записана немного в другом месте бланка, не так, где этого ищу я.
            pdmo(*main_blank.ordered_content)
            pass
            for elem in main_blank.ordered_content:  # Поэтому надо просто ещё раз прошерстить файл (благо для этого уже есть сохранённый результат в объекте бланка) и найти все указания систем, а система обычно записана между словами "БЛАНК-ЗАКАЗ" и "от"
                pdmo(elem)
                if isinstance(elem[1], int):  # В случае таблиц...
                    elem = {re.findall(r'БЛАНК-ЗАКАЗ\s?(.+?)\s?от', cell.text, re.IGNORECASE)[0] for row in elem[0].rows for cell in row.cells if 'БЛАНК-ЗАКАЗ' in cell.text.upper()}  # Создаётся такое вот множество. Объект там обычно один, но если их будет два...
                else:  # Вообще этот кусок кода выглядит как что-то, что может наебнуться, но ничего лучше я пока не придумал для поиска по параграфам, так что похер
                    elem = re.findall(r'БЛАНК-ЗАКАЗ\s?(.+?)\s?от', elem[0], re.IGNORECASE) if 'БЛАНК-ЗАКАЗ' in elem[0].upper() else ''
                pdmo(elem)
                if elem:  # Если что-то нашлось...
                    SYSTEM_NAME = tuple(elem)[0]  # сохраняем как кортеж (у нас на элем будет либо множеством, либо списком, так что сработает) и забираем первый элемент (обычно он же единственный)
                    break  # И выходим из цикла. Дело сделано, поздравляем
            pass
        pdmo(SYSTEM_NAME)
        if IS_CHANAL or IS_OBPROM:  # А, во-вторых, в бланках канального оборудования иногда могут написать несколько одинаковых систем, чтобы сэкономить себе время. Себе-то они время экономят, но мне кто сэкономит, кроме меня самого? Поэтому в случае с канальным оборудованием надо дополнительно отслеживать, сколько систем в одном бланке. На это может указать несколько вещей. Вообще обычно номер системы выглядит как набор символов, в конце которых находится число
            all_system_names = vm.find_all_systems(SYSTEM_NAME)  # Из-за того, что этой функцией очень часто пользуется Руслан, я подумываю вынести это в отдельную функцию, чтобы потом это использовать где-то ещё. Посмотрим по ситуации. Все разъяснения по этому принципу содержатся внутри функции. Используемый там код мне прям очень нравится, я им чертовски горжусь
            pdmo(all_system_names)
            pass
        else:
            all_system_names = [SYSTEM_NAME]  # Но нам всё равно надо привести вид названий систем к списочному виду, даже если там один элемент
        pdmo(all_system_names)
        system_count = len(all_system_names)  # По итогу у нас получается список из систем, причём их количество обычно равно единице, а может и отличаться

        SHKVAL, FIREVENT, SHKVAL_VPD, SHKVAL_VD = SHKVAL_maker()
        pdmo(SHKVAL, FIREVENT, SHKVAL_VPD, SHKVAL_VD)
        pass
        
        THE_STREAM = main_info['Поток']  # Определение потока - штука сложная и муторная, но жизненно необходимая. И если в веросах обычно это указывается по умолчанию, то в канальном такого раздела тупо нет. В таком случае на помощь может прийти наличие или отсутствия букв П и В в обозначении системы - часто они называются "Пномер", "Вномер" или "ПВномер" - приток, вытяжка, приток и вытяжка соответственно
        if THE_STREAM == '-':  # И раз у нас ничего не написано тут, то попробуем хоть что-то задать
            if not IS_VEROSA:
                main_info_name = ''.join(sorted(set(re.findall(r'(П|В)', FILENAME, re.IGNORECASE)), reverse=True)) if SYSTEM_NAME not in FILENAME else ''.join(sorted(set(re.findall(r'(П|В)', SYSTEM_NAME, re.IGNORECASE)), reverse=True))
                THE_STREAM = 'приток/вытяжка' if main_info_name == 'ПВ' else 'приток' if main_info_name == 'П' else 'вытяжка' if main_info_name == 'В' else 'приток'  # Пробуем. Одним из возможных способов это определить служит как раз наличие букв.
            pdmo(THE_STREAM)
        pdmo(main_info)
        if IS_VEROSA:  # Для верос ещё надо и типоразмер определить, который требуется не только для нахождения капилляров
            verosa_type_size = re.findall(r'(ВЕРОСА)[\s-]?(\d{3})[\s-]?(\d{3})[\s-]?(\d{0,2})[\s-]?(\d{0,2})[\s-]?(У1|У3|УХЛ1|УХЛ3|Т1|Т3)[\s-]?(В)?', main_info['Типоразмер'], re.IGNORECASE)  # А этот типоразмер может быть записан максимально идиотским способом - либо через пробелы, либо через дефисы, либо слитно. От чего это зависит, я в душе не ебу, однако точно знаю следующее - нам нужно само название ВЕРОСА, первые три цифры и следующие три цифры. И ещё последний параметр - достаточно, чтобы он был (или не был). Вообще установок тут может быть несколько, но пока для упрощения буду брать самую первую
            pdmo(main_info['Типоразмер'], verosa_type_size)
            verosa_type_size = verosa_type_size[0] if verosa_type_size else ''
            if verosa_type_size and verosa_type_size[-1]:  # Оказывается, для взрывозащищённых верос надо подбор осуществлять вручную. А взрывозащита указывается в последнем пункте, который принимает значения 'В' или '', поэтому я и проверяю, истинен ли этот параметр
                message = "Для взрывозащищённой ВЕРОСА программа не осуществляет подбора! Осуществляйте это вручную!"
                if flask_version:
                    return [('', '')]
                elif streamlit_version:
                    ALL_UNUSUAL_FILES[Exception(message)] = [None, for_unusial_files]
                    ALL_UNUSUAL_FILES[Exception(message)] = [None, for_unusial_files]
                    return ALL_UNUSUAL_FILES, all_current_pivot_strings.drop('№', axis=1)
                else:
                    if not FAST_MODE:
                        pass
                        # sg.popup(message) if not FAST_MODE else ...
                    return None

        if not flask_version and not streamlit_version:
            print(f'ЗАВЕРШЕНА ОБРАБОТКА БЛАНКА {FILENAME}')  # Тут я определил конец первого логического блока - создание информации на основе исходного бланка, о чём и уведомляю пользователя. Пусть радуется.
        if window_version:
            progress_bar_1, count_1 = vm.progress_bar_updater(progress_bar_1, count_1)  # Сопровождающий текст к функции, как по мне, максимально исчерпывающий. Происходящему внутри я однозначно посвещу отдельную главу, но не сейчас. Кстати, а вы знали, что pass  - штука довольно странная и капризная? Иногда эта ерунда может работать так, что делает остановку абсолютно везде, так что если вдруг пасс делает остановку там, где делать не должен - напишите после него ещё один пасс уровнем выше, хуже не будет, правда. Код пассом не испортишь

        linear_codes_for_blank = vm.flatten_dictionary(CODES_FOR_BLANK, True)  # Как вы помните, коудс_фор_бланк нужны в случае ручного ввода параметров для бланка. Итак, для упрощения жизни конечным пользователем, ему важно знать, какие он вообще сам изменения внёс. Для этого я выравниваю словарь, избавляясь от всех подсловарей, повышая их в коренной уровень (данная функция тоже довольно подробно описана, так что здесь не вижу смысла кончать пятую главу)

        # Блок подготовки всей необходимой информации тут завершается. У нас на руках уже есть бланк, откуда выудили всю информацию, и есть некие введённые вручную параметры для бланка. Теперь пришло время забрать всю необходимую информацию!
        if streamlit_version:
            CELL_NEW_CONTENT, AUTOMATION_DEVICES, CIRCUIT_DESIGN_LONG, CIRCUIT_DESIGN_SHORT, AMOUNT = create_cell_new_content(CODES_FOR_BLANK_WITH_CODES if use_chachacha else CODES_FOR_BLANK_WITH_CODES_CLEAR)
        else:
            if not any(bool(value) for _, value in linear_codes_for_blank.items()):  # Я проверяю, пусты ли значения. Если хотя бы одно из них отлично от пустоты, то мы сюда не зайдём. Раньше я это запрещал делать, если много файлов, но я передумал.
                CELL_NEW_CONTENT, AUTOMATION_DEVICES, CIRCUIT_DESIGN_LONG, CIRCUIT_DESIGN_SHORT, AMOUNT = create_cell_new_content(CODES_FOR_BLANK_WITH_CODES)  # Раз нет каких-то предустановленных значений, то тогда мы попадаем сюда. О том, как работает эта функция - позже
            else:  # А если же есть какие-то изменения...
                selected_things = "\n".join((f"{key}: {value}" for key, value in linear_codes_for_blank.items() if value))  # ...было бы неплохо сначала узнать, что это за изменения. Для этого формирую строчку, где передаю все те изменённые изменения, а они будут отличны от пустоты.
                CELL_NEW_CONTENT, AUTOMATION_DEVICES, CIRCUIT_DESIGN_LONG, CIRCUIT_DESIGN_SHORT, AMOUNT = create_cell_new_content(CODES_FOR_BLANK_WITH_CODES if vm.popup_true_false(f'Выбранные значения:\n\n{selected_things}\n\nЗапустить создание бланков на основе бланка\n{FILENAME}\nс выбранными значениями?') else CODES_FOR_BLANK_WITH_CODES_CLEAR)  # Впрочем пользователь может пожелать не использовать эти значения. Если он захочет, то я передаю эти самые изменённые значения. Не захочет - передаём тот самый глубинно скопированный пустой словарь. Пользователь пусть сам решает, надо ли ему, чтобы абсолютно всем бланкам передались параметры, введённые вручную в программе. 
        pdmo(CELL_NEW_CONTENT, AUTOMATION_DEVICES, CIRCUIT_DESIGN_LONG, CIRCUIT_DESIGN_SHORT, AMOUNT)
        # Именно здесь начинается самое весёлое - извелечение всей необходимой информации - именно оно и занимает бесконечные строчки кода
        # ============================== КОНЕЦ ГЛАВЫ III ==============================

    # ============================== ГЛАВА XX ==============================
    # Итак, возвращаемся к главной функции. На руках у нас очень много вытащенной тем или иным образом информации, теперь осталось её просто обработать, раскидать по нужным местам.

    if not flask_version and not streamlit_version:
        print('ИНФОРМАЦИЯ В ТАБЛИЦЕ ДЛЯ ЗАВОДА', *CELL_NEW_CONTENT.items(), sep=' || ')  # Я считаю эту информацию настолько важной, что не стесняюсь выводить наружу, чтобы все это видели
        print('АВТОМАТИЧЕСКИЕ УСТРОЙСТВА', *AUTOMATION_DEVICES, sep=' || ')  # Я считаю эту информацию настолько важной, что не стесняюсь выводить наружу, чтобы все это видели
        print(f"ТИПОВОЕ СХЕМНОЕ РЕШЕНИЕ: {CIRCUIT_DESIGN_LONG}, {CIRCUIT_DESIGN_SHORT}")  # Я считаю эту информацию настолько важной, что не стесняюсь выводить наружу, чтобы все это видели

        pdmo(*VECTOR_NAME.values())
        pdmo(AMOUNT)

        print(f"ЗАВЕРШЁН АНАЛИЗ ИНФОРМАЦИИ О {'ВЕРОСЕ' if IS_VEROSA else 'КАНАЛЬНОМ ОБОРУДОВАНИИ' if IS_CHANAL else 'ВЕНТИЛЯТОРЕ' if IS_OBPROM or IS_INDUST else ''}")
    if window_version:
        progress_bar_1, count_1 = vm.progress_bar_updater(progress_bar_1, count_1)
        if system_count > 1:  # И тут у нас начинаются проблемы. Если у нас несколько систем в одном бланке, то нужно сделать для КАЖДОЙ системы бланк. Так что дальше пойдёт огромадный цикл, но в оконной форме надо это ещё отобразить визуально - изменением максимума
            progress_bar_1.update(current_count=count_1, max=maxim_1 + (system_count - 1) * 3)  # Внутри той части. что попала под цикл, находится три разных логических части, которые обновляют счётчик, поэтому надо увеличить максимум на три, умноженное на количество "лишних" систем

    
    automation_cabinet_name = SHKVAL_finder() if SHKVAL else ShSAU_finder()  # Тут надо остановиться. Шквал и Шсау взаимоисключаемы, поэтому если у нас есть шквал, то шсау быть не может, и вайс-верса. Идея в том, что если у нас несколько схем в одном бланке, то для них нужны одни и те же шкафы, поэтому для упрощения это нужно задать до начала цикла. Внедрение шквала решило проблему, почему Шсау были вынесены отдельно - для разных шкафов разные подходы.
    CONTROLLER = 'FireVent' if FIREVENT else CONTROLLER  # Всё логично, мне кажется, и дополнительные пояснения не нужны
    pdmo(automation_cabinet_name, CONTROLLER)
    pass   

    all_new_files = []  # Сюда мы будем складывать все адреса созданных бланков - их-то у нас может быть больше двух
    for system_name in all_system_names:  # Ну что, начинаем проходить по всем тем системам, что нашлись в бланке. Очевидно, если система одна, то и цикл сработает лишь единожды
        pdmo(system_name)

        TABLE_MAIN_CONTENT_1_values = [  # Скажу так - из-за особенности работы функции, заносящей значения в таблицу, мне всегда нужно ей передавать словарь. И тут я формирую словарь содержимого заголовочной таблицы. Ещё в главном теле программы мы задавали ключи для этой таблицы. Теперь пришёл черёд её заполнить
            OBJECT_NAME,  # Объект. Собственно, название объекта, взятое из бланка
            ORGANIZAION_NAME,  # Заказчик. Название организации
            '   ',  # Имейл. Не заполняется
            '   ',  # Телефон/Факс
            '   ',  # Для. Вообще не знаю, что это такое!
            system_name,  # Система
            f'{CONTROLLER} - 2 шт' if THE_BACKUP_VENTI_UNIT else CONTROLLER,  # Контроллер. Может быть совсем другим, и от него, кстати, зависит 1.15, однако если не Шквал, то нужен ОВЕН, потому что в этом разбираются только автоматчики. Однако их будет два, если у нас две резервные установки
            develop,  # Разработчик от ВЕЗА.
            '    ',  # Подпись разработчика
            MANAGER_NAME,  # Менеджер. Снова забираем из бланка
            f'{CIRCUIT_DESIGN_SHORT}\n{CIRCUIT_DESIGN_SHORT}' if THE_BACKUP_VENTI_UNIT else CIRCUIT_DESIGN_SHORT  # Типовое схемное решение - та самая выжимка, которую мы делали чуть ранее. Её нужно продублировать в случае, когда у нас резерв. Тут нужна сокращённая форма - полная потребуется позже
        ]

        TABLE_MAIN_CONTENT_1 = {key : value for key, value in zip(TABLE_MAIN_CONTENT_1_KEYS, TABLE_MAIN_CONTENT_1_values)}  # Мы объединяем всё в словарь. Я уже упоминал, что словарная форма нужна для последующей записи в бланк
        TABLE_MAIN_CONTENT_2 = {key : value for key, value in zip(TABLE_MAIN_CONTENT_2_KEYS, TABLE_MAIN_CONTENT_1_values[0:4] + ['    '] + TABLE_MAIN_CONTENT_1_values[7:10])}  # Мы объединяем всё в словарь. Я уже упоминал, что словарная форма нужна для последующей записи в бланк. Вторая таблица настолько похожа на первую, и значение в ней настолько толком ни для чего не нужно, что я даже решил отказаться от этой переменной.
        pdmo(*TABLE_MAIN_CONTENT_1.items())
        pdmo(*TABLE_MAIN_CONTENT_2.items())

        if window_version:  # В оконной форме есть три служебные таблицы, которые нужны только для того, чтобы показать пользователю, что вообще извлеклось. Для этих таблиц надо передать двухмерную матрицу, а вот как она будет заполняться - зависит от обстоятельств
            window['-table_main_content-'].update([item for item in TABLE_MAIN_CONTENT_1.items()])  # Тут у нас таблица из двух столбцов, так что можно просто передать кортежи, полученные через метод итемс. Вторую таблицу всё ещё нет смысла рисовать отдельно, она почти копия первой без каких-то серьёзных изменений
            window['-table_new_content-'].update([[f"1.{i}", CELL_NEW_CONTENT[f"1.{i}"], f"1.{i + 8}", CELL_NEW_CONTENT[f"1.{i + 8}"]] for i in range(1, 9)])  # А тут у нас таблица из четырёх столбцов, где первые два столбца - показатели от 1 до 8, а следующие два - от 9 до 16. Но заполнять их нужно построчно, так что в каждой строке записывается сразу два значения с шагом в восемь, что даёт четыре элемента в ряду: номер, значение, номер плюс восемь, значение номера плюс восемь
            window['-table_automation_devices-'].update([[f'2.{i}'] + row for i, row in enumerate(AUTOMATION_DEVICES, 1)])  # А тут мы к уже имеющейся матрице, по сути, добавляем левый столбец
            progress_bar_1, count_1 = vm.progress_bar_updater(progress_bar_1, count_1)
        if not flask_version and not streamlit_version:
            print(f'ОБНОВЛЕНИЕ ИНТЕРФЕЙСА ИНФОРМАЦИЕЙ ИЗ БЛАНКА')  # Выделять это в отдельный шаг смысла не имеет, однако если не сделать этот шаг, то не обновится оконная форма
        # ============================== КОНЕЦ ГЛАВЫ XX ==============================

        # ============================== ГЛАВА XXI ==============================
        # Здесь мы начинаем долгую процедуру по вносу всего, что можно, в два бланка - для завода и для заказчиков. Пожалуй, теперь пришло время рассказать, в чём между ними принципиальная разница. Итак, в бланке для завода есть таблица, озаглавленная как "Тип шкафа системы автоматического управления", и именно для него и формировался словарь с ключами от 1.1 до 1.16. Эта таблица есть только в бланке для завода, а остальные таблицы есть и там, и там. Заголовочную таблицу мы создали в двух экземплярах, таблица "Перечень приборов автоматики, входящих в комплект поставки" и там, и там абсолютно идентичны. Самое главное отличие будет в дополнительных требованиях и прочих описательных процедурах, которые следуют после таблиц

        if IS_BLANK:
            order_form = main_info['Бланк-заказ']
            pdmo(order_form)
            if IS_VEROSA:  # Как было обмолвлено в самой первой главе, у Верос всегда есть номер системы из 1С или как это говно называется? И если у нас вероса, то всё замечательно
                KA_number = f"КА{order_form}".replace('/', '+').replace('\\', '+').replace('\n', '')  # Стандартное название каждого из бланков состоит из такого названия. В номере системы может быть слэш (обратный или прямой (ха!)), так что я его заменяю на запятую (вообще надо бы сделать проверку на все запрещённые для названия файла символы, но в этом пока нет нужды)
            else:  # Иначе же начинаются проблемы
                if KA_NUMBER_NUMBER:  # Если стартовый номер, с которого что-то начинается, уже создан, то всё прекрасно и замечательно, париться не надо.
                    if not streamlit_version:
                        KA_NUMBER_NUMBER += 1  # Надо просто увеличить его на один, а потом записать его в название файла
                else:  # А в ином случае...
                    KA_NUMBER_NUMBER = vm.decision('Введите номер бланк-заказа, к которому будут относиться последующие бланки! Только девятизначный номер, без суффикса-обозначения подразделения!', int, 100000000, 999999999, True) if not FAST_MODE else 231967485  # Его надо задать. Я тут использую почти забытую мной функцию из моего модуля, которую специально решил переработать, доработать, улучшить и сделать универсальной (а то у меня было аж три функции, делавшие одно и то же, непорядок!). А ещё создал заглушку - это окно меня заебало
                order_form = f"{KA_NUMBER_NUMBER}-{filial}"
                KA_number = f"КА{order_form}"
        else:
            order_form = f"{KA_NUMBER_NUMBER}-{filial}"
            KA_number = f"КА{order_form}"

        KA_for_customers = system_name if '\\' not in system_name and '/' not in system_name else system_name.replace('/', '+').replace('\\', '+').replace('\n', '')  # Как просят автоматичики, в скобках набо писать не "для заказчика", а указывать номер системы или типа того. В номере системы может быть слэш (обратный или прямой (ха!)), так что я его заменяю на запятую (вообще надо бы сделать проверку на все запрещённые для названия файла символы, но в этом пока нет нужды)
        pdmo(KA_number, KA_for_customers)
        final_docx_file_1, final_docx_file_2 = (
            f"{os.getcwd()}\\тестовый (для завода).docx",
            f"{os.getcwd()}\\тестовый (для заказчика{' шквал' if SHKVAL else ''}).docx",  # обозначение для шквала нужно мне как помощь
            ) if debug_mode_on else (
            f"{RESULT_FOLDER}\\{KA_number} (для завода{' ' + KA_for_customers if system_count > 1 else ''}).docx",
            f"{RESULT_FOLDER}\\{KA_number} ({KA_for_customers}).docx")  # Если у нас тестовый прогон, то оба бланка сохраняются в папку с программой под названием "тестовый". Иначе - в табличку с готовыми бланками. Важно отметить, что номер в названии этих и последующих переменных, имеющей отношение к бланкам, означает, к какому бланку оно относится (1 - завод, 2 - заказчик). Это сыграет ключевую роль

        # Бланки формируются так - у нас есть некий шаблон, из которого мы забираем документ как объект, видоизменяем этот объект, а потом сохраняем под новым названием, подставив в шаблон нужные значения
        TEMPLATE_FILE_1 = os.path.realpath(f'{WORKING_FOLDER}\\template_1_for_two.docx') if THE_BACKUP_VENTI_UNIT else os.path.realpath(f'{WORKING_FOLDER}\\template_1_new.docx')  # Для случая, когда у нас есть резервная установка, нужно создавать отдельную таблицу для второй установки, однако так как это реализовать чисто технически очень сложно, то было принято настолько непопулярное решение, как создание дополнительного шаблона, в котором уже есть дополнительная вторая таблицу. Как мне рассказали, практически не бывает случаев с тремя установками, поэтому этого должно хватить
        TEMPLATE_FILE_2 = os.path.realpath(f'{WORKING_FOLDER}\\template_2_shkval.docx') if SHKVAL else os.path.realpath(f'{WORKING_FOLDER}\\template_2_new.docx')  # Бланки для систем со Шквалом и обычных систем очень похожи, но они взаимоисключаемые
        pdmo(TEMPLATE_FILE_1, TEMPLATE_FILE_2)

        new_blank_document_1, new_blank_document_2 = (Document(tf) for tf in (TEMPLATE_FILE_1, TEMPLATE_FILE_2))  # Дальше для сокращения ненужных повторений я буду использовать функцию exec, но здесь я её не использую. Почему? Нерационально,  мало строчек кода по итогу сократится, тем более что мне лучше всё-таки явно обозначить эти две переменные во избежания ошибок
        if THE_BACKUP_VENTI_UNIT:  # Дальше нам нужно импортировать таблицы из файла. Метод тейблс создаёт список таблицы, а дальше нужно их просто распаковать - каждую в свою переменную. А так как в случае с резервной установкой у нас появляется одна лишняя таблица, то нужно проверять, есть ли у нас резервная установка, и только потом её назначать
            table_prelude_1, table_main_1, table_type_ShSAU_1, table_type_ShSAU_backup_1, table_automation_devices_1 = new_blank_document_1.tables  # Для сохранения упорядоченности и единообразия названий переменных, таблицы с теми 16 пунктами, я тоже пронумеровал, хотя эта таблица уникальна для заводского бланка
        else:
            table_prelude_1, table_main_1, table_type_ShSAU_1, table_automation_devices_1 = new_blank_document_1.tables
        table_prelude_2, table_main_2, table_3rd_2, table_4th_2, table_automation_devices_2 = new_blank_document_2.tables  # Да, я для третьей и четвёртой таблиц так и не придумал красивого названия - это, по сути, просто две строчки, в которые нужно вписать значения, они не несут глубокого смысла. И да, в Шквале те же самые таблицы

        # Здесь я предлагаю сделать паузу и, в первую очередь, заглянуть внутрь функции "чендж_тейбл_контент", где я расписываю, как оно работает, а потом, не отходя от кассы, просмотреть "воркинг_виз_параграфс", чтобы два раза не вставать. Почему сейчас? Просто потом идёт довольно... своеобразный блок, в котором я использую несколько крайне неочевидных решений, и чтобы как-то разграничить область разумности от области эзотерического, предлагаю сделать такую паузу.
        # ============================== КОНЕЦ ГЛАВЫ XXI ==============================

        # ============================== ГЛАВА XXIV ==============================
        # Итак, дальше идёт несколько неочевидный для любого человека порядок действий, но если разобраться, то всё станет ясно. Итак, в два разных файла мне нужно внести либо что-то принципиально разное, либо что-то абсолютно одинаковое, что требует повторения одного и того же. Эту проблему я решил - экзек выручает.

        table_3rd_2_cells = table_3rd_2.rows[0].cells  # Вторая табличка (первая - это шапка с главной информацией, о ней позже) бланка для заказчиков представляет всего одну строчку. Во вторую ячейку нужно внести название системы, а в третью - развёрнутое типовое схемное решение.
        if SHKVAL:  # Правда в Шквал надо вписать всего в одну ячейку
            de.change_cell_applying_its_style(table_3rd_2_cells[1], automation_cabinet_name)  # О том, как работает конкретно этот метод, подробно описано в моём модуле. И да, именно сюда нужно вписать это обозначение
        else:
            de.change_cell_applying_its_style(table_3rd_2_cells[1], f"{system_name}\n{system_name}р" if THE_BACKUP_VENTI_UNIT else system_name) # if IS_VEROSA else f"{system_name}: {venti_index}")  # нужно дублировать, если есть резервная установка
            de.change_cell_applying_its_style(table_3rd_2_cells[2], f"{CIRCUIT_DESIGN_LONG}\n{CIRCUIT_DESIGN_LONG}р" if THE_BACKUP_VENTI_UNIT else CIRCUIT_DESIGN_LONG)  # нужно дублировать, если есть резервная установка

        table_4th_2_cells = table_4th_2.rows[0].cells  # В третьей табличке бланков для заказчиков нужно изменить всего одну ячейку - вторую
        de.change_cell_applying_its_style(table_4th_2_cells[1], f'{CONTROLLER}x2шт' if THE_BACKUP_VENTI_UNIT else CONTROLLER)

        change_table_content(table_type_ShSAU_1, CELL_NEW_CONTENT)  # Вносим в "Тип шкафа системы автоматического управления" всю информацию. Наверное, одна из самых древних частей этого кода, хех
        if THE_BACKUP_VENTI_UNIT:  # А если у нас ещё и резервная установка...
            change_table_content(table_type_ShSAU_backup_1, {key : value if key not in ('1.1', '1.2', '1.15', '1.16') else '0' for key, value in CELL_NEW_CONTENT.items()})  # ...то вносим во вторую табличку то же самое, вот только в указанных ячейках пишем нули - они уже были указаны в первый раз, и дублировать нет смысла

        for i in (1, 2):  # Как я уже говорил, у меня есть место во внесении таблиц, когда я повторяю одно и то же дважды. Я решил сократить это, используя такой цикл, где я просто меняю числа 1 и 2 в названиях переменных. И ещё в этом же цикле, чтобы два раза не вставать, я добавляю параграфы и сохраняю файлы. Уверенное третье место в топ-10 самых шизофренических решений в моём коде
            exec(f"table_prelude_{i}_cells = table_prelude_{i}.rows[0].cells")  # Итак, сначала нам нужно внести в нулевую табличку данные. Для этого мы, грубо говоря, создаём список из ячеек первой строчки (строчек-то у нас и так всего одна)
            exec(f"de.change_cell_applying_its_style(table_prelude_{i}_cells[0], order_form)")  # В одну ячейку вносим название бланк-заказа. 
            exec(f"de.change_cell_applying_its_style(table_prelude_{i}_cells[1], date.today().strftime('%d.%m.%y'))")  # А в другу вносим сегодняшнюю дату. Есть вероятность, конечно, что тут будет две разные даты, если запустить программу так, чтобы начало этого цикла началось где-то в 23:59:59, так что один бланк может быть одним днём, а второй - вторым. Но если у вас это получится... Я, мать твою, даже не знаю. Я охуею, честно
            exec(f"change_table_content(table_main_{i}, TABLE_MAIN_CONTENT_{i})")  # Дальше нужно внести в самую первую таблицу, где содержится вся основная информация, эту самую основную информацию
            exec(f"change_table_content(table_automation_devices_{i}, {{f'2.{{j}}' : value for j, value in enumerate(AUTOMATION_DEVICES, 1)}}, True)")  # Вносим комплект автоматики в таблицу для комплекта. Это будет единственная таблица, где значения надо передавать на всю строку. Таким образом, у нас будет словарь, где ключ - это первый столбец, а содержимое - список - это остальные столбцы. Почему я тут, по сути, дважды делаю одни и те же вычисления? Лень, катастрофическая лень!
            exec(f"de.change_cell_applying_its_style(table_automation_devices_{i}.rows[-1].cells[-1], str(sum(int(''.join(s for s in st[-1] if s.isdigit())) for st in AUTOMATION_DEVICES)) + ' шт.')")  # В самой последней ячейке этой таблицы надо указать, сколько всего приборов автоматики тут должно быть. Суммарное количество этих самых приборов считается оно очень легко - сумма чисел из последнего столбца, потому что в последнем столбце всё формата "№ шт". Почему я тут снова дважды делаю одни и те же вычисления? Лень, катастрофическая лень!

            exec(f"working_with_paragraphs(new_blank_document_{i}.paragraphs, CELL_NEW_CONTENT, {i})")  # С таблицами покончили, переходим к параграфам. В заголовке описано, что конкретно нужно передать - список параграфов-объектов, нужную информацию и порядковый номер бланка, так как от этого, как мы видели, многое зависит

            if not streamlit_version:
                no_permission_error = False  # Мы закончили редактировать бланк, теперь нужно сохранить изменённый документ-объект как новый файл с новым названием. Однако так как я часто забывал закрыть старый тестовый файл, то возникла эта конструкция, где я ставлю программу на паузу, чтобы закрыть программу
                while not no_permission_error:  # Всё просто - пока эта переменная не истинна, программа выплёвывает всплывающее окно до тех пор, пока я не закрою файл. Закрыл - меняет переменную
                    try:  # Собственно, это, теоретически, будет работать даже в оконной форме, но мне сложно представить ситуацию, когда придётся её там задействовать
                        if not (SHKVAL and i == 1):
                            exec(f"new_blank_document_{i}.save(final_docx_file_{i})")  # Сохраняем файлы. Раньше я копировал файл, и в новом файле что-то менял. Но, покумекав, решил, что в этом нет смысла, и теперь я забираю документ-объект из шаблона, меняю его, но сохраняю в новом файле вот здесь
                    except PermissionError:  
                        pass# Ошибка, которая нам нужна - ошибка доступа. Так что если вдруг что-то другое пойдёт не так при сохранении, то я об этом узнаю, можете не сомневаться
                        # exec(f"sg.popup(f'Программа не может сохранить файл {{final_docx_file_{i}}}, так как он сейчас открыт. Закройте его, пожалуйста')")
                    else:
                        no_permission_error = True
                no_permission_error = False  # На всякий случай переназначаю переменную, потому что в коде есть ещё одно место, где я ставлю программу на паузу, пока не закрою файл

        ALL_UNUSUAL_FILES[final_docx_file_1] = [new_blank_document_1, {"glycol_blank" : [False, []], "electric_heater" : [False, False], "JTU_blank" : [False, ""]}]
        ALL_UNUSUAL_FILES[final_docx_file_2] = [new_blank_document_2, for_unusial_files]

        if not flask_version and not streamlit_version:
            print(f'ВНЕСЕНИЕ ИНФОРМАЦИИ В ТАБЛИЦЫ БЛАНКОВ И СОХРАНЕНИЕ БЛАНКОВ')  # Раз мы оказались здесь, это значит одно - мы успешно завершаем работу с бланками. Они созданы, ура! Свершилось то, к чему мы так долго шли! Вот только программа на этом не закончилась, хотя конец уже маячит на горизонте. И теперь да, рассказываем об этом зрителю. Теперь остался последний серьёзный блок - работа со сводной таблицей
        if window_version:
            progress_bar_1, count_1 = vm.progress_bar_updater(progress_bar_1, count_1)
        # ============================== КОНЕЦ ГЛАВЫ XXIV ==============================

        # ============================== ГЛАВА XXV ==============================
        # Что должно быть представлено в сводной таблице, уже было описано раньше по тексту. Теперь надо описать, откуда что берётся
        string_for_pivot = {key : '-' for key in PIVOT_TABLE_COLUMNS}  # Для удобства поиска что куда вносить, снова создаётся словарь, где ключ - шапка таблицы, а содержимым будут найденные значения. Почему не банальный список? Были какие-то соображения, но они канули в лету

        string_for_pivot[PIVOT_TABLE_COLUMNS[0]] = PIVOT_INDEX  # Порядковый номер. Как уже говорил, даром не нужен
        string_for_pivot[PIVOT_TABLE_COLUMNS[1]] = f"{KA_number} ({system_name})"  # Ну, название КАшки, что очевидно
        string_for_pivot[PIVOT_TABLE_COLUMNS[2]] = CIRCUIT_DESIGN_LONG  # Это длинное обозначение пишется и сюда
        string_for_pivot[PIVOT_TABLE_COLUMNS[3]] = '+'.join(f"({content})" if any(c in content for c in '-+') else content for content in CELL_NEW_CONTENT.values())  # Сюда нужно соединить всё то, что мы делали для первой таблицы

        # string_for_pivot[PIVOT_TABLE_COLUMNS[4]] =   # здесь должно быть про цены, однако реинжиниринг этой ерунды слишком сложный, поэтому пока без цен, пусть цены как-то иначе делаются. Я могу довольно долго и подробно расписывать, почему в текущем виде забор цен на КА, ВЕРСы и прочую ерунду просто не работает так, как должен

        string_for_pivot[PIVOT_TABLE_COLUMNS[5]] = automation_cabinet_name  # Заносим в таблицу рассчитанное за пределами цикла название шкафа. Как я уже говорил, если у нас много систем, то нужны одинаковые версы, c'est la vie, nanodesu

        # string_for_pivot[PIVOT_TABLE_COLUMNS[6]] =   # Однажды здесь будут цены... Но потом

        string_for_pivot[PIVOT_TABLE_COLUMNS[7]], string_for_pivot[PIVOT_TABLE_COLUMNS[8]] = (', '.join(VECTOR_NAME[key]) if VECTOR_NAME[key] else '-' for key in VECTOR_NAME.keys())  # Нам ещё нужно отдельно прописать вектора охлаждения и нагрева. Есть - пишем, нет - не пишем. Генератор нужен для сокращения, упрощения и бла-бла-бла
        
        pdmo(string_for_pivot)
        all_current_pivot_strings = pd.concat([all_current_pivot_strings, pd.DataFrame([string_for_pivot.values()], columns=PIVOT_TABLE_COLUMNS)], ignore_index=True)  # Добавляем строку в датафрейм. Конкат так работает, что нужно ему передать сначала старую таблицу, а потом уже новую строчку, переведённую в датафрейм. Словомо, всё и так расписано в самой формуле
        DF_RESULT = pd.concat([DF_RESULT, all_current_pivot_strings], ignore_index=True)
        pdmo(all_current_pivot_strings, DF_RESULT)
        PIVOT_INDEX += 1  # Увеличиваем индекс (можно удалить)
        if not flask_version and not streamlit_version:
            print(f'КОНЕЦ РАБОТЫ С ТЕКУЩЕЙ СИСТЕМОЙ {system_name}')
        if window_version:
            progress_bar_1, count_1 = vm.progress_bar_updater(progress_bar_1, count_1)
        all_new_files.append((final_docx_file_1, final_docx_file_2))  # Собственно, добавляем адреса созданных файлов сюда
        
    if not multiple_files:
        vm.xlsx_file_beautifulication(FILE_PIVOT_TABLE, DF_RESULT)  # И работаем со сводной таблицей

    # ========== МЕСТО ОБНУЛЕНИЯ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ ==========
    # Хоть они и пересоздаются всякий раз, осторожность лишней не будет. По сути, тут то же самое, что и в начале, но записанное ещё раз, чтобы наверняка
    VECTOR_NAME = {
        'нагревателя' : [],
        'охладителя' : []
    }
    tvn_15, tvk_15 = '', ''
    tvn_15_list = []
    we_came_from_venti = False
    switching_typical_circuit_design = ''
    honeycomb_index = False
    illumination_theory = {
        "1.4" : [],
        "1.12" : [],
        "1.13" : []}
    air_preparation_unit = False
    THE_BACKUP_STREAM = False
    glycol_blank = []
    recycling_split = []
    JTU_blank = ''
    SHKVAL_devices = []
    SHKVAL_name = {
        'f1' : '',
        'f2' : '',
        'f3' : {f'f3{i}' : '' for i in range(1, 10)},
        'f4' : ''
    }

    if flask_version:  # На будущее я решил выплёвывать список адресов созданных бланков. Не придумал пока, как это реализовать, но пусть будет
        return [('', '')]
    elif streamlit_version:
        return ALL_UNUSUAL_FILES, all_current_pivot_strings.drop('№', axis=1)
    else:
        print(f'ВНЕСЕНИЕ ИНФОРМАЦИИ В СВОДНУЮ ТАБЛИЦУ И ОКОНЧАНИЕ РАБОТЫ С БЛАНКОМ {FILENAME}')
        if window_version:
            progress_bar_1, count_1 = vm.progress_bar_updater(progress_bar_1, count_1)
            if not multiple_files:
                pass
                # sg.popup('Бланк создан!')
        return None
    # Итак, на этом рассказ о работе программы подходит к концу. Конкретно в этом файле рассказывается исключительно об общем принципе работы. О том, как потом это реализуется в оконной форме или веб-форме рассказывается в соответствующих файлах. Здесь есть только эпилог, который вряд ли будет так уж интересен
    # ============================== КОНЕЦ ГЛАВЫ XXV ==============================
    pass

# ====================================================================================================================================================================================

def for_engine_I(poles:int, Ny:float, Uu:float) -> int:
    """Поиск силы тока по таблице двигателей. Таблица представляет собой два логических блока - в левой половине находится четыре набора столцбов на четыре разных случая полюсов, так как от полюсов многое зависит. В правой половине находятся ещё значения, которые нам пока не требуются.

    Args:
        poles (int): количество полюсов
        Ny (float): мощность, кВт
        Uu (float): напряжение, В

    Returns:
        Ii: сила тока, А. Теперь вообще не должно возвращать прочерк, правда!..
    """ 
    # ========== ДОПОЛНЕНИЕ К ГЛАВЕ XVI ==========
    for engine_data in ENGINE_DATA[2:]:
        match poles:  # В зависимости от полюса мы берём те или иные столбцы из левой части и всю правую часть, хотя она нам, если подумать, не слишком-то и нужна. Почему мы не обрубаем исходную таблицу? Исходную таблицу трогать нельзя - она-то требуется в разных местах, и полюса могут быть совершенно разными! Поэтому изменение происходит внутри самого цикла - это надёжнее. Можно было бы, конечно, в каждом заходе в функцию создавать копию исходной таблицы... но оно нам надо? Подробно останавливаться, почему берутся те или иные столбцы, не буду - посмотрите исходную таблицу, если мне не верите или есть вопросы
            case 8:  # 0-5
                engine_data = engine_data[0:6] + engine_data[24:-3]
            case 6:  # 6-11
                engine_data = engine_data[6:12] + engine_data[24:-3]
            case 4:  # 12-17
                engine_data = engine_data[12:18] + engine_data[24:-3]
            case 2:  # 18-23
                engine_data = engine_data[18:24] + engine_data[24:-3]
        if engine_data[1] == Ny:  # Нам нужно совпадение по мощности - именно в этой строчке будет искомая сила тока. Но есть один нюанс. В той таблице указано несколько производителей, и у разных производителей разные параметры силы тока, а у кого-то их и вовсе нет. Я беру первое встречное, потому что часто эта программа выдавала прочерки
            ind = 2  # Силы тока начинаются с третьего столбца
            Ii = '-'  # Пока нужен прочерк, потому что...
            while isinstance(Ii, str):  # ...программа будет работать, пока она не заберёт числовое значение (пандас автоматически конвертирует числа в числовой тип данных)
                Ii = engine_data[ind]  # Забираем значение
                ind += 1  # Сдвигаемся на столбец вправо
                if ind > 5:  # Если мы так ничего и не нашли, то выходим из вайла
                    break
            break  # Если мы нашли нужную мощность, то нужно заканчивать с циклом брейком - потому что...
    else:  # ...есть очень маленький, но шанс, что нужной мощности в таблице нет. В таком случае я максимально в лоб вычислю силу тока. Именно поэтому и нужен брейк - мы сюда попадём лишь если цикл отработал как положено
        Ii = Ny / Uu
    # ========== КОНЕЦ ДОПОЛНЕНИЯ К ГЛАВЕ XVI ==========
    return Ii

def linear_dict_change_values(nested_dicts:dict, changing_symbol:str, filled_or_not=False):
    """Вспомогательная функция, изменяющая все пустые значнеия заменены на нижнее подчёркивание

    Args:
        nested_dicts (dict): словарь со словарями
        changing_symbol (str): символ, которым надо заменить пустоту
        filled_or_not (bool): надо менять пустое значение или нет. По умолчанию ложь - меняем только пустые

    Returns:
        dict: nested_dicts, в котором все пустые значнеия заменены на нижнее подчёркивание
    """

    for key, value in nested_dicts.items():  # Я говорил, что ненавижу рекурсии? Вот теперь вы знаете, что ненавижу
        if isinstance(value, dict):  # Итак, если у нас это словарь, то...
            nested_dicts[key] = linear_dict_change_values(value, changing_symbol, filled_or_not)  # Верно, грёбаная рекурсия!
        else:  # А если не словарь, то...
            if bool(value) == filled_or_not:  # Короче, если у нас пустое значение, то...
                nested_dicts[key] = changing_symbol  # Заменяем на нужный символ
    return nested_dicts  # Всё, к чёрту, пошли отсюда

def the_meaning(code:str, values:dict) -> str:
    """Функция, формирующая обозначение для поля бланка КА по номеру поля и переданному как словарь значению

    Args:
        code (str): Номер поля
        values (dict): Значения для текущего поля

    Returns:
        str: new_value - строковый вид поля
    """
    match code:  # Да, снова всё зависит от того, какой у нас ключ.
        case '1.1' | '1.2' | '1.4' | '1.15' | '1.16':
            new_value = values
        case '1.3':
            part_1 = f"{values['Питание привода']}{values['Управление приводом']}{values['Типы клапанов']}"
            part_2 = f"-{values['Обогрев клапана']}" if values['Обогрев клапана'] != '-' else ''
            part_3 = f"-{values['Дополнительные параметры']}" if values['Дополнительные параметры'] != '-' else ''
            new_value = part_1 + part_2 + part_3
        case '1.5':
            pump_part = f"{values['Насос']['Питание']}-{values['Насос']['Опции']}-" if values['Насос']['Питание'] and values['Насос']['Опции'] else ''
            new_value = f"{pump_part}{values['Регулирующий кран']['Питание']}{values['Регулирующий кран']['Управление']}-{values['Дополнительные параметры']['Дополнительные параметры']}"
        case '1.6':
            po_part = f"{values['ПО']['Наличие']}{values['ПО']['Питание привода']}{values['ПО']['Управление приводом']}-{values['ПО']['Дополнительные параметры']}" if values['ПО']['Наличие'] != '-' else ''
            gn_part = f"{values['ГН']['Наличие']}{values['ГН']['Питание']}-{values['ГН']['Дополнительные параметры']}" if values['ГН']['Наличие'] != '-' else ''
            dn_part = f"{values['ДН']['Наличие']}{values['ДН']['Питание']}-{values['ДН']['Дополнительные параметры']}" if values['ДН']['Наличие'] != '-' else ''
            new_value = INNER_DELIMITER.join((part for part in (po_part, gn_part, dn_part) if part))
        case '1.7':
            new_value = f"{values['Питание']}{values['Силовая часть']}-{values['Управление']}"
        case '1.8':
            new_value = f"{values['Питание']}{values['Управление']}-{values['Опции']}"
        case '1.9':
            new_value = f"{values['Включение']}-{values['Дополнительные параметры']}"
        case '1.10':
            tr_part = f"{values['ТР']['Наличие']}{values['ТР']['Частотный преобразователь']}[{values['ТР']['Параметр контроля обмерзания']}]" if values['ТР']['Наличие'] != '-' else ''
            tp_part = f"{values['ТП']['Наличие']}{values['ТП']['Наличие перекрёстноточного теплоутилизатора']}[{values['ТП']['Параметр контроля обмерзания']}]-{values['ТП']['Управление приводом']}" if values['ТП']['Наличие'] != '-' else ''
            jt_part = f"{values['ЖТУ']['Наличие']}-{values['ЖТУ']['Питание насоса']}-{values['ЖТУ']['Опции насоса']}-{values['ЖТУ']['Питание привода']}{values['ЖТУ']['Управление привода']}{'-' + values['ЖТУ']['Опции привода'] if values['ЖТУ']['Опции привода'] != '-' else ''}" if values['ЖТУ']['Наличие'] != '-' else ''
            new_value = INNER_DELIMITER.join((part for part in (tr_part, tp_part, jt_part) if part))
        case '1.11':
            fu_part = f"{values['ФУ']['Наличие']}-{values['ФУ']['Питание насоса']}-{values['ФУ']['Опции для насоса']}-{values['ФУ']['Управление насосом']}" if values['ФУ']['Наличие'] != '-' else ''
            su_part = f"{values['СУ']['Наличие']}-{values['СУ']['Питание насоса']}-{values['СУ']['Опции для насоса']}-{values['СУ']['Управление насосом']}" if values['СУ']['Наличие'] != '-' else ''
            pu_part = f"{values['ПУ']['Наличие']}-{values['ПУ']['Питание парогенератора']}" if values['ПУ']['Наличие'] != '-' else ''
            new_value = INNER_DELIMITER.join((part for part in (fu_part, su_part, pu_part) if part))
        case '1.12' | '1.13':
            part_1 = f"{values['Параметры двигателя']['Питание']}-{values['Параметры двигателя']['Опции']}"
            part_2 = '-'.join(value for value in values['Тип управления двигателем'].values() if value != '-')
            part_3 = f"-{values['Резервирование']}" if values['Резервирование'] != '-' else ''
            part_4 = '-inner_delimiter+'.join(f"{values['Приводы отсечных клапанов']['Питание привода']}{values['Приводы отсечных клапанов']['Управление приводом']}{qwe}{'-' + values['Приводы отсечных клапанов']['Дополнительные параметры'] if values['Приводы отсечных клапанов']['Дополнительные параметры'] != '-' else ''}" for qwe in values['Приводы отсечных клапанов']['Отсечной клапан'].split('/')) if values['Приводы отсечных клапанов']['Наличие'] == '+' else ''
            new_value = f"{part_1}{'-' + part_2 if part_2 else ''}{part_3}{part_4}"
        case '1.14':
            new_value = f"{values['Тип']}{values['Назначение']}{values['Тип сигнала']}"
    return new_value

def create_automation_devices(code:str, amount:int, *args) -> list:
    """Создаёт строку для таблицы устройств автоматики

    Args:
        code (str): текущий код
        amount (int): текущее количество

    Returns:
        list: текущая строка
    """
    c_auto_desi = []
    match code:
        case '1.4':
            c_auto_desi = [[
                'Реле перепада для контроля запыленности фильтра с комплектом монтажных изделий',
                f"Диапазон:\n{args[0]}",  # Здесь будет диапазон перепада давления
                f'{amount} шт.'
            ]]
            pass
        case '1.5':  # Это чуть ли не единственный случай, когда нам надо добавить аж два прибора автоматики, и если с датчиком защиты от замораживания всё просто, то с капиллярами...
            c_auto_desi = [[
                f"Датчик защиты от замораживания по {'теплоносителю' if args[0] else 'воде'} с крепежным хомутом",  # Здесь переменная the_liquid
                'ДТС224-РТ1000.В2.43/2',
                f'{amount} шт.'
            ]]
            shlang_lengths = [tuple(map(int, shlang_term.split('х'))) for shlang_term in args[1].split(' + ')]
            for shlang_length in shlang_lengths:  # Здесь все шланги (множество, сплитованное по +)
                c_auto_desi.append([
                    f"Термостат защиты от замораживания по воздуху с комплектом монтажных изделий{' (для ТО' + str(amount) + ')' if args[2] > 6 else ''}",  # Здесь указание схемы. Ещё логика в том, что если у нас гликоля больше 40%, то шланг нужен лишь для второго датчика
                    f'Длина капилляра:\n{shlang_length[1]}м',
                    f'{(amount - 1 if args[2] > 6 else amount) * shlang_length[0]} шт.'
                ])
            pass
        case '1.10':
            if CODES_WITH_CODES[code]['ТР']['Наличие']['присутствует'] == args[1]:  # Здесь должно быть обозначение, короче
                c_auto_desi += [[
                    'Реле перепада для контроля обмерзания роторного теплоутилизатора с комплектом монтажных изделий',
                    f"Диапазон:\n{args[0]}",  # Здесь будет диапазон перепада давления range_select(150)
                    f"{sum(CODES_WITH_CODES[code]['ТР']['Наличие']['присутствует'] in args_args for args_args in args[1].split(INNER_DELIMITER))} шт."
                ]]
            if CODES_WITH_CODES[code]['ТП']['Наличие']['присутствует'] == args[1]:
                c_auto_desi += [[
                    'Реле перепада для контроля обмерзания пластинчатого теплоутилизатора с комплектом монтажных изделий',
                    f"Диапазон:\n{args[0]}",  # Здесь будет диапазон перепада давления range_select(150)
                    f"{sum(CODES_WITH_CODES[code]['ТП']['Наличие']['присутствует'] in args_args for args_args in args[1].split(INNER_DELIMITER))} шт."
                ]]
            if CODES_WITH_CODES[code]['ЖТУ']['Наличие']['присутствует'] == args[1]:
                c_auto_desi += [[  # Тут нужен будет этот датчик, причём тут всегда по теплоносителю - видимо, воду сюда не пускают
                    f"Датчик защиты от замораживания по теплоносителю с крепежным хомутом",
                    'ДТС224-РТ1000.В2.43/2',
                    f"{sum(CODES_WITH_CODES[code]['ЖТУ']['Наличие']['присутствует'] in args_args for args_args in args[1].split(INNER_DELIMITER))} шт."
                ]]
            pass
        case '1.12' | '1.13':
            c_auto_desi = [[
                'Реле перепада для контроля работы вентилятора с комплектом монтажных изделий',
                f"Диапазон:\n{args[0]}",  # Здесь будет диапазон перепада давления по выбираемому давлению
                f'{amount} шт.'
            ]]
            pass
        case '1.14':
            sensor_PDC, sensor_TET, sensor_HEP, sensor_TEP, sensor_TEU, sensor_TEK, sensor_TER, curr_TEK_amount = args[0]
            if sensor_HEP:
                c_auto_desi += [[
                    'Датчик температуры и относительной влажности воздуха в помещении',
                    'ПВТ100-Н4.2.И',
                    '1 шт.']]
            if sensor_TEP:
                c_auto_desi += [[
                    'Датчик температуры воздуха в помещении',
                    'ДТС125Л РТ1000.В2.60',
                    '1 шт.']]
            if sensor_TEU:
                c_auto_desi += [[
                    'Датчик температуры наружного воздуха',
                    'ДТС125Л РТ1000.В2.60',
                    '1 шт.']]
            if sensor_TEK:
                c_auto_desi += [[
                    'Канальный датчик температуры приточного воздуха с установочным фланцем',
                    'ДТС405PT1000.В2.320',
                    f'{curr_TEK_amount} шт.']]
            if sensor_TER:
                c_auto_desi += [[
                    'Канальный датчик температуры воздуха в камере смешения c установочным фланцем',
                    'ДТС405PT1000.В2.320',
                    '1 шт.']]
            pass
    return c_auto_desi

def create_circuit_design(code:str, index:int, amount:int, *args) -> list:
    """Функция, создающая маркировку для занесения в таблицу. На выходе даёт строчки таблицы из двух столбцов

    Args:
        code (str): текущий код
        index (int): текущий индекс
        amount (int): текущее количество

    Returns:
        list: circ_desi - строчка для таблицы
    """
    circ_desi = []

    match code:
        case '1.3':  # args: тип клапана, обозначение для нагревателя, азвание привода клапана
            if args[0] == CODES_WITH_CODES[code]['Типы клапанов']['рециркуляционный клапан']:
                valve_type = 'Кр'
            elif args[0] == CODES_WITH_CODES[code]['Типы клапанов']['воздухозаборный клапан (на входе в установку)']:
                valve_type = 'К'
            elif args[0] == CODES_WITH_CODES[code]['Типы клапанов']['приточный клапан (на выходе из установки)']:
                valve_type = 'Кп'
            elif args[0] == CODES_WITH_CODES[code]['Типы клапанов']['вытяжной клапан']:
                valve_type = 'Кв'
            elif args[0] == CODES_WITH_CODES[code]['Типы клапанов']['противопожарный (огнезадерживающий) клапан']:
                valve_type = 'Ко'
            circ_desi = [index, f"{valve_type}{args[1]}({args[2]})"]
        case '1.4':
            circ_desi = [index, f"Ф{amount}"]
        case '1.5':  # args: pump_phase_begin (начало фазы)
            circ_desi = [index, f'ТО{amount}({args[0]})']
        case '1.6':
            if args[0] == CODES_WITH_CODES[code]['ПО']['Наличие']['присутствует']:
                circ_desi = [index, f"ПО"]
            if args[0] == CODES_WITH_CODES[code]['ГН']['Наличие']['присутствует']:
                circ_desi = [index, f"ГН"]
            if args[0] == CODES_WITH_CODES[code]['ДН']['Наличие']['присутствует']:
                circ_desi = [index, f"ДН"]
        case '1.7':  # args: electric_heater_steps, electric_heater_power
            circ_desi = [index, f'ЭК{amount}({args[0]}кВт; ~{args[1]})']
            pass
        case '1.8':
            circ_desi = [index, f'ХО{amount}']
        case '1.9':
            circ_desi = [index, 'ФО']
        case '1.10':  # args: CODES_WITH_CODES[code]['ТР']['Наличие']['присутствует'], drive_unit для пластинчатого рекуператора
            if args[0] == CODES_WITH_CODES[code]['ТР']['Наличие']['присутствует']:
                circ_desi = [index, f"ТР({args[1]})"]
            if args[0] == CODES_WITH_CODES[code]['ТП']['Наличие']['присутствует']:
                circ_desi = [index, f"ТП({args[1]})"]
            if args[0] == CODES_WITH_CODES[code]['ЖТУ']['Наличие']['присутствует']:
                circ_desi = [index, f"ЖТУ({args[1]})"]
        case '1.11':
            if args[0] == CODES_WITH_CODES[code]['ФУ']['Наличие']['присутствует']:
                circ_desi = [index, "ФУ"]
            if args[0] == CODES_WITH_CODES[code]['СУ']['Наличие']['присутствует']:
                circ_desi = [index, f"СУ({0.31}кВт; ~1)"]
            if args[0] == CODES_WITH_CODES[code]['ПУ']['Наличие']['присутствует']:
                circ_desi = [index, "ПУ"]
        case '1.12' | '1.13':  # args: for_curr_typical_circuit_design_part_1, for_curr_typical_circuit_design
            circ_desi = [index, f"{args[0]}{args[1]}"]

    return circ_desi

def for_1_14(all_results:dict, all_amounts:dict, the_backup_venti_unit:bool) -> list:
    """Нам нужно записать все датчики так же, как мы записывали все предыдущие пункты - в массив, а потом соединить через плюсы. Всего может быть максимум семь разных обозначений и датчиков (их названия максимально красноречивые и дают понять, для чего они нужны). У каждого датчика есть условия, при которых они появляются. Всё подробно расписано внутри данной функции

    Args:
        all_results (dict): все результаты
        all_amounts (dict): все количества
        the_backup_venti_unit (bool): резервная ли установка

    Returns:
        list: sensor_PDC, sensor_TET, sensor_HEP, sensor_TEP, sensor_TEU, sensor_TEK, sensor_TER, curr_TEK_amount - семь датчиков и одно нужное для другой функции значение
    """
    sensor_PDC = ''  # PDC - реле перепада для контроля чего бы то ни было. Как мы помним, по ходу текста, разные (всего их четыре) варианта реле перепада возникали в тех или иных местах
    sensor_TET = ''  # TET - датчик защиты от замораживания по воде с крепежным хомутом
    sensor_HEP = ''  # HEP - датчик температуры и относительной влажности воздуха в помещении
    sensor_TEP = ''  # TEP - датчик температуры воздуха в помещении
    sensor_TEU = ''  # TEU - датчик температуры наружного воздуха
    sensor_TEK = ''  # TEK - канальный датчик температуры приточного воздуха с установочным фланцем
    sensor_TER = ''  # TER - канальный датчик температуры воздуха в камере смешения с установчным фланцем
    curr_TEK_amount = 0

    room_temperature_and_relative_humidity_sensor = (CODES_WITH_CODES['1.7']['Управление']['работа в режиме «Лето» совместно с охладителем для осушения воздуха'] in all_results['1.7']) or (CODES_WITH_CODES['1.11']['ФУ']['Наличие']['присутствует'] in all_results['1.11']) or (CODES_WITH_CODES['1.11']['СУ']['Наличие']['присутствует'] in all_results['1.11'])
    room_temperature_sensor = all_results['1.9'] != '0'

    # PDC_amount = filter_amount + venti_1_amount + venti_2_amount + heat_recovery_amount  # реле перепада бывают на фильтрах, вентиляторах и рекуператорах, и их количество равно общему количеству всех тех позиций
    PDC_amount = all_amounts['1.4'] + all_amounts['1.12'] + all_amounts['1.13'] + all_amounts['1.10']
    # pdmo(PDC_amount)
    if PDC_amount > 0:  # Если есть в них необходимость, то...
        sensor_PDC = CODES_WITH_CODES['1.14']['Тип']['реле перепада давления'] + CODES_WITH_CODES['1.14']['Назначение']['контроль работы(перепада)']  # ...ну, добавляем
        if PDC_amount > 1:  # Если их больше одного, надо указать число в квадратных скобках, иначе не надо
            sensor_PDC += f"[{PDC_amount}]"

    if all_amounts['1.5'] > 0 or CODES_WITH_CODES["1.10"]["ЖТУ"]["Наличие"]["присутствует"] in all_results['1.10']:  # Датчик защиты от замораживания по воде с крепежным хомутом нужен если есть жидкостный нагреватель ИЛИ есть ЖТУ
        sensor_TET = CODES_WITH_CODES['1.14']['Тип']['датчик температуры'] + CODES_WITH_CODES['1.14']['Назначение']['на теплоносителе'] + CODES_WITH_CODES['1.14']['Тип сигнала']['Pt1000']

    if room_temperature_and_relative_humidity_sensor:  # На протяжении всего текста мы иногда задавали этой переменной значение истины - это нужно, потому что если есть этот датчик, то не будет датчика температур. В общем случае, датчик температуры и относительной влажности воздуха в помещении нужен, если есть либо сотовый увлажнитель, либо форсуночный увлажнитель, либо ещё что-то, что я не помню, но помнит код
        sensor_HEP = CODES_WITH_CODES['1.14']['Тип']['датчик влажности'] + CODES_WITH_CODES['1.14']['Назначение']['помещение'] + CODES_WITH_CODES['1.14']['Тип сигнала']['4...20мА']
    elif not room_temperature_and_relative_humidity_sensor and room_temperature_sensor:  # Датчик температуры воздуха в помещении нуже, если есть фреоновый охладитель. Однако если есть фреоновый охладитель, и есть что-то, что требует датчика температуры и влажности, то ставится более общий датчик
        sensor_TEP = CODES_WITH_CODES['1.14']['Тип']['датчик температуры'] + CODES_WITH_CODES['1.14']['Назначение']['уличный'] + CODES_WITH_CODES['1.14']['Тип сигнала']['Pt1000']

    TEU_amount = all_amounts['1.5'] + all_amounts['1.6'] + all_amounts['1.7'] + all_amounts['1.8'] + all_amounts['1.9'] #+ heat_exchanger_amount  # Датчик температуры наружного воздуха ставится, если есть процесс обработки воздуха. То есть, если есть теплообменник, какой-либо другой нагреватель, электронагреватель, если есть охлаждение (жидкостное или фреоновое). Ещё он ставится, если есть рециркуляционный клапан, но только если не выполняются все предыдущие условия. Так что пока будет проверяться первое условие - наличие всех вышеуказанных элементов
    
    if TEU_amount > 0:  # Если есть хотя бы что-то из вышеуказанного...
        sensor_TEU = CODES_WITH_CODES['1.14']['Тип']['датчик температуры'] + CODES_WITH_CODES['1.14']['Назначение']['уличный'] + CODES_WITH_CODES['1.14']['Тип сигнала']['Pt1000']
        
        if not (all_amounts['1.9'] > 0 and (TEU_amount - all_amounts['1.9']) == 0):  # Проблемы начинаются дальше, потому что одновременно с этим нужно определить, ставится ли канальный датчик температуры приточного воздуха с установочным фланцем, потому что он ставится во всех предыдущих случаях, КРОМЕ случая, когда есть ТОЛЬКО фреоновое охлаждение
            if CODES_WITH_CODES['1.7']['Управление']['работа в режиме «Зима» по своему датчику температуры'] in all_results['1.7']:  # А ещё тип сигнала отличается от того, как работает электронагреватель. Тут я принимаю слова автоматчиков на веру
                sygnal_type = CODES_WITH_CODES['1.14']['Тип сигнала']['Ni1000']
                curr_TEK_amount = 2  # И я не знаю, почему, но в таком случае будет два датчика
            else:
                sygnal_type = CODES_WITH_CODES['1.14']['Тип сигнала']['Pt1000']
                curr_TEK_amount = 1
            if the_backup_venti_unit or 'Внести данные из бланка вручную' in all_results['1.5']:  # А если есть ещё резервная установка, то нужен ещё один датчик сверху
                curr_TEK_amount += 1
            sensor_TEK = CODES_WITH_CODES['1.14']['Тип']['датчик температуры'] + CODES_WITH_CODES['1.14']['Назначение']['канальный'] + sygnal_type  # Правда в бланке для завода всё равно количество не пишется, так что оно нужно лишь в таблице приборов автоматики

    if CODES_WITH_CODES["1.3"]["Типы клапанов"]["рециркуляционный клапан"][:2] in all_results['1.3']:  # С рециркуляцией всё сложно. Если она есть, то ставится датчик температуры наружного воздуха, однако он ставится в тех случаях, когда уже есть TEK и/или TEU. Если их нет, но есть рециркуляция, то нужно оба этих дватчика вставить.
        if sensor_TEK or sensor_TEU:  # Собственно, да - есть любой из этих двух датчиков, ставим TER
            sensor_TER = CODES_WITH_CODES['1.14']['Тип']['датчик температуры'] + CODES_WITH_CODES['1.14']['Назначение']['смешение'] + CODES_WITH_CODES['1.14']['Тип сигнала']['Pt1000']
        else:  # Нет - ставим оба датчика. Очевидно, что тут нет смысла проверять, будет ли только фреоновый охладитель - его не может быть по определению. Делаем то же, что и в прошлый раз. Сможете придумать, как это оптимизировать - флаг вам в руки
            sensor_TEU = CODES_WITH_CODES['1.14']['Тип']['датчик температуры'] + CODES_WITH_CODES['1.14']['Назначение']['уличный'] + CODES_WITH_CODES['1.14']['Тип сигнала']['Pt1000']

            if CODES_WITH_CODES['1.7']['Управление']['работа в режиме «Зима» по своему датчику температуры'] in all_results['1.7']:
                sygnal_type = CODES_WITH_CODES['1.14']['Тип сигнала']['Ni1000']
                curr_TEK_amount = 2
            else:
                sygnal_type = CODES_WITH_CODES['1.14']['Тип сигнала']['Pt1000']
                curr_TEK_amount = 1
            sensor_TEK = CODES_WITH_CODES['1.14']['Тип']['датчик температуры'] + CODES_WITH_CODES['1.14']['Назначение']['канальный'] + sygnal_type

    return [sensor_PDC, sensor_TET, sensor_HEP, sensor_TEP, sensor_TEU, sensor_TEK, sensor_TER, curr_TEK_amount]
    pass

# ====================================================================================================================================================================================

# ============================== ЭПИЛОГ ==============================
if __name__ == '__main__':  # Конкретно этот файл нужно запускать только ради одного - тестового прогона. При импорте мы сюда и не будем попадать, потому что нейм будет не равен мейн.
    test_automata()  # Очень долгое главной проблемой было научить программы отличать, что это не тестовый прогон. Раньше мне приходилось раз за разом закомменнчивать этот отрывок, но ещё чаще я забывал это сделать, так что у конечных пользователей оно вылетало с ошибкой, так как не находило тестовую папку. Теперь это всё существует по разным файлам, так что и проблемы нет. В этом основном файле существует только тестовый режим. Оконная форма теперь отдельно, веб-версия отдельно
# ============================== КОНЕЦ ЭПИЛОГА ==============================
